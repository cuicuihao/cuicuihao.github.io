<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>面试要点整理 ~ Hexo</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>cuicuihao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期日, 十二月 1日 2019, 4:13 下午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    5.9k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      22 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <ol>
<li>http相关<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#https" target="_blank" rel="noopener">https</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http2-0" target="_blank" rel="noopener">http2.0</a></li>
<li>http三次握手和四次挥手<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#三次握手" target="_blank" rel="noopener">三次握手</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#四次挥手" target="_blank" rel="noopener">四次挥手</a></li>
</ol>
</li>
<li>常见的http头<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#请求头：" target="_blank" rel="noopener">请求头：</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#响应头" target="_blank" rel="noopener">响应头</a></li>
</ol>
</li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#常见的http代码" target="_blank" rel="noopener">常见的http代码</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http方法" target="_blank" rel="noopener">http方法</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#浏览器输入url到最终显示过程" target="_blank" rel="noopener">浏览器输入url到最终显示过程</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#get请求和post请求的区别" target="_blank" rel="noopener">get请求和post请求的区别</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器主动推送" target="_blank" rel="noopener">服务器主动推送</a></li>
</ol>
</li>
<li>ajax相关<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#ajax的优点" target="_blank" rel="noopener">ajax的优点</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#ajax的缺点" target="_blank" rel="noopener">ajax的缺点</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xml和json的比较" target="_blank" rel="noopener">xml和json的比较</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js解析json的方法" target="_blank" rel="noopener">js解析json的方法</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xmlhttprequest的readystate取值" target="_blank" rel="noopener">xmlhttprequest的readystate取值</a></li>
</ol>
</li>
<li>web安全相关<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#csrf" target="_blank" rel="noopener">csrf</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#xss" target="_blank" rel="noopener">xss</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#clickjacking" target="_blank" rel="noopener">clickjacking</a></li>
</ol>
</li>
<li>性能优化<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#内容优化" target="_blank" rel="noopener">内容优化</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器优化" target="_blank" rel="noopener">服务器优化</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js优化" target="_blank" rel="noopener">js优化</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#css优化" target="_blank" rel="noopener">css优化</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#图片优化" target="_blank" rel="noopener">图片优化</a></li>
</ol>
</li>
<li>vue相关<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#mvvm和mvc" target="_blank" rel="noopener">mvvm和mvc</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue双向数据绑定" target="_blank" rel="noopener">vue双向数据绑定</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue生命周期" target="_blank" rel="noopener">vue生命周期</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue组件通信" target="_blank" rel="noopener">vue组件通信</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vuex的作用" target="_blank" rel="noopener">vuex的作用</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#vue1-0和vue2-0的区别是什么" target="_blank" rel="noopener">vue1.0和vue2.0的区别是什么</a></li>
</ol>
</li>
<li>js相关<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#数据类型" target="_blank" rel="noopener">数据类型</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#判断数据类型" target="_blank" rel="noopener">判断数据类型</a></li>
<li>高级函数<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#惰性载入函数" target="_blank" rel="noopener">惰性载入函数</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#安全的类型检测" target="_blank" rel="noopener">安全的类型检测</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#作用域安全的构造函数" target="_blank" rel="noopener">作用域安全的构造函数</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#函数柯里化" target="_blank" rel="noopener">函数柯里化</a></li>
</ol>
</li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#判断数组" target="_blank" rel="noopener">判断数组</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#箭头函数和this" target="_blank" rel="noopener">箭头函数和this</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#this指向" target="_blank" rel="noopener">this指向</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#作用域" target="_blank" rel="noopener">作用域</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#词法分析" target="_blank" rel="noopener">词法分析</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#构造函数" target="_blank" rel="noopener">构造函数</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#new的操作" target="_blank" rel="noopener">new的操作</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#promise和async-await" target="_blank" rel="noopener">promise和async/await</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#闭包" target="_blank" rel="noopener">闭包</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js对象私有变量" target="_blank" rel="noopener">js对象私有变量</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js垃圾回收机制" target="_blank" rel="noopener">js垃圾回收机制</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#原型链" target="_blank" rel="noopener">原型链</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#rhs和lhs" target="_blank" rel="noopener">rhs和lhs</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#EventLoop" target="_blank" rel="noopener">EventLoop</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#WebSocket" target="_blank" rel="noopener">WebSocket</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#继承" target="_blank" rel="noopener">继承</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#创建对象" target="_blank" rel="noopener">创建对象</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js跨域" target="_blank" rel="noopener">js跨域</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#服务器推送" target="_blank" rel="noopener">服务器推送</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#多页面传参数" target="_blank" rel="noopener">多页面传参数</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#深拷贝和浅拷贝" target="_blank" rel="noopener">深拷贝和浅拷贝</a></li>
<li>js事件模型<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM0级模型" target="_blank" rel="noopener">DOM0级模型</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM2级模型" target="_blank" rel="noopener">DOM2级模型</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#IE事件模型" target="_blank" rel="noopener">IE事件模型</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#DOM事件模型和IE事件模型的区别" target="_blank" rel="noopener">DOM事件模型和IE事件模型的区别</a></li>
</ol>
</li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#严格模式" target="_blank" rel="noopener">严格模式</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#js模块化" target="_blank" rel="noopener">js模块化</a></li>
</ol>
</li>
<li>缓存和离线存储<ol>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http缓存" target="_blank" rel="noopener">http缓存</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#session-cookie-localStorage-sessionStorage" target="_blank" rel="noopener">session cookie localStorage sessionStorage</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#manifest" target="_blank" rel="noopener">manifest</a></li>
<li><a href="https://vevlins.github.io/2018/03/14/面试要点整理/#http缓存机制" target="_blank" rel="noopener">http缓存机制</a></li>
</ol>
</li>
</ol>
<h2 id="http相关"><a href="#http相关" class="headerlink" title="http相关"></a>http相关</h2><h3 id="https"><a href="#https" class="headerlink" title="https"></a>https</h3><p>Https可以理解为HTTP+SSL/TLS， 即 HTTP 下加入 SSL 层，即HTTP-SSL-TCP-IP,HTTPS 的安全基础是 SSL，因此加密的详细内容就需要 SSL，用于安全的 HTTP 数据传输.目前使用最广泛的是TLS 1.1、TLS 1.2。<br>HTTP面临的风险有：</p>
<ul>
<li>窃听风险</li>
<li>篡改风险</li>
<li>冒充风险</li>
</ul>
<p><img src="https://pic2.zhimg.com/80/v2-5e2241fae8b593ff7f3b3a308ef81c10_hd.jpg" srcset="undefined" alt="img"></p>
<h3 id="http2-0"><a href="#http2-0" class="headerlink" title="http2.0"></a>http2.0</h3><p>当前使用的协议是http1.1,http2.0(RFC 7540)需要现代浏览器和web服务器的支持，其发展于SPDY。<br>其特点有：</p>
<ul>
<li>二进制分帧</li>
<li>压缩头部</li>
<li>多路复用（请求优先级）</li>
<li>服务器推送</li>
</ul>
<h3 id="http三次握手和四次挥手"><a href="#http三次握手和四次挥手" class="headerlink" title="http三次握手和四次挥手"></a>http三次握手和四次挥手</h3><h4 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h4><p>第一次握手：主机A发送位码为syn＝1,随机产生seq number=x的数据包到服务器，客户端进入SYN_SEND状态，等待服务器的确认；主机B由SYN=1知道，A要求建立联机；</p>
<p>第二次握手：主机B收到请求后要确认联机信息，向A发送ack number(主机A的seq+1),syn=1,ack=1,随机产生seq=y的包,此时服务器进入SYN_RECV状态;</p>
<p>第三次握手：主机A收到后检查ack number是否正确，即第一次发送的seq number+1,以及位码ack是否为1，若正确，主机A会再发送ack number(主机B的seq+1),ack=1，主机B收到后确认seq值与ack=1则连接建立成功。客户端和服务器端都进入ESTABLISHED状态，完成TCP三次握手。</p>
<h4 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h4><p>第一次挥手：主机1（可以使客户端，也可以是服务器端），设置Sequence Number和Acknowledgment Number，向主机2发送一个FIN报文段；此时，主机1进入FIN_WAIT_1状态；这表示主机1没有数据要发送给主机2了；</p>
<p>第二次挥手：主机2收到了主机1发送的FIN报文段，向主机1回一个ACK报文段，Acknowledgment Number为Sequence Number加1；主机1进入FIN_WAIT_2状态；主机2告诉主机1，我也没有数据要发送了，可以进行关闭连接了；</p>
<p>第三次挥手：主机2向主机1发送FIN报文段，请求关闭连接，同时主机2进入CLOSE_WAIT状态；</p>
<p>第四次挥手：主机1收到主机2发送的FIN报文段，向主机2发送ACK报文段，然后主机1进入TIME_WAIT状态；主机2收到主机1的ACK报文段以后，就关闭连接；此时，主机1等待2MSL后依然没有收到回复，则证明Server端已正常关闭，那好，主机1也可以关闭连接了。</p>
<h3 id="常见的http头"><a href="#常见的http头" class="headerlink" title="常见的http头"></a>常见的http头</h3><h4 id="请求头："><a href="#请求头：" class="headerlink" title="请求头："></a>请求头：</h4><ul>
<li>Accept：接受的响应内容类型： text/plain</li>
<li>Cache-Control：是否使用缓存机制：no-cache</li>
<li>Origin：用于cors判断请求来源</li>
<li>Referer：访问的前一个页面</li>
<li>User-Agent：浏览器标识字符串</li>
</ul>
<h4 id="响应头"><a href="#响应头" class="headerlink" title="响应头"></a>响应头</h4><ul>
<li>Allow：允许的http方法</li>
<li>Content-Encoding：响应资源所使用的编码类型</li>
<li>ETag：资源版本的标识符</li>
<li>Expires：过期时间</li>
<li>Set-Cookie：设定cookie值</li>
</ul>
<h3 id="常见的http代码"><a href="#常见的http代码" class="headerlink" title="常见的http代码"></a>常见的http代码</h3><ul>
<li>1xx：临时响应</li>
<li>2xx：成功</li>
<li>3xx：重定向</li>
<li>4xx：客户端错误</li>
<li>5xx：服务器错误</li>
</ul>
<p>常见代码：</p>
<ul>
<li>301:永久移动</li>
<li>302：临时移动</li>
<li>304:未修改</li>
<li>400:不理解请求的语法</li>
<li>401:未授权</li>
<li>403:拒绝请求</li>
<li>405:不支持http方法</li>
<li>503:现在无法提供服务</li>
</ul>
<h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><ul>
<li>GET：获取资源</li>
<li>HEAD：获取报头</li>
<li>PUT：更新资源</li>
<li>POST：提交数据、新建资源</li>
<li>TRACE：检查http在过程中的变更</li>
<li>OPTIONS：返回支持的http方法</li>
<li>DELETE：删除页面</li>
<li>拓展方法如MOVE、COPY等</li>
</ul>
<h3 id="浏览器输入url到最终显示过程"><a href="#浏览器输入url到最终显示过程" class="headerlink" title="浏览器输入url到最终显示过程"></a>浏览器输入url到最终显示过程</h3><ul>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>连接结束</li>
</ul>
<h3 id="get请求和post请求的区别"><a href="#get请求和post请求的区别" class="headerlink" title="get请求和post请求的区别"></a>get请求和post请求的区别</h3><ul>
<li>get请求url长度受限制：url最大长度是2048个字符</li>
<li>get请求只能传输ascii字符</li>
<li>get请求可以显示在url中，所以安全性较差</li>
</ul>
<h3 id="服务器主动推送"><a href="#服务器主动推送" class="headerlink" title="服务器主动推送"></a>服务器主动推送</h3><ul>
<li>ajax轮询</li>
<li>Comet</li>
<li>Server-Sent</li>
<li>WebSocket</li>
</ul>
<h2 id="ajax相关"><a href="#ajax相关" class="headerlink" title="ajax相关"></a>ajax相关</h2><h3 id="ajax的优点"><a href="#ajax的优点" class="headerlink" title="ajax的优点"></a>ajax的优点</h3><ul>
<li>异步加载，优化用户体验</li>
<li>减少了与服务器之间不必要的传输</li>
<li>实现局部刷新</li>
<li>把服务器的负担转移到客户端</li>
</ul>
<h3 id="ajax的缺点"><a href="#ajax的缺点" class="headerlink" title="ajax的缺点"></a>ajax的缺点</h3><ul>
<li>不支持浏览器的历史记录</li>
<li>对搜索引擎的支持差</li>
</ul>
<h3 id="xml和json的比较"><a href="#xml和json的比较" class="headerlink" title="xml和json的比较"></a>xml和json的比较</h3><ul>
<li>xml解码难度大，json是js的子集，解析容易</li>
<li>xml占据了较早的市场</li>
<li>xml数据描述性更好</li>
<li>json体积小，传输速度快</li>
</ul>
<h3 id="js解析json的方法"><a href="#js解析json的方法" class="headerlink" title="js解析json的方法"></a>js解析json的方法</h3><ul>
<li>eval</li>
<li>new Function</li>
<li>JSON.parse</li>
</ul>
<h3 id="xmlhttprequest的readystate取值"><a href="#xmlhttprequest的readystate取值" class="headerlink" title="xmlhttprequest的readystate取值"></a>xmlhttprequest的readystate取值</h3><p>readyState属性 请求的状态 有5个可取值0=未初始化 ，1=正在加载，2=已加载，3=交互中，4=完成</p>
<h2 id="web安全相关"><a href="#web安全相关" class="headerlink" title="web安全相关"></a>web安全相关</h2><h3 id="csrf"><a href="#csrf" class="headerlink" title="csrf"></a>csrf</h3><p>csrf：跨站请求伪造。借助用户本地存储的cookie进行恶意的请求伪造。解决方案是检查其http-refer和制作token在请求中一并发送。</p>
<h3 id="xss"><a href="#xss" class="headerlink" title="xss"></a>xss</h3><p>xss：跨站脚本攻击。攻击者将恶意的js代码插入到页面中。分为基于反射的，基于存储的，基于dom的。解决方案是通过检查过滤用户输入的数据。</p>
<h3 id="clickjacking"><a href="#clickjacking" class="headerlink" title="clickjacking"></a>clickjacking</h3><p>clickjacking：设置iframe指向其他网站并且将其设置为透明，诱骗用户填入信息并触发请求。解决方案为在响应头中设置X-Frame-Options，可选为3个DENY、SAMEORIGIN、ALLOW-FROM。</p>
<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><h3 id="内容优化"><a href="#内容优化" class="headerlink" title="内容优化"></a>内容优化</h3><ul>
<li>减少http请求</li>
<li>dns预解析</li>
<li>减少iframe</li>
</ul>
<h3 id="服务器优化"><a href="#服务器优化" class="headerlink" title="服务器优化"></a>服务器优化</h3><ul>
<li>静态资源cookie隔离</li>
<li>cdn</li>
<li>gzip压缩</li>
<li>etag</li>
<li>避免空的图像src</li>
<li>开启缓存</li>
</ul>
<h3 id="js优化"><a href="#js优化" class="headerlink" title="js优化"></a>js优化</h3><ul>
<li>减少dom操作</li>
<li>减少长作用域链查找</li>
<li>在底部加载</li>
</ul>
<h3 id="css优化"><a href="#css优化" class="headerlink" title="css优化"></a>css优化</h3><ul>
<li>采用link而不是import</li>
<li>css放在顶部</li>
<li>尽量避免使用css表达式</li>
<li>减少选择器嵌套</li>
<li>减少css动画</li>
</ul>
<h3 id="图片优化"><a href="#图片优化" class="headerlink" title="图片优化"></a>图片优化</h3><ul>
<li>压缩图片</li>
<li>sprites</li>
<li>使用图标字体</li>
<li>懒加载</li>
</ul>
<h2 id="vue相关"><a href="#vue相关" class="headerlink" title="vue相关"></a>vue相关</h2><h3 id="mvvm和mvc"><a href="#mvvm和mvc" class="headerlink" title="mvvm和mvc"></a>mvvm和mvc</h3><ul>
<li>mvc：view-controller-model-view 单向传递</li>
<li>mvvm：view-viewmodel-model 双向传递</li>
</ul>
<h3 id="vue双向数据绑定"><a href="#vue双向数据绑定" class="headerlink" title="vue双向数据绑定"></a>vue双向数据绑定</h3><p>通过Object.defineProperty()实现数据劫持，在数据变动时发布消息给订阅者，触发相应的监听回调。</p>
<ul>
<li>实现一个数据监听器Observer，能够对数据对象的所有属性进行监听，如有变动可拿到最新值并通知订阅者。defineProperty</li>
<li>实现一个指令解析器Compile，对每个元素节点的指令进行扫描和解析，根据指令模板替换数据，以及绑定相应的更新函数。createDocumentFragment</li>
<li>实现一个Watcher，作为连接Observer和Compile的桥梁，能够订阅并收到每个属性变动的通知，执行指令绑定的相应回调函数，从而更新视图。 订阅发布模式定义了一种一对多的关系，让多个观察者同时监听某一个主题对象，这个主题对象的状态发生改变时就会通知所有观察者对象</li>
<li>mvvm入口函数，整合以上三者</li>
</ul>
<h3 id="vue生命周期"><a href="#vue生命周期" class="headerlink" title="vue生命周期"></a>vue生命周期</h3><p>beforeCreate（创建前）,created（创建后），beforeMount(载入前),mounted（载入后）,beforeUpdate（更新前）,updated（更新后）,beforeDestroy（销毁前）,destroyed（销毁后）</p>
<h3 id="vue组件通信"><a href="#vue组件通信" class="headerlink" title="vue组件通信"></a>vue组件通信</h3><ul>
<li>父组件向子组件传递：父组件写在标签内，子组件通过通过props获取</li>
<li>子组件向父组件传递：<code>$emit</code>发送事件</li>
<li>兄弟组件传递：实例化一个第三方vue实例，<code>$emit</code>触发事件,<code>$on</code>接收事件</li>
</ul>
<h3 id="vuex的作用"><a href="#vuex的作用" class="headerlink" title="vuex的作用"></a>vuex的作用</h3><p>VueX 是一个专门为 Vue.js 应用设计的状态管理架构，统一管理和维护各个vue组件的可变化状态。当单独使用Vue.js,我们常常倾向于存储状态我们的组件内。也就是说,每个组件属于我们的应用程序状态,因此结果状态乱扔的到处都是。然而,有时一块状态需要由多个组件共享。常见的做法是让一个组件“发送”一些使用自定义事件系统其他组件。这种模式的问题是内部的事件流大组件树很快就变得复杂,通常很难原因时出现错误。</p>
<h3 id="vue1-0和vue2-0的区别是什么"><a href="#vue1-0和vue2-0的区别是什么" class="headerlink" title="vue1.0和vue2.0的区别是什么"></a>vue1.0和vue2.0的区别是什么</h3><ul>
<li>vue2.0代码必须包裹在一个根元素</li>
<li>vue2.0的生命周期发生了很大的变化</li>
</ul>
<h2 id="js相关"><a href="#js相关" class="headerlink" title="js相关"></a>js相关</h2><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>基本数据类型：String、Number、Boolean、Undefined、Null、Symbol</li>
<li>引用类型：object、array、function</li>
</ul>
<h3 id="判断数据类型"><a href="#判断数据类型" class="headerlink" title="判断数据类型"></a>判断数据类型</h3><ul>
<li>typeof：对null返回object、无法判断array、date等类型</li>
<li>instanceof：检测两个对象是否实例关系</li>
<li>constructor：无法判断null和undefined，重写prototype之后constructor丢失默认为Object</li>
<li>Object.prototype.toString.call</li>
</ul>
<h3 id="高级函数"><a href="#高级函数" class="headerlink" title="高级函数"></a>高级函数</h3><p>惰性函数、柯里化、</p>
<h4 id="惰性载入函数"><a href="#惰性载入函数" class="headerlink" title="惰性载入函数"></a>惰性载入函数</h4><p>在浏览器功能检测中，函数的分支当第一次确定时就将分支内的函数作为返回值，这样就改变了这个函数。在以后加载中避免了每次都判断。</p>
<pre><code>function addEvent (type, element, fun) {
    if (element.addEventListener) {
        addEvent = function (type, element, fun) {
            element.addEventListener(type, fun, false);
        }
    }
    else if(element.attachEvent){
        addEvent = function (type, element, fun) {
            element.attachEvent(&#39;on&#39; + type, fun);
        }
    }
    else{
        addEvent = function (type, element, fun) {
            element[&#39;on&#39; + type] = fun;
        }
    }
    return addEvent(type, element, fun);
}</code></pre><h4 id="安全的类型检测"><a href="#安全的类型检测" class="headerlink" title="安全的类型检测"></a>安全的类型检测</h4><p>通过toString方法来检测传入参数的类型，以判断是否进行下一步操作。</p>
<pre><code>  Object.prototype.toString.call(value)</code></pre><h4 id="作用域安全的构造函数"><a href="#作用域安全的构造函数" class="headerlink" title="作用域安全的构造函数"></a>作用域安全的构造函数</h4><p>构造函数如果没有new，那么构造函数内部的this指向全局也就是window对象。先用instance判断一下this指向，如果不是指向构造函数，那么返回一个new实例化的对象。</p>
<pre><code>function Person(name){
    if(this instanceof Person){
        this.name = name;
    }else{
        return new Person(name)
    }
}</code></pre><h4 id="函数柯里化"><a href="#函数柯里化" class="headerlink" title="函数柯里化"></a>函数柯里化</h4><p>它用于创建已经设置好了一个或者多个参数的函数，函数柯里化的基本方法和函数绑定是一样的，使用一个闭包返回一个函数。</p>
<pre><code> //普通的add版本
function add(num1, num2){
    return num1 + num2;
}
//第一个参数为5的add版本
function curriedAdd5(num2){
    return add(5, num2)
}

function curry(fn, context){
//截取调用curry时候，除了fn,context,之后的所有参数
    var args =[].slice.call(arguments,2);
    return function(){
//获取调用fn的所有参数
        var totalArgs = args.concat([].slice.call(arguments));
        return fn.apply(context, totalArgs);
    }
}

var curriedAdd5 = curry(add, null, 5)</code></pre><h3 id="判断数组"><a href="#判断数组" class="headerlink" title="判断数组"></a>判断数组</h3><ul>
<li>instanceof</li>
<li>toString</li>
<li>constructor</li>
</ul>
<h3 id="箭头函数和this"><a href="#箭头函数和this" class="headerlink" title="箭头函数和this"></a>箭头函数和this</h3><p>箭头函数没有它自己的this值，箭头函数内的this值继承自外围作用域。箭头函数的this其实就是在定义的时候就确定好的，以后不管怎么调用这个箭头函数，箭头函数的this始终为定义时的this。箭头函数没有arguments，可以用剩余参数代替。箭头函数不要再对象的方法中、作为构造函数、定义原型方法时使用。</p>
<h3 id="this指向"><a href="#this指向" class="headerlink" title="this指向"></a>this指向</h3><ul>
<li>函数调用模式-全局调用：指向全局对象也就是window，包括在函数方法中嵌套的</li>
<li>方法调用模式：指向上层对象</li>
<li>构造器调用模式：通过new构造的this指向新的对象</li>
<li>apply、call、bind等调用模式：指向传入的对象</li>
</ul>
<h3 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h3><p>只有函数可以限定一个变量的作用范围，即函数才是变量的作用域。在ES6之前，JavaScript没有块级作用域(一对花括号{}即为一个块级作用域)，只有全局作用域和函数作用域。</p>
<h3 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h3><p>函数在运行的瞬间，生成一个活动对象（Active Object），简称AO</p>
<ul>
<li>第一步：分析参数：函数接收形式参数，添加到AO的属性，并且这个时候值为undefine,即AO.age=undefined，接收实参，添加到AO的属性，覆盖之前的undefined</li>
<li>第二步：分析变量声明：如var age;或var age=18;如果上一步分析参数中AO还没有age属性，则添加AO属性为undefined，即AO.age=undefine，如果AO上面已经有age属性了，则不作任何修改</li>
<li>第三步：分析函数的声明：如果有function age(){}把函数赋给AO.age ,覆盖上一步分析的值</li>
</ul>
<h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><p>首字母大写，内部用this的函数，最后通过new来进行实例化。<br>构造函数的返回值有以下几种情况：</p>
<ul>
<li>没有返回值时返回实例化的对象。</li>
<li>返回值为基本数据类型时返回实例化的对象，用来两用函数。</li>
<li>返回值为引用类型时，返回该引用类型。</li>
</ul>
<h3 id="new的操作"><a href="#new的操作" class="headerlink" title="new的操作"></a>new的操作</h3><p>相当于以下步骤：</p>
<pre><code>var obj = {}
obj._proto_ = Co.prototyoe
Co.call(obj)
return obj</code></pre><h3 id="promise和async-await"><a href="#promise和async-await" class="headerlink" title="promise和async/await"></a>promise和async/await</h3><p>promise的三种状态pending（进行中）、fulfilled（已成功）和rejected（已失败）。两个参数resolve和reject。</p>
<h3 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h3><p>闭包是由函数以及创建该函数的词法环境组合而成。这个环境包含了这个闭包创建时所能访问的所有局部变量。(MDN)用来访问另一个函数作用域链上的变量的函数。由于该变量被其他函数饮用所以内存回收机制导致其不会立即清除，也就是其定义时的上下文被记住，起到了记忆功能。</p>
<h3 id="js对象私有变量"><a href="#js对象私有变量" class="headerlink" title="js对象私有变量"></a>js对象私有变量</h3><ul>
<li>_开头的编码约定</li>
<li>基于闭包构造特权函数，缺点是无法挂载在prototype上，无法实现共享</li>
<li>强引用散列表</li>
<li>基于ES6的WeakMap</li>
</ul>
<h3 id="js垃圾回收机制"><a href="#js垃圾回收机制" class="headerlink" title="js垃圾回收机制"></a>js垃圾回收机制</h3><p>JavaScript的解释器可以检测到何时程序不再使用一个对象了，当他确定了一个对象是无用的时候，他就知道不再需要这个对象，可以把它所占用的内存释放掉了。现在各大浏览器通常用采用的垃圾回收有两种方法：标记清除、引用计数。优化垃圾回收的主要思想是避免新建对象，而是尽量复用。比如delete obj的属性，而非new Object()。设置arr.length = 0而非 arr = []。</p>
<p>可能会导致内存泄漏的操作有：</p>
<ul>
<li>意外的全局变量</li>
<li>被遗忘的定时器或回调</li>
<li>没有清理的DOM元素引用</li>
<li>不恰当的闭包</li>
</ul>
<h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><p><img src="https://pic1.zhimg.com/80/e83bca5f1d1e6bf359d1f75727968c11_hd.jpg" srcset="undefined" alt="img"></p>
<h3 id="rhs和lhs"><a href="#rhs和lhs" class="headerlink" title="rhs和lhs"></a>rhs和lhs</h3><p>rhs为取值，lhs为赋值。<br>如果在rhs的所有嵌套的作用域查询中都无法找到该变量,js引擎就会抛出一个ReferenceError异常. ReferenceError是一个重要的异常.<br>相较之下， 当引擎执行 LHS 查询时， 如果在顶层（ 全局作用域） 中也无法找到目标变量，<br>全局作用域中就会创建一个具有该名称的变量， 并将其返还给引擎， 前提是程序运行在非 “ 严格模式” 下。</p>
<h3 id="EventLoop"><a href="#EventLoop" class="headerlink" title="EventLoop"></a>EventLoop</h3><p>函数调用形成了一个栈帧。对象被分配在一个堆中，即用以表示一个大部分非结构化的内存区域。一个待处理的消息队列。当栈拥有足够内存时并且满足触发条件(如setTimeout)从队列中取出一个消息进行处理。一个 web worker 或者一个跨域的iframe都有自己的栈，堆和消息队列。两个不同的运行时只能通过 postMessage方法进行通信。如果后者侦听到message事件，则此方法会向其他运行时添加消息。</p>
<p>js所谓的单线程，是指在JS引擎中负责解释和执行JavaScript代码的线程只有一个。不妨叫它主线程。实际上还存在其他的线程。例如：处理AJAX请求的线程、处理DOM事件的线程、定时器线程、读写文件的线程(例如在Node.js中)等等。这些线程可能存在于JS引擎之内，也可能存在于JS引擎之外，在此我们不做区分。不妨叫它们工作线程。</p>
<p>一个异步过程：主线程发起一个异步请求，相应的工作线程接收请求并告知主线程已收到(异步函数返回)；主线程可以继续执行后面的代码，同时工作线程执行异步任务；工作线程完成工作后，通知主线程；主线程收到通知后，执行一定的动作(调用回调函数)。</p>
<h3 id="WebSocket"><a href="#WebSocket" class="headerlink" title="WebSocket"></a>WebSocket</h3><p>HTTP 协议有一个缺陷：通信只能由客户端发起。HTTP 协议做不到服务器主动向客户端推送信息。WebSocket最大的特点就是服务器可以主动向服务器发送信息，客户端也可以向服务器端主动发送信息。SSE是单向推送，利用EventSource，content-type设置为text/event-stream。</p>
<p>特点有以下：</p>
<ul>
<li>建立在TCP之上</li>
<li>默认端口也是ws80和wss443，握手阶段采用http协议。</li>
<li>数据格式轻，性能开销小</li>
<li>可以发送文本和二进制文件</li>
<li>没有同源策略的限制</li>
</ul>
<p>客户端API：</p>
<ul>
<li>var ws = new WebSocket(‘ws://localhost:8080’);</li>
<li>webSocket.readyState 0=正在连接 1=连接成功 2=连接正在关闭 3=连接已经关闭</li>
<li>ws.onopen= function(){} 连接成功后的回调函数</li>
<li>ws.onclose = function(){} 连接关闭后的回调函数</li>
<li>onmessage 收到信息后 event.data instanceof ArrayBuffer || String</li>
<li>ws.send(‘your message’);</li>
<li>ws.bufferedAmount 还有多少字节没有发送完 判断是否发送完毕</li>
<li>ws.onerror</li>
</ul>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><ul>
<li>原型链</li>
<li>构造函数</li>
<li>组合继承</li>
<li>原型式继承</li>
<li>寄生式继承</li>
<li>寄生组合式继承</li>
</ul>
<h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul>
<li>工厂模式</li>
<li>构造函数模式</li>
<li>原型模式</li>
<li>组合模式</li>
<li>动态原型模式</li>
<li>寄生构造模式</li>
<li>稳妥构造模式</li>
</ul>
<h3 id="js跨域"><a href="#js跨域" class="headerlink" title="js跨域"></a>js跨域</h3><p>同源策略要求三个相同：协议相同、域名相同、端口相同</p>
<ul>
<li>cors</li>
<li>图像ping</li>
<li>jsonp</li>
<li>iframe+document.domain：适用于主域相同而子域不同的情况，设置相同的domain，然后在a页面中创建b页面的iframe，获取ifr.contentDocument就可以操作b</li>
<li>iframe+location.hash:src指向目标，hash中带参数，目标页面处理之后设置一个src指向代理文件，代理文件通过parent.parent.location.hash向源文件传递参数，源文件通过hashchange事件获取hash</li>
<li>iframe+window.name:window.name2MB而且在页面切换后不会变，先iframe.src指向跨域地址，在onload时转向当前域下一空文件，之前取到的window.name依然不变</li>
<li>代理服务器</li>
<li>postmessage</li>
</ul>
<h3 id="服务器推送"><a href="#服务器推送" class="headerlink" title="服务器推送"></a>服务器推送</h3><ul>
<li>comet</li>
<li>sse</li>
<li>websocket</li>
</ul>
<h3 id="多页面传参数"><a href="#多页面传参数" class="headerlink" title="多页面传参数"></a>多页面传参数</h3><ul>
<li>cookie轮询</li>
<li>localStorage和storage事件</li>
<li>websocket</li>
</ul>
<h3 id="深拷贝和浅拷贝"><a href="#深拷贝和浅拷贝" class="headerlink" title="深拷贝和浅拷贝"></a>深拷贝和浅拷贝</h3><p>浅拷贝分两种情况，拷贝直接拷贝源对象的引用 和 源对象拷贝实例.对于第二种情况，常用方法为<code>Array.prototype.slice(), Array.prototype.concat(), jQury的$.extend({},obj)</code></p>
<pre><code>function shallowCopy(src) {
  var dst = {};
  for (var prop in src) {
    if (src.hasOwnProperty(prop)) {
      dst[prop] = src[prop];
    }
  }
  return dst;
}</code></pre><p>深拷贝后，两个对象，包括其内部的元素互不干扰。常见方法有JSON.parse(),JSON.stringify()，jQury的<code>$.extend(true,{},obj)</code>，lodash的<code>_.cloneDeep和_.clone(value, true)。</code>有两种解决方案：</p>
<pre><code>JSON.parse(JSON.stringify(test))
function clone(p,s){
　　var s=s||{};
　　for(var prop in p){
　　　　if(typeof p[prop]==&#39;object&#39;){
　　　　　　　　s[prop]=(p[prop].constructor===Array)?[]:{};//三元运算，将s[prop]初始化为数组或者对象
　　　　　　　　clone(p[prop],s[prop])
　　　　}
　　　　else{
　　　　　　s[prop]=p[prop];
　　　　}
};
　　　　return s;
};</code></pre><h3 id="js事件模型"><a href="#js事件模型" class="headerlink" title="js事件模型"></a>js事件模型</h3><h4 id="DOM0级模型"><a href="#DOM0级模型" class="headerlink" title="DOM0级模型"></a>DOM0级模型</h4><p>又称原始事件模型，事件不会传播，没有事件流的概念。事件绑定通过在html代码中直接写<code>onclick</code> 或者在js中通过<code>.onclick=xxx</code>实现，如果取消可以将其指向<code>null</code>。</p>
<h4 id="DOM2级模型"><a href="#DOM2级模型" class="headerlink" title="DOM2级模型"></a>DOM2级模型</h4><p>分为事件捕获阶段，事件处理阶段，事件冒泡阶段。通过 <code>addEventListener</code>和<code>removeEventListener</code>。<br>参数有三个：</p>
<ul>
<li>eventType指定事件类型(不要加on)</li>
<li>handler是事件处理函数</li>
<li>useCapture是一个boolean用于指定是否在捕获阶段进行处理，一般设置为false与IE浏览器保持一致。</li>
</ul>
<h4 id="IE事件模型"><a href="#IE事件模型" class="headerlink" title="IE事件模型"></a>IE事件模型</h4><p>事件处理和事件冒泡阶段。<br><code>attachEvent</code>和<code>detachEvent</code></p>
<h4 id="DOM事件模型和IE事件模型的区别"><a href="#DOM事件模型和IE事件模型的区别" class="headerlink" title="DOM事件模型和IE事件模型的区别"></a>DOM事件模型和IE事件模型的区别</h4><ul>
<li>event和window.event</li>
<li>target和srcElement</li>
<li>stopPropagation和cancelBubble</li>
<li>preventDefault和returnValue</li>
</ul>
<h3 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h3><p>可以在全局最顶端声明，也可以在某个函数顶端声明。</p>
<ul>
<li>全局变量必须显式声明</li>
<li>禁止使用with语句</li>
<li>eval自己存在独立的作用域</li>
<li>禁止this指向全局对象</li>
<li>禁止删除变量</li>
<li>禁止重名</li>
</ul>
<h3 id="js模块化"><a href="#js模块化" class="headerlink" title="js模块化"></a>js模块化</h3><ul>
<li>无模块化：分js文件写script。缺点是污染全局作用域和依赖关系不明显。</li>
<li>CommonJS：CommonJS的核心思想就是通过 require 方法来同步加载所要依赖的其他模块，然后通过 exports 或者 module.exports 来导出需要暴露的接口。用于node端，同步加载模块，不适用于浏览器端。</li>
<li>AMD：require.js。通过define来定义一个模块，然后使用require来加载一个模块。前置加载依赖。</li>
<li>CMD：sea.js，按需加载，依赖就近。</li>
<li>ES6模块化：import导入，export导出。</li>
</ul>
<h2 id="缓存和离线存储"><a href="#缓存和离线存储" class="headerlink" title="缓存和离线存储"></a>缓存和离线存储</h2><h3 id="http缓存"><a href="#http缓存" class="headerlink" title="http缓存"></a>http缓存</h3><ul>
<li>判断Cache-Control或者expires，如果未过期，直接读取http缓存文件，不发送http请求。</li>
<li>判断是否有etag，有则带上if-none-mathch发送请求，未修改返回304，修改返回200。</li>
<li>判断是否有last-modified，有则带上if-modified-since，有效返回200，无效返回304。</li>
</ul>
<p><img src="https://images2017.cnblogs.com/blog/621603/201709/621603-20170925162600417-90375901.png" srcset="undefined" alt="img"><br><code>crtl+f5</code>可以强制刷新。</p>
<h3 id="session-cookie-localStorage-sessionStorage"><a href="#session-cookie-localStorage-sessionStorage" class="headerlink" title="session cookie localStorage sessionStorage"></a>session cookie localStorage sessionStorage</h3><ul>
<li>session和cookie<br>session存在服务器端，cookie存在浏览器端。cookie只能保存字符串类型，session通过类似于hashtable的数据结构存储任何类型的对象。cookie4kb，session无限制。session更安全。</li>
<li>localStorage sessionStorage<br>localStorage永久，sessionStorage仅在当前会话下有效，关闭浏览器窗口失效。存储都是5MB。都存在客户端，只能存文本类型。lcoalStorage的接口有getItem、setItem、removeItem、clear，另外存储时还会触发storage事件。</li>
</ul>
<h3 id="manifest"><a href="#manifest" class="headerlink" title="manifest"></a>manifest</h3><p>``</p>
<p>其分为三个部分：</p>
<ul>
<li>CACHE MANIFEST 缓存</li>
<li>NETWORK 不缓存</li>
<li>FALLBACK 无法访问时的回退</li>
</ul>
<p>window.applicationCache.status可以访问缓存状态，分别为：UNCACHED、IDLE、CHECKING、DOWNLOADING、UPDATEREADY、IDLE</p>
<p>离线缓存与传统浏览器缓存区别：</p>
<ul>
<li>离线缓存是针对整个应用，浏览器缓存是单个文件</li>
<li>离线缓存断网了还是可以打开页面，浏览器缓存不行</li>
<li>离线缓存可以主动通知浏览器更新资源</li>
</ul>
<h3 id="http缓存机制"><a href="#http缓存机制" class="headerlink" title="http缓存机制"></a>http缓存机制</h3><ul>
<li>Cache-Control：响应头表示了资源是否可以被缓存，以及缓存的有效期。</li>
<li>Etag：响应头标识了资源的版本，此后浏览器可据此进行缓存以及询问服务器。</li>
<li>Last-Modified：响应头标识了资源的修改时间，此后浏览器可据此进行缓存以及询问服务器。</li>
</ul>
<p>缓存策略三要素：</p>
<ul>
<li>缓存存储策略</li>
<li>缓存过期策略</li>
<li>缓存对比策略</li>
</ul>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "面试要点整理&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
