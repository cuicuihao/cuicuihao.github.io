<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="description" content="">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  <title>java面试题 ~ Hexo</title>

  <link rel="stylesheet" href="/lib/font-awesome/css/all.min.css"  >
<link rel="stylesheet" href="/lib/bootstrap/css/bootstrap.min.css"  >
<link rel="stylesheet" href="/lib/mdbootstrap/css/mdb.min.css"  >
<link rel="stylesheet" href="/lib/github-markdown/github-markdown.min.css"  >

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link rel="stylesheet" href="/lib/prettify/tomorrow-night-eighties.min.css"  >

<link rel="stylesheet" href="/css/main.css"  >


  <link rel="stylesheet" href="/lib/fancybox/jquery.fancybox.min.css"  >


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/">&nbsp;<strong>cuicuihao</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/">Home</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/archives/">Archives</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/categories/">Categories</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/tags/">Tags</a>
          </li>
        
          
          
          <li class="nav-item">
            <a class="nav-link" href="/about/">About</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>


</nav>

    <div class="view intro-2" id="background"
         style="background: url('/img/default.png')no-repeat center center;
           background-size: cover;
           background-attachment: fixed;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              <br>
              
                <p class="mt-3">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>&nbsp;
                  星期一, 三月 2日 2020, 10:28 上午
                </p>
              

              <p>
                
                  
                  &nbsp;<i class="far fa-chart-bar"></i>
                  <span class="post-count">
                    4.9k 字
                  </span>&nbsp;
                

                
                  
                  &nbsp;<i class="far fa-clock"></i>
                  <span class="post-count">
                      18 分钟
                  </span>&nbsp;
                

                
                  <!-- 不蒜子统计文章PV -->
                  
                  &nbsp;<i class="far fa-eye" aria-hidden="true"></i>&nbsp;
                  <span id="busuanzi_container_page_pv">
                    <span id="busuanzi_value_page_pv"></span> 次
                  </span>&nbsp;
                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="py-5 z-depth-3" id="board">
        <div class="post-content mx-auto" id="post">
          <div class="markdown-body">
            <h5 id="1、面向对象的特征有哪些方面？"><a href="#1、面向对象的特征有哪些方面？" class="headerlink" title="1、面向对象的特征有哪些方面？"></a>1、面向对象的特征有哪些方面？</h5><p>答：抽象、封装、继承、多态</p>
<h5 id="2、访问修饰符public-private-protected-以及不写（默认）时的区别？"><a href="#2、访问修饰符public-private-protected-以及不写（默认）时的区别？" class="headerlink" title="2、访问修饰符public,private,protected,以及不写（默认）时的区别？"></a>2、访问修饰符public,private,protected,以及不写（默认）时的区别？</h5><p>​             当前类                当前包                        子类                     其它</p>
<pre><code>public        √             √                 √              √   
protected     √             √                 √              ×     
default       √             √                 √              ×     
private       √             ×                 ×              ×        </code></pre><h5 id="3、String-是最基本的数据类型吗？"><a href="#3、String-是最基本的数据类型吗？" class="headerlink" title="3、String 是最基本的数据类型吗？"></a>3、String 是最基本的数据类型吗？</h5><p>不是，Java是面向对象编程，String是一个封装的类</p>
<h5 id="4、float-f-3-4-是否正确？"><a href="#4、float-f-3-4-是否正确？" class="headerlink" title="4、float f=3.4;是否正确？"></a>4、float f=3.4;是否正确？</h5><p>不正确，应该是float f=(float)3.4或者float f=34.F;</p>
<h5 id="5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？"><a href="#5、short-s1-1-s1-s1-1-有错吗-short-s1-1-s1-1-有错吗？" class="headerlink" title="5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？"></a>5、short s1 = 1; s1 = s1 + 1;有错吗?short s1 = 1; s1 += 1;有错吗？</h5><p>short s1 = 1; s1 = s1 + 1;有错 s1是short类型,1是int类型，要进行强制类型转换short s1 = 1; s1 = (short)(s1 + 1);<br>short s1 = 1; s1 += 1;正确，它会被换为s1 = (short)(s1 + 1);</p>
<h5 id="6、int和Integer有什么区别？"><a href="#6、int和Integer有什么区别？" class="headerlink" title="6、int和Integer有什么区别？"></a>6、int和Integer有什么区别？</h5><p>答：Java是一个近乎纯洁的面向对象编程语言，但是为了编程的方便还是引入了基本数据类型，但是为了能够将这些基本数据类型当成对象操作，Java为每一个基本数据类型都引入了对应的包装类型（wrapper class），int的包装类就是Integer，从Java 5开始引入了自动装箱/拆箱机制，使得二者可以相互转换。</p>
<pre><code class="java">class AutoUnboxingTest {
  public static void main(String[] args) {
    Integer a = new Integer(3);
    Integer b = 3;         // 将3自动装箱成Integer类型
    int c = 3;
    System.out.println(a == b);   // false 两个引用没有引用同一对象
    System.out.println(a == c);   // true a自动拆箱成int类型再和c比较
  }
}</code></pre>
<p>最近还遇到一个面试题，也是和自动装箱和拆箱有点关系的，代码如下所示：</p>
<pre><code class="java">public class Test03 {

  public static void main(String[] args) {
    Integer f1 = 100, f2 = 100, f3 = 150, f4 = 150;
    System.out.println(f1 == f2);
    System.out.println(f3 == f4);
  }

}</code></pre>
<p>如果不明就里很容易认为两个输出要么都是true要么都是false。首先需要注意的是f1、f2、f3、f4四个变量都是Integer对象引用，所以下面的==运算比较的不是值而是引用。装箱的本质是什么呢？当我们给一个Integer对象赋一个int值的时候，会调用Integer类的静态方法valueOf</p>
<pre><code class="java">public static Integer valueOf(int i) {
  if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
    return IntegerCache.cache[i + (-IntegerCache.low)];
  return new Integer(i);
}</code></pre>
<p>简单的说，如果整型字面量的值在-128到127之间，那么不会new新的Integer对象，而是直接引用常量池中的Integer对象，所以上面的面试题中f1==f2的结果是true，而f3==f4的结果是false。</p>
<h5 id="7、-amp-和-amp-amp-的区别？"><a href="#7、-amp-和-amp-amp-的区别？" class="headerlink" title="7、&amp;和&amp;&amp;的区别？"></a>7、&amp;和&amp;&amp;的区别？</h5><p>&amp;是位运算符，&amp;&amp;是逻辑运算符；&amp;运算时它的前后两个表达式都要运算然后给出结果，&amp;&amp;运算时如果前面哪个表达式的值是false则不用计算后面的表达式，<br>直接给出结果false</p>
<h5 id="8、解释内存中的栈-stack-、堆-heap-和方法区、常量池的用法。"><a href="#8、解释内存中的栈-stack-、堆-heap-和方法区、常量池的用法。" class="headerlink" title="8、解释内存中的栈(stack)、堆(heap)和方法区、常量池的用法。"></a>8、解释内存中的栈(stack)、堆(heap)和方法区、常量池的用法。</h5><p>栈存储的是变量名，堆存储的是对象，静态区存储使用static修饰的属性和方法</p>
<h5 id="9、Math-round-11-5-等于多少？Math-round-11-5-等于多少？"><a href="#9、Math-round-11-5-等于多少？Math-round-11-5-等于多少？" class="headerlink" title="9、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？"></a>9、Math.round(11.5) 等于多少？Math.round(-11.5)等于多少？</h5><p>Math.round(11.5) 等于12</p>
<p>Math.round(-11.5)等于-11</p>
<h5 id="10、switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？"><a href="#10、switch-是否能作用在byte-上，是否能作用在long-上，是否能作用在String上？" class="headerlink" title="10、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？"></a>10、switch 是否能作用在byte 上，是否能作用在long 上，是否能作用在String上？</h5><p>switch循环支持byte</p>
<p> String,不支持long</p>
<h5 id="11、用最有效率的方法计算2乘以8？"><a href="#11、用最有效率的方法计算2乘以8？" class="headerlink" title="11、用最有效率的方法计算2乘以8？"></a>11、用最有效率的方法计算2乘以8？</h5><p>2&lt;&lt;8</p>
<h5 id="12、数组有没有length-方法？String有没有length-方法？"><a href="#12、数组有没有length-方法？String有没有length-方法？" class="headerlink" title="12、数组有没有length()方法？String有没有length()方法？"></a>12、数组有没有length()方法？String有没有length()方法？</h5><p>数组有没有length()方法,有length属性,String有length()方法</p>
<h5 id="13、构造器（constructor）是否可被重写（override）？"><a href="#13、构造器（constructor）是否可被重写（override）？" class="headerlink" title="13、构造器（constructor）是否可被重写（override）？"></a>13、构造器（constructor）是否可被重写（override）？</h5><p>构造器只有一个不能被重写，但是可以被重载</p>
<h5 id="14、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？"><a href="#14、两个对象值相同-x-equals-y-true-，但却可有不同的hash-code，这句话对不对？" class="headerlink" title="14、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？"></a>14、两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对？</h5><p>不对，.equals方法对比的是两个值的地址，地址相同hashcode也相同</p>
<h5 id="15、是否可以继承String类？"><a href="#15、是否可以继承String类？" class="headerlink" title="15、是否可以继承String类？"></a>15、是否可以继承String类？</h5><p>不可以,String类是用final修饰的</p>
<h5 id="16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"><a href="#16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？" class="headerlink" title="16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？"></a>16、当一个对象被当作参数传递到一个方法后，此方法可改变这个对象的属性，并可返回变化后的结果，那么这里到底是值传递还是引用传递？</h5><p>值传递</p>
<h5 id="17、String和StringBuilder、StringBuffer的区别？"><a href="#17、String和StringBuilder、StringBuffer的区别？" class="headerlink" title="17、String和StringBuilder、StringBuffer的区别？"></a>17、String和StringBuilder、StringBuffer的区别？</h5><p>String再循环中每次都会创建一个新的String对象，StringBuilder和StringBuffer是始终使用一个对象，所以更快，StringBuilder可以使用多线程速度稍微比StringBuffer慢点，StringBuffer只能单线程速度最快</p>
<h5 id="18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"><a href="#18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？" class="headerlink" title="18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？"></a>18、重载（Overload）和重写（Override）的区别。重载的方法能否根据返回类型进行区分？</h5><p>重载是在一个类中除方法名必须相同外其他不必相同；重写是子类对父类方法的重写，除方法体不相同，其他必须相同，子类的修饰符范围必须大于或等于父类的修饰符，重载的方法可以根据返回类型进行区分</p>
<h5 id="19、描述一下JVM加载class文件的原理机制？"><a href="#19、描述一下JVM加载class文件的原理机制？" class="headerlink" title="19、描述一下JVM加载class文件的原理机制？"></a>19、描述一下JVM加载class文件的原理机制？</h5><p>jvm是先把class文件转换为数组，在运行数组</p>
<h5 id="20、抽象类（abstract-class）和接口（interface）有什么异同？"><a href="#20、抽象类（abstract-class）和接口（interface）有什么异同？" class="headerlink" title="20、抽象类（abstract class）和接口（interface）有什么异同？"></a>20、抽象类（abstract class）和接口（interface）有什么异同？</h5><p>抽象类可以有构造方法，可以有方法体，修饰符可以是任意类型；接口不可以有构造方法，不可以有方法体，修饰符只能是public，接口每一个属性和方法都被默认为被public static final修饰。抽象可以被单继承，接口可以被多实现，它们都是一种规范和标准，约束类的行为，方法都要被重写</p>
<h5 id="21、Java-中会存在内存泄漏吗，请简单描述。"><a href="#21、Java-中会存在内存泄漏吗，请简单描述。" class="headerlink" title="21、Java 中会存在内存泄漏吗，请简单描述。"></a>21、Java 中会存在内存泄漏吗，请简单描述。</h5><p>不会存在内存泄漏，因为Java中有Gc垃圾回收机制，但是在实际应用中如果hasnmap session用完没有手动清空，关闭的话会存在内存泄漏</p>
<h5 id="22、GC是什么？为什么要有GC？"><a href="#22、GC是什么？为什么要有GC？" class="headerlink" title="22、GC是什么？为什么要有GC？"></a>22、GC是什么？为什么要有GC？</h5><p>Gc是垃圾回收机制,栈中的变量在使用后会自动删除，堆中存储的需要Gc垃圾回收机制回收。</p>
<h5 id="23、String-s-new-String-“xyz”-创建了几个字符串对象？"><a href="#23、String-s-new-String-“xyz”-创建了几个字符串对象？" class="headerlink" title="23、String s = new String(“xyz”);创建了几个字符串对象？"></a>23、String s = new String(“xyz”);创建了几个字符串对象？</h5><p>两个，“xyz”在变量池中，new String()在堆中</p>
<h5 id="24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？"><a href="#24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete-class）？" class="headerlink" title="24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？"></a>24、接口是否可继承（extends）接口？抽象类是否可实现（implements）接口？抽象类是否可继承具体类（concrete class）？</h5><p>接口是可以继承接口，抽象类是可以实现接口，抽象类是可以继承具体类</p>
<h5 id="25、Java-中的final关键字有哪些用法？"><a href="#25、Java-中的final关键字有哪些用法？" class="headerlink" title="25、Java 中的final关键字有哪些用法？"></a>25、Java 中的final关键字有哪些用法？</h5><p>Final修饰的属性是常量，不能改变；修饰的方法不能被重写；修饰的类不能被继承</p>
<h5 id="26、指出下面程序的运行结果。"><a href="#26、指出下面程序的运行结果。" class="headerlink" title="26、指出下面程序的运行结果。"></a>26、指出下面程序的运行结果。</h5><pre><code class="java">class A {   
  static {    
    System.out.print(&quot;1&quot;);  
  }   
  public A() {    
    System.out.print(&quot;2&quot;);  
  }
} 
class B extends A{   
  static {    
    System.out.print(&quot;a&quot;);  
  }   
  public B() {    
    System.out.print(&quot;b&quot;);  
  }
} 
public class Hello {   
  public static void main(String[] args) {    
    A ab = new B();    
    ab = new B();  
  } 
}</code></pre>
<p>1a2b2b,先执行父类的静态方法，在执行本类的静态方法，再依次执行父类和本类的构造方法</p>
<h5 id="27、数据类型之间的转换："><a href="#27、数据类型之间的转换：" class="headerlink" title="27、数据类型之间的转换："></a>27、数据类型之间的转换：</h5><p>int转换为字符串：int a=1;String b=a+”” ; String c=Intereg.valueof(a).toString();</p>
<p>字符串转换为int：String a=”1” int b=Intereg.valueof(a);</p>
<h5 id="28、如何实现字符串的反转及替换？"><a href="#28、如何实现字符串的反转及替换？" class="headerlink" title="28、如何实现字符串的反转及替换？"></a>28、如何实现字符串的反转及替换？</h5><p>StringBuffer result=new StringBuffer(“abc”);<br>result.revese().toString();</p>
<h5 id="29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"><a href="#29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？" class="headerlink" title="29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？"></a>29、怎样将GB2312编码的字符串转换为ISO-8859-1编码的字符串？</h5><p> String s1 = “你好”; </p>
<p> String s2 = new String(s1.getBytes(“GB2312”), “ISO-8859-1”); </p>
<h5 id="30、利用java-text-DataFormat-的子类（如SimpleDateFormat类）中的format-Date-方法可将日期格式化"><a href="#30、利用java-text-DataFormat-的子类（如SimpleDateFormat类）中的format-Date-方法可将日期格式化" class="headerlink" title="30、利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化"></a>30、利用java.text.DataFormat 的子类（如SimpleDateFormat类）中的format(Date)方法可将日期格式化</h5><p>String birthday=”2020-02-25”;<br>DateTimeFormatter fmt = DateTimeFormatter.ofPattern(“yyyy-MM-dd”);<br>LocalDate date2 = LocalDate.parse(birthday, fmt);</p>
<h5 id="31、比较一下Java和JavaSciprt。"><a href="#31、比较一下Java和JavaSciprt。" class="headerlink" title="31、比较一下Java和JavaSciprt。"></a>31、比较一下Java和JavaSciprt。</h5><p>Java是一种基于面向对象的编程语言，javaSciprt是一种解释性脚本语言</p>
<h5 id="32、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后"><a href="#32、try-里有一个return语句，那么紧跟在这个try后的finally-里的代码会不会被执行，什么时候被执行，在return前还是后" class="headerlink" title="32、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?"></a>32、try{}里有一个return语句，那么紧跟在这个try后的finally{}里的代码会不会被执行，什么时候被执行，在return前还是后?</h5><p>会执行，在return后执行</p>
<h5 id="33、列出一些你常见的运行时异常？"><a href="#33、列出一些你常见的运行时异常？" class="headerlink" title="33、列出一些你常见的运行时异常？"></a>33、列出一些你常见的运行时异常？</h5><p>1、ClassCastException(类转换异常)</p>
<p>2、IndexOutOfBoundsException(数组越界)</p>
<p>3、NullPointerException(空指针)</p>
<p>4、ArrayStoreException(数据存储异常，操作数组时类型不一致)</p>
<p>5、BufferOverflowException异常</p>
<h5 id="34、类ExampleA继承Exception，类ExampleB继承ExampleA。"><a href="#34、类ExampleA继承Exception，类ExampleB继承ExampleA。" class="headerlink" title="34、类ExampleA继承Exception，类ExampleB继承ExampleA。"></a>34、类ExampleA继承Exception，类ExampleB继承ExampleA。</h5><p>有如下代码片断：</p>
<pre><code class="java">        try {
              throw new ExampleB(&quot;b&quot;);
            } catch(ExampleA e){
              System.out.println(&quot;ExampleA&quot;);
            } catch(Exception e){
              System.out.println(&quot;Exception&quot;);
            }</code></pre>
<p>请问执行此段代码的输出是什么？</p>
<p>ExampleA</p>
<p>面试题 - 说出下面代码的运行结果。（此题的出处是《Java编程思想》一书）</p>
<pre><code class="java">class Annoyance extends Exception {}
class Sneeze extends Annoyance {}

class Human {
  public static void main(String[] args) 
    throws Exception {
    try {
      try {
        throw new Sneeze();
      } 
      catch ( Annoyance a ) {
        System.out.println(&quot;Caught Annoyance&quot;);
        throw a;
      }
    } 
    catch ( Sneeze s ) {
      System.out.println(&quot;Caught Sneeze&quot;);
      return ;
    }
    finally {
      System.out.println(&quot;Hello World!&quot;);
    }
  }
}</code></pre>
<p>输出：Caught Annoyance  Hello World!</p>
<pre><code class="java">try {
    throw new Annoyance(); 
} catch (Sneeze s) {  
    System.out.println(&quot;Caught Sneeze&quot;);  
  return;  
} finally {  
  System.out.println(&quot;Hello World!&quot;);  
}  </code></pre>
<p>输出：Hello World!</p>
<pre><code class="java">try {  
  throw new Annoyance(); 
} catch (Sneeze s) {   
  System.out.println(&quot;Caught Sneeze&quot;);  
  return;  
} catch (Exception e) {  
  System.out.println(&quot;Caught Exception&quot;);      
  return;  
} finally {
  System.out.println(&quot;Hello World!&quot;);
}  </code></pre>
<p>输出：Caught Exception Hello World!</p>
<h5 id="35、List、Set、Map是否继承自Collection接口？"><a href="#35、List、Set、Map是否继承自Collection接口？" class="headerlink" title="35、List、Set、Map是否继承自Collection接口？"></a>35、List、Set、Map是否继承自Collection接口？</h5><p>List、Set继承自Collection接口，map本身就是一个接口</p>
<h5 id="36、Collection和Collections的区别？"><a href="#36、Collection和Collections的区别？" class="headerlink" title="36、Collection和Collections的区别？"></a>36、Collection和Collections的区别？</h5><p>Collection是list,set集合的父接口，Collections是工具类</p>
<h5 id="37、List、Map、Set三个接口存取元素时，各有什么特点？"><a href="#37、List、Map、Set三个接口存取元素时，各有什么特点？" class="headerlink" title="37、List、Map、Set三个接口存取元素时，各有什么特点？"></a>37、List、Map、Set三个接口存取元素时，各有什么特点？</h5><p>List集合是无序的元素可以重复，可通过下标获取，</p>
<p>Set是有序的集合，元素不能重复，通过循环遍历每个元素，</p>
<p>map存储的是键值对  。</p>
<h5 id="38、Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别"><a href="#38、Thread类的sleep-方法和对象的wait-方法都可以让线程暂停执行，它们有什么区别" class="headerlink" title="38、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?"></a>38、Thread类的sleep()方法和对象的wait()方法都可以让线程暂停执行，它们有什么区别?</h5><p>Thread类的sleep()方法暂停指定时间段线程，</p>
<p>wait()方法暂停执行直到使用 start0方法 再次执行</p>
<h5 id="39、线程的sleep-方法和yield-方法有什么区别？"><a href="#39、线程的sleep-方法和yield-方法有什么区别？" class="headerlink" title="39、线程的sleep()方法和yield()方法有什么区别？"></a>39、线程的sleep()方法和yield()方法有什么区别？</h5><p>sleep()方法暂停指定时间段线程，yield()方法暂停当前正在执行的线程对象,并执行其他线程 </p>
<h5 id="40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"><a href="#40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？" class="headerlink" title="40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？"></a>40、当一个线程进入一个对象的synchronized方法A之后，其它线程是否可进入此对象的synchronized方法B？</h5><p>不可以，其他线程可以方法这个对象的非同步方法，同步方法不能进入，synchronized以获得这个对象的锁。</p>
<h5 id="41、请说出与线程同步以及线程调度相关的方法。"><a href="#41、请说出与线程同步以及线程调度相关的方法。" class="headerlink" title="41、请说出与线程同步以及线程调度相关的方法。"></a>41、请说出与线程同步以及线程调度相关的方法。</h5><p>wait(): 使一个线程处于等待(阻塞) 状态，并且释放所持有的对象的锁;</p>
<p> sleep():使-个正在运行的线程处于睡眠状态,是一个静态方法，调用此方法要处理<br>InterruptedException异常;<br>notify():唤醒一个处于等待状态的线程，当然在调用此方法的时候，并不能确切的唤醒某一<br>个等待状态的线程，而是由JVM确定唤醒哪个线程，而且与优先级无关;<br>notityAll():唤醒所有处于等待状态的线程，该方法并不是将对象的锁给所有线程，而是让它<br>们竞争，只有获得锁的线程才能进入就绪状态; </p>
<h5 id="42、编写多线程程序有几种实现方式？"><a href="#42、编写多线程程序有几种实现方式？" class="headerlink" title="42、编写多线程程序有几种实现方式？"></a>42、编写多线程程序有几种实现方式？</h5><p>一种是继承Thread类;另-种是实现Runnable接口。两种方式都要重写run()方法 </p>
<h5 id="43、synchronized关键字的用法？"><a href="#43、synchronized关键字的用法？" class="headerlink" title="43、synchronized关键字的用法？"></a>43、synchronized关键字的用法？</h5><p> synchronized关键字可以将对象或者方法标记为同步，以实现对对象和方法的互斥访问，<br>可以用synchronized(对象) { … }定义同步代码块，或者在声明方法时将synchronized作为方法<br>的修饰符。</p>
<h5 id="44、举例说明同步和异步。"><a href="#44、举例说明同步和异步。" class="headerlink" title="44、举例说明同步和异步。"></a>44、举例说明同步和异步。</h5><p>例如正在写的数据以后可能被另一个线程读到，或者正在读的数据可能已经被另一个线程写过了，那么这些数据就必须进行同步存取（数据库操作中的排他锁就是最好的例子）。当应用程序在对象上调用了一个需要花费很长时间来执行的方法，并且不希望让程序等待方法的返回时，就应该使用异步编程，在很多情况下采用异步途径往往更有效率。</p>
<h5 id="45、简述synchronized-和java-util-concurrent-locks-Lock的异同？"><a href="#45、简述synchronized-和java-util-concurrent-locks-Lock的异同？" class="headerlink" title="45、简述synchronized 和java.util.concurrent.locks.Lock的异同？"></a>45、简述synchronized 和java.util.concurrent.locks.Lock的异同？</h5><p> Lock能完成几乎所有synchronized的功能，并有一些后者不具备的功能， Lock 需要程序员在finally块中手工释放  ，在并发量小的时候，用synchronize是比较好的选择，并发量大的时候用Lock，synchronize是自动释放锁，Lock是主动释放锁，Lock可以设定所等待的时间。</p>
<h5 id="46、事务的ACID是指什么？"><a href="#46、事务的ACID是指什么？" class="headerlink" title="46、事务的ACID是指什么？"></a>46、事务的ACID是指什么？</h5><p>一致性(Consistent):事务结束后系统状态是一致的;<br>隔离性(Isolated): 并发执行的事务彼此无法看到对方的中间状态;<br>持久性(Durable): 事务完成后所做的改动都会被持久化，即使发生灾难性的失败。通过日志<br>和同步备份可以在故障发生后重建数据。 </p>
<h5 id="47、获得一个类的类对象有哪些方式？"><a href="#47、获得一个类的类对象有哪些方式？" class="headerlink" title="47、获得一个类的类对象有哪些方式？"></a>47、获得一个类的类对象有哪些方式？</h5><p>方法1:类型.class， 例如: String.class<br>方法2:对象.getClass(), 例如: “hello”.getClass()<br>方法3: Class.forName(), 例如: Class.forName(“java.lang.string) </p>
<h5 id="48、简述一下面向对象的”六原则一法则”。"><a href="#48、简述一下面向对象的”六原则一法则”。" class="headerlink" title="48、简述一下面向对象的”六原则一法则”。"></a>48、简述一下面向对象的”六原则一法则”。</h5><p> 单一职责原则:一个类只做它该做的事情 。</p>
<p> 开闭原则:软件实体应当对扩展开放，对修改关闭。 </p>
<p> 依赖倒转原则：面向接口编程。 </p>
<p> 里氏替换原则:任何时候都可以用子类型替换掉父类型。 </p>
<p> 接口隔离原则：接口要小而专，绝不能大而全。 </p>
<p> 合成聚合复用原则：优先使用聚合或合成关系复用代码。 </p>
<p> 迪米特法则：迪米特法则又叫最少知识原则，一个对象应当对其他对象有尽可能少的了解。 </p>
<h5 id="49、简述一下你了解的设计模式。"><a href="#49、简述一下你了解的设计模式。" class="headerlink" title="49、简述一下你了解的设计模式。"></a>49、简述一下你了解的设计模式。</h5><p>单例模式：某个类只能有一个实例，提供一个全局的访问点。</p>
<p>简单工厂：一个工厂类根据传入的参量决定创建出那一种产品类的实例。</p>
<p>工厂方法：定义一个创建对象的接口，让子类决定实例化那个类。</p>
<p>抽象工厂：创建相关或依赖对象的家族，而无需明确指定具体类。</p>
<p>建造者模式：封装一个复杂对象的构建过程，并可以按步骤构造。</p>
<p>原型模式：通过复制现有的实例来创建新的实例。</p>
<p>适配器模式：将一个类的方法接口转换成客户希望的另外一个接口。</p>
<p>组合模式：将对象组合成树形结构以表示“”部分-整体“”的层次结构。</p>
<p>装饰模式：动态的给对象添加新的功能。</p>
<p>代理模式：为其他对象提供一个代理以便控制这个对象的访问。</p>
<p>亨元（蝇量）模式：通过共享技术来有效的支持大量细粒度的对象。</p>
<p>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</p>
<p>桥接模式：将抽象部分和它的实现部分分离，使它们都可以独立的变化。</p>
<p>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</p>
<p>解释器模式：给定一个语言，定义它的文法的一种表示，并定义一个解释器。</p>
<p>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</p>
<p>状态模式：允许一个对象在其对象内部状态改变时改变它的行为。</p>
<p>观察者模式：对象间的一对多的依赖关系。</p>
<p>备忘录模式：在不破坏封装的前提下，保持对象的内部状态。</p>
<p>中介者模式：用一个中介对象来封装一系列的对象交互。</p>
<p>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化。</p>
<p>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</p>
<p>责任链模式：将请求的发送者和接收者解耦，使的多个对象都有处理这个请求的机会。</p>
<p>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构。</p>
<h5 id="50、用Java写一个冒泡排序。"><a href="#50、用Java写一个冒泡排序。" class="headerlink" title="50、用Java写一个冒泡排序。"></a>50、用Java写一个冒泡排序。</h5><pre><code class="java">for(int i=0;i&lt;arr . length-1;i++){//外层循环控制排序趟数
  for(int j=0;j&lt;arr. length-1-i;j++){//内层循环控制每- -趟排序多少次
    if(arr[jl&gt;arr[j+11){
        int temp=arr[j];
        arr[j]=arr[j+1];
        arrlj+1]=temp;
   }
}</code></pre>
<h5 id="51、用Java写一个二分查找。"><a href="#51、用Java写一个二分查找。" class="headerlink" title="51、用Java写一个二分查找。"></a>51、用Java写一个二分查找。</h5><p>非递归实现</p>
<pre><code class="java">public static int biSearch(int [ ]array,int a){
        int 1o=0;
        int hi=array.length-1;
        int mid;
      while(lo&lt;=hi){
            mid=(1o+hi)/2;
          if(array[mid]==a){
            return mid+1;
          }else if(array[mid]&lt;a){
            1o=mid+1;
          }else{
            hi=mid-1;
          }
        return -1;
      }
}</code></pre>
<p>递归实现</p>
<pre><code class="java">public static int binarySearch(int[] arr,int low,int high,int key ) {
        int mid = (low + high)/2;
        if(arr[mid] == key) {
            index = mid;
            return mid;
        }
        if(low&gt;high) {
            return -1;
        }else if(key &gt; arr[mid]) {
            return binarySearch(arr,mid+1,high,key);
        }else if(key &lt; arr[mid]) {
            return binarySearch(arr,low,mid-1,key);
        }
        return -1;
            }</code></pre>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="52、Servlet的运行过程？"><a href="#52、Servlet的运行过程？" class="headerlink" title="52、Servlet的运行过程？"></a>52、Servlet的运行过程？</h5><p> Web容器加载Servlet并将其实例化后，Servlet生 命周期开始，容器运行其init(方法进行<br>Servlet的初始化;请求到达时调用Servlet的service(方法，service()方法 会根据需要调用与请<br>求对应的doGet或doPost等方法;当服务器关闭或项目被卸载时服务器会将Servlet实例销毁,<br>此时会调用Servlet的destroy0方法 </p>
<h5 id="53、转发（forward）和重定向（redirect）的区别？"><a href="#53、转发（forward）和重定向（redirect）的区别？" class="headerlink" title="53、转发（forward）和重定向（redirect）的区别？"></a>53、转发（forward）和重定向（redirect）的区别？</h5><p>转发是服务器行为,重定向是客户端行为<br>1.转发在服务器端完成的;重定向是在客户端完成的<br>2.转发的速度快;重定向速度慢<br>3.转发的是同一次请求，会提示是否重新提交订单;重定向是两次不同请求<br>4.转发不会执行转发后的代码;重定向会执行重定向之后的代码<br>5.转发地址栏没有变化;重定向地址栏有变化<br>6.转发必须是在同一台服务器下完成;重定向可以在不同的服务器下完成</p>
<h5 id="54、JSP有哪些内置对象？作用分别是什么？"><a href="#54、JSP有哪些内置对象？作用分别是什么？" class="headerlink" title="54、JSP有哪些内置对象？作用分别是什么？"></a>54、JSP有哪些内置对象？作用分别是什么？</h5><p> JSP有9个内置对象:<br>- request;封装客户端的请求，其中包含来自GET或POST请求的参数; .<br>- response:封装服务器对客户端的响应;<br>- pageContext:通过该对象可以获取其他对象;<br>. session:封装用户会话的对象;<br>. application:封装服务器运行环境的对象;<br>- out: 输出服务器响应的输出流对象;<br>- config: Web应用的配置对象;<br>- page: JSP页面本身(相当于Java程序中的this) ;<br>- exception: 封装页面抛出异常的对象。 </p>
<h5 id="55、讲解JSP中的四种作用域。"><a href="#55、讲解JSP中的四种作用域。" class="headerlink" title="55、讲解JSP中的四种作用域。"></a>55、讲解JSP中的四种作用域。</h5><p> SP中的四种作用域包括page. request. session和application, 具体来说:<br>- page代表与一个页面相关的对象和属性。<br>- request代表与Web客户机发出的一个请求相关的对象和属性。一个请求可能跨越多个页面，<br>涉及多个Web组件;需要在页面显示的临时数据可以置于此作用域。<br>- session代表与某个用户与服务器建立的一次会话相关的对象和属性。跟某个用户相关的数据<br>应该放在用户自己的session中。<br>. application代表与整个Web应用程序相关的对象和属性，它实质上是跨越整个Web应用程<br>序，包括多个页面、请求和会话的一个全局作用域。 </p>

            <hr>
          </div>
          <br>
          <div>
            <p>
            
            
            </p>
            
              <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
            
          </div>
        </div>
      </div>
    </div>
    <div class="d-none d-lg-block col-lg-2 toc-container">
      
  <div id="toc">
    <p class="h4"><i class="far fa-list-alt"></i>&nbsp;目录</p>
    <div id="tocbot"></div>
  </div>

    </div>
  </div>
</div>

<!-- custom -->


<!-- Comments -->
<div class="col-lg-7 mx-auto nopadding-md">
  <div class="container comments mx-auto" id="comments">
    
  </div>
</div>

    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  <footer class="mt-5">
  <div class="text-center py-3">
    <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
    <i class="iconfont icon-love"></i>
    <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    <br>

    
  
    <!-- 不蒜子统计PV -->
    
    &nbsp;<span id="busuanzi_container_site_pv">总访问量 
          <span id="busuanzi_value_site_pv"></span> 次</span>&nbsp;
  
  
    <!-- 不蒜子统计UV -->
    
    &nbsp;<span id="busuanzi_container_site_uv">总访客数 
            <span id="busuanzi_value_site_uv"></span> 人</span>&nbsp;
  
  <br>



    

  </div>
</footer>

<!-- SCRIPTS -->
<script src="/lib/jquery/jquery.min.js" ></script>
<script src="/lib/popper/popper.min.js" ></script>
<script src="/lib/bootstrap/js/bootstrap.min.js" ></script>
<script src="/lib/mdbootstrap/js/mdb.min.js" ></script>
<script src="/js/main.js" ></script>


  <script src="/js/lazyload.js" ></script>



  
    <script src="/lib/tocbot/tocbot.min.js" ></script>
  
  <script src="/js/post.js" ></script>



  <script src="/lib/smooth-scroll/smooth-scroll.min.js" ></script>



  <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>


<!-- Plugins -->


  

  

  

  

  




  <script src="/lib/prettify/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script src="/lib/typed/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "java面试题&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script src="/lib/anchor/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "false",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script src="/js/local-search.js" ></script>
  <script>
    var path = "/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script src="/lib/fancybox/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>







</body>
</html>
